<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>WinAPI文档 | yui1111</title><meta name="keywords" content="C++,WinAPI"><meta name="author" content="yui1111"><meta name="copyright" content="yui1111"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="注：转载自小甲鱼-鱼c论坛 ，归纳一下方便自己学习&#x2F;&#x2F;SetScrollRange 函数BeginPaint函数功能：BeginPaint 函数为指定窗口进行绘画作准备，并用将和绘画有关的信息填充到一个 PAINTSTRUCT 结构中。 API 函数原型：1234HDC BeginPaint(  _In_   HWND hwnd,  _Out_  LPPAINTSTRUCT lpPaint);">
<meta property="og:type" content="article">
<meta property="og:title" content="WinAPI文档">
<meta property="og:url" content="https://yui1111.github.io/2021/10/26/WinAPI%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="yui1111">
<meta property="og:description" content="注：转载自小甲鱼-鱼c论坛 ，归纳一下方便自己学习&#x2F;&#x2F;SetScrollRange 函数BeginPaint函数功能：BeginPaint 函数为指定窗口进行绘画作准备，并用将和绘画有关的信息填充到一个 PAINTSTRUCT 结构中。 API 函数原型：1234HDC BeginPaint(  _In_   HWND hwnd,  _Out_  LPPAINTSTRUCT lpPaint);">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yui1111.github.io/img/43.png">
<meta property="article:published_time" content="2021-10-26T14:00:51.000Z">
<meta property="article:modified_time" content="2021-10-28T14:32:44.093Z">
<meta property="article:author" content="yui1111">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="WinAPI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yui1111.github.io/img/43.png"><link rel="shortcut icon" href="/img/11.png"><link rel="canonical" href="https://yui1111.github.io/2021/10/26/WinAPI%E6%96%87%E6%A1%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-28 22:32:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/shubiao.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/12.jpg" onerror="onerror=null;src='/img/4041.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home/主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags/标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories/分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link/友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-heart"></i><span> Gallery/相册</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/43.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">yui1111</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home/主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags/标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories/分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link/友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-heart"></i><span> Gallery/相册</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WinAPI文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-26T14:00:51.000Z" title="发表于 2021-10-26 22:00:51">2021-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-28T14:32:44.093Z" title="更新于 2021-10-28 22:32:44">2021-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/WinAPI%E6%96%87%E6%A1%A3/">WinAPI文档</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：转载自<a target="_blank" rel="noopener" href="https://fishc.com.cn/forum-207-1.html">小甲鱼-鱼c论坛</a> ，归纳一下方便自己学习//SetScrollRange</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="BeginPaint"><a href="#BeginPaint" class="headerlink" title="BeginPaint"></a>BeginPaint</h2><h3 id="函数功能："><a href="#函数功能：" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>BeginPaint 函数为指定窗口进行绘画作准备，并用将和绘画有关的信息填充到一个 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>中。</p>
<h3 id="API-函数原型："><a href="#API-函数原型：" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">BeginPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HWND hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPPAINTSTRUCT lpPaint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hwnd</td>
<td>需要重新绘制的窗口句柄</td>
</tr>
<tr>
<td>lpPaint</td>
<td>指向 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>的指针，用于存放绘画相关的信息</td>
</tr>
</tbody></table>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数成功，返回值是指定窗口的“显示设备描述表”句柄；</p>
</li>
<li><p>如果函数失败，返回值是 NULL，表明没有得到显示设备的内容。</p>
</li>
</ol>
<h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>BeginPaint 函数自动设置显示设备内容的剪切区域，而排除任何更新区域外的区域。该更新区域可以通过 InvalidateRect 或 InvalidateRgn 函数设置，也可以是系统在改变大小、移动、创建、滚动后设置的，或者其他的影响客户区的操作来设置的。</p>
</li>
<li><p>如果更新区域被标记为可擦除的，BeginPaint 发送一个 WM_ERASEBKGND 消息给窗口。</p>
</li>
<li><p>一个应用程序除了响应 WM_PAINT 消息外，不应该调用 BeginPaint。</p>
</li>
<li><p>每次调用 BeginPaint 都应该有相应的 EndPaint 函数。</p>
</li>
<li><p>如果被绘画的客户区中有一个 caret（caret：插入符。是窗口客户区中的一个闪烁的线，块，或位图。插入符通常表示文本或图形将被插入的地方。即一闪一闪的光标），BeginPaint 自动隐藏该符号，而保证它不被擦除。</p>
</li>
<li><p>如果窗口类有一个背景刷，BeginPaint 使用这个刷子来擦除更新区域的背景。</p>
</li>
</ol>
<h2 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h2><h3 id="函数功能：-1"><a href="#函数功能：-1" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>CreateWindow 函数创建一个重叠式窗口、弹出式窗口或子窗口。它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。函数也指该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。</p>
<p>若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数。</p>
<h3 id="API-函数原型：-1"><a href="#API-函数原型：-1" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code>说明该参数是可选参数。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND WINAPI <span class="title">CreateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpClassName,    <span class="comment">// 窗口类名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpWindowName,   <span class="comment">// 窗口标题</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD dwStyle,          <span class="comment">// 窗口风格，或称窗口格式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> x,                  <span class="comment">// 初始 x 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> y,                  <span class="comment">// 初始 y 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> nWidth,             <span class="comment">// 初始 x 方向尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> nHeight,            <span class="comment">// 初始 y 方向尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWndParent,        <span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HMENU hMenu,            <span class="comment">// 窗口菜单句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HINSTANCE hInstance,    <span class="comment">// 程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPVOID lpParam          <span class="comment">// 创建参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-1"><a href="#参数解析：-1" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpClassName</td>
<td>1. 窗口类名称，可以是一个指向 NULL 结束的字符串或一个整型数值 2. 如果是字符串，它指定了窗口的类名。这个类名可以是任何用函数 RegisterClass 注册的类名，或是任何预定义的控制类名 3. 如是一个整型量，它是由此前调用 theGlobalAddAtom 函数产生的全局量。这个小于 0xC000 的 16 位数必须是 lpClassName 参数字的低 16 位，该参数的高位必须是 0</td>
</tr>
<tr>
<td>lpWindowName</td>
<td>1. 窗口标题，一个指向 NULL 结束的字符串指针 2. 如果窗口风格指定了标题条，由 lpWindowName 指向的窗口标题将显示在标题条上 3. 当使用 Createwindow 函数来创建控制例如按钮，选择框和静态控制时，可使用 lpWindowName 来指定控制文本</td>
</tr>
<tr>
<td>dwStyle</td>
<td>指定创建窗口的风格（详见下方↓）</td>
</tr>
<tr>
<td>x</td>
<td>1. 指定窗口的初始水平位置（x 坐标） 2. 对一个层叠或弹出式窗口，x 参数是屏幕坐标系的窗口的左上角的初始 x 坐标 3. 对于子窗口，x 是子窗口左上角相对父窗口客户区左上角的初始 x 坐标 4. 如果该参数被设为 CW_USEDEFAULT 则系统为窗口选择缺省的左上角坐标并忽略 y 参数，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口或子窗口设定，则 x 和 y 参数被设为零。</td>
</tr>
<tr>
<td>y</td>
<td>1. 指定窗口的初始垂直位置（y 坐标） 2. 对一个层叠或弹出式窗口，y 参数是屏幕坐标系的窗口的左上角的初始 y 坐标 3. 对于子窗口，y 是子窗口左上角相对父窗口客户区左上角的初始 y 坐标 4. 对于列表框，y 是列表框客户区左上角相对父窗口客户区左上角的初始 y 坐标 5. 如果层叠窗口是使用 WS_VISIBLE 风格位创建的并且 x 参数被设为 CW_USEDEFAULT，则系统将忽略 y 参数</td>
</tr>
<tr>
<td>nWidth</td>
<td>1. 以设备单元指明窗口的宽度 2. 对于层叠窗口，nWidth 的值或是屏幕坐标的窗口宽度或是 CW_USEDEFAULT 3. 若 nWidth 是 CW_USEDEFAULT，则系统为窗口选择一个默认的高度和宽度（默认宽度为从初始 x 坐标开始到屏幕的右边界，缺省高度为从初始 y 坐标开始到目标区域的顶部。)，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口和子窗口设定 CW_USEDEFAULT 标志则 nWidth 和 nHeight 被设为零</td>
</tr>
<tr>
<td>nHeight</td>
<td>1. 以设备单元指明窗口的高度 2. 对于层叠窗口，nHeight 是屏幕坐标的窗口宽度 3. 若 nWidth 被设为 CW_USEDEFAULT，则系统忽略 nHeight 参数，自动为 nWidth 和 nHeight 设置默认参数</td>
</tr>
<tr>
<td>hWndParent</td>
<td>1. 指向被创建窗口的父窗口或所有者窗口的句柄 2. 若要创建一个子窗口或一个从属窗口，需提供一个有效的窗口句柄 3. 创建一个单纯的消息窗口，可以提供 HWND_MESSAGE 或提供一个己存在的消息窗口的句柄</td>
</tr>
<tr>
<td>hMenu</td>
<td>1. 指向窗口菜单句柄，或依据窗口风格指明一个子窗口标识 2. 对于层叠或弹出式窗口，hMenu 指定窗口使用的菜单：如果使用了菜单类，则 hMenu 可以为 NULL 3. 对于子窗口，hMenu 指定了该子窗口标识（一个整型量），一个对话框使用这个整型值将事件通知父类。应用程序确定子窗口标识，这个值对于相同父窗口的所有子窗口必须是唯一的</td>
</tr>
<tr>
<td>hInstance</td>
<td>与窗口相关联的模块实例的句柄</td>
</tr>
<tr>
<td>lpParam</td>
<td>1. 指向一个值的指针，该值传递给窗口 WM_CREATE 消息。该值通过在 IParam 参数中的 CREATESTRUCT 结构传递 2. 如果应用程序调用 CreateWindow 创建一个 MDI 客户窗口，则 lpParam 必须指向一个 CLIENTCREATESTRUCT 结构</td>
</tr>
</tbody></table>
<h3 id="dwStyle-窗口风格解析"><a href="#dwStyle-窗口风格解析" class="headerlink" title="dwStyle 窗口风格解析"></a><strong>dwStyle 窗口风格解析</strong></h3><table>
<thead>
<tr>
<th><strong>窗口风格</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>WS_BORDER</td>
<td>创建一个带边框的窗口</td>
</tr>
<tr>
<td>WS_CAPTION</td>
<td>创建一个有标题框的窗口（包含了 WS_BODER 风格）</td>
</tr>
<tr>
<td>WS_CHILD</td>
<td>创建一个子窗口，这个风格的窗口不能拥有菜单也不能与 WS_POPUP 风格合用</td>
</tr>
<tr>
<td>WS_CHILDWINDOW</td>
<td>与 WS_CHILD 相同</td>
</tr>
<tr>
<td>WS_CLIPCHILDREN</td>
<td>当在父窗口内绘图时，排除子窗口区域，在创建父窗口时使用这个风格</td>
</tr>
<tr>
<td>WS_CLIPSIBLINGS</td>
<td>1. 排除子窗口之间的相对区域，也就是，当一个特定的窗口接收到 WM_PAINT 消息时，WS_CLIPSIBLINGS 风格将所有层叠窗口排除在绘图之外，只重绘指定的子窗口 2. 如果未指定该风格，并且子窗口是层叠的，则在重绘子窗口的客户区时，就会重绘邻近的子窗口</td>
</tr>
<tr>
<td>WS_DISABLED</td>
<td>1. 创建一个初始状态为禁止的子窗口，一个禁止状态的窗口不能接受来自用户的输入信息 2. 在窗口创建之后，可以调用 EnableWindow 函数来启用该窗口</td>
</tr>
<tr>
<td>WS_DLGFRAME</td>
<td>创建一个带对话框边框风格的窗口，这种风格的窗口不能带标题条</td>
</tr>
<tr>
<td>WS_GROUP</td>
<td>1. 指定一组“控制窗口”的第一个“控制窗口” 2. 这个“控制窗口”组由第一个“控制窗口”和随后定义的“控制窗口”组成，自第二个“控制窗口”开始每个“控制窗口”具有 WS_GROUP 风格 3. 每个组的第一个“控制窗口”带有 WS_TABSTOP 风格，从而使用户可以在组间移动 4. 用户随后可以使用光标在组内的控制间改变键盘焦点</td>
</tr>
<tr>
<td>WS_HSCROLL</td>
<td>创建一个有水平滚动条的窗口</td>
</tr>
<tr>
<td>WS_ICONIC</td>
<td>创建一个初始状态为最小化状态的窗口，与 WS_MINIMIZE 风格相同</td>
</tr>
<tr>
<td>WS_MAXIMIZE</td>
<td>创建一个初始状态为最大化状态的窗口</td>
</tr>
<tr>
<td>WS_MAXIMIZEBOX</td>
<td>创建一个具有最大化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td>
</tr>
<tr>
<td>WS_MINIMIZE</td>
<td>创建一个初始状态为最小化状态的窗口，与 WS_ICONIC 风格相同</td>
</tr>
<tr>
<td>WS_MINIMIZEBOX</td>
<td>创建一个具有最小化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td>
</tr>
<tr>
<td>WS_OVERLAPPED</td>
<td>产生一个层叠的窗口，一个层叠的窗口有一个标题条和一个边框，与 WS_TILED 风格相同</td>
</tr>
<tr>
<td>WS_OVERLAPPEDWINDOW</td>
<td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_TILEDWINDOW 风格相同</td>
</tr>
<tr>
<td>WS_POPUP</td>
<td>创建一个弹出式窗口，该风格不能与 WS_CHILD 风格同时使用。</td>
</tr>
<tr>
<td>WS_POPUPWINDOW</td>
<td>相当于（WS_POPUP | WS_BORDER | WS_SYSMENU），但 WS_CAPTION 和 WS_POPUPWINDOW 必须同时设定才能使窗口某单可见</td>
</tr>
<tr>
<td>WS_SIZEBOX</td>
<td>创建一个可调边框的窗口，与 WS_THICKFRAME 风格相同</td>
</tr>
<tr>
<td>WS_SYSMENU</td>
<td>创建一个在标题条上带有窗口菜单的窗口，必须同时设定 WS_CAPTION 风格</td>
</tr>
<tr>
<td>WS_TABSTOP</td>
<td>1. 创建一个“控制窗口”，在用户按下 Tab 键时可以获得键盘焦点。 2. 按下 Tab 键后使键盘焦点转移到下一具有 WS_TABSTOP 风格的“控制窗口”</td>
</tr>
<tr>
<td>WS_THICKFRAME</td>
<td>创建一个具有可调边框的窗口，与 WS_SIZEBOX 风格相同</td>
</tr>
<tr>
<td>WS_TILED</td>
<td>产生一个层叠的窗口，一个层叠的窗口有一个标题和一个边框，与 WS_OVERLAPPED 风格相同</td>
</tr>
<tr>
<td>WS_TILEDWINDOW</td>
<td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_OVERLAPPEDWINDOW 风格相同</td>
</tr>
<tr>
<td>WS_VISIBLE</td>
<td>创建一个初始状态为可见的窗口</td>
</tr>
<tr>
<td>WS_VSCROLL</td>
<td>创建一个有垂直滚动条的窗口</td>
</tr>
</tbody></table>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数成功，返回值为新窗口的句柄；</p>
</li>
<li><p>如果函数失败，返回值为 NULL。</p>
</li>
</ol>
<h2 id="DefWindowProc"><a href="#DefWindowProc" class="headerlink" title="DefWindowProc"></a>DefWindowProc</h2><h3 id="函数功能：-2"><a href="#函数功能：-2" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>DefWindowProc 函数调用默认的窗口过程来处理我们不感兴趣的任何消息，该函数是为了确保每个消息都被处理。</p>
<p>DefWindowProc 函数传入和窗口过程同样的参数。</p>
<h3 id="API-函数原型：-2"><a href="#API-函数原型：-2" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">DefWindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  UINT Msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-2"><a href="#参数解析：-2" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>指定接收消息的窗口句柄</td>
</tr>
<tr>
<td>Msg</td>
<td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式 2. 应用程序消息只能使用低 16 位，高 16 位被系统保留 3. 传送门：<a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td>
</tr>
<tr>
<td>wParam</td>
<td>指定消息的附加消息，确切的含义取决于消息成员的值</td>
</tr>
<tr>
<td>lParam</td>
<td>指定消息的附加消息，确切的含义取决于消息成员的值</td>
</tr>
</tbody></table>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>返回值就是消息处理结果，它取决于发送的消息。</p>
<h2 id="DestroyWindow"><a href="#DestroyWindow" class="headerlink" title="DestroyWindow"></a>DestroyWindow</h2><h3 id="函数功能：-3"><a href="#函数功能：-3" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><ol>
<li><p>DestroyWindow 用于销毁一个指定的窗口，该函数通过发送 WM_DESTROY 消息和 WM_NCDESTROY 消息使窗口无效并移除其键盘焦点。</p>
</li>
<li><p>DestroyWindow 函数还销毁窗口的菜单，清空线程的消息队列，销毁与窗口过程相关的定时器，解除窗口对剪贴板的拥有权，打断剪贴板器的查看链。</p>
</li>
<li><p>如果指定的窗口拥有子窗口或拥有其它窗口，该函数将自动先销毁其子窗口或所拥有的窗口，然后再销毁自身。</p>
</li>
</ol>
<h3 id="API-函数原型：-3"><a href="#API-函数原型：-3" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DestroyWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-3"><a href="#参数解析：-3" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>指定将被销毁的窗口句柄</td>
</tr>
</tbody></table>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数成功执行，返回值为非 0；</p>
</li>
<li><p>如果函数执行失败，返回值为 0。</p>
</li>
</ol>
<h3 id="备注：-1"><a href="#备注：-1" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>一个线程不能使用本函数销毁别的线程创建的窗口。</p>
</li>
<li><p>如果这个窗口是一个不具有 WS_EX_NOPARENTNOTIFY 样式的子窗口，则销毁窗口时将发 WM_PARENTNOTIFY 消息给其父窗口。</p>
</li>
</ol>
<h2 id="DispatchMessage"><a href="#DispatchMessage" class="headerlink" title="DispatchMessage"></a>DispatchMessage</h2><h3 id="函数功能：-4"><a href="#函数功能：-4" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>DispatchMessage 函数分派一个消息给窗口过程（回调函数），通常该消息从 GetMessage 函数获得。Windows 的控制权在该函数交给了应用程序。</p>
<h3 id="API-函数原型：-4"><a href="#API-函数原型：-4" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> MSG *lpmsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-4"><a href="#参数解析：-4" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpmsg</td>
<td>指向含有消息的 MSG结构 的指针</td>
</tr>
</tbody></table>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>返回值是窗口过程返回的值；</p>
</li>
<li><p>尽管返回值的含义依赖于被分派的消息，但返回值通常被忽略。</p>
</li>
</ol>
<h3 id="备注：-2"><a href="#备注：-2" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>MSG 结构必须包含有效的消息值。</p>
</li>
<li><p>如果参数 lpmsg 指向一个 WM_TIMER 消息，并且 WM_TIMER 消息的参数 lParam 不为 NULL，则调用 lParam 指向的函数，而不是调用窗口程序。</p>
</li>
</ol>
<h2 id="DrawText"><a href="#DrawText" class="headerlink" title="DrawText"></a>DrawText</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>DrawText 函数在指定的矩形里写入格式化的正文，根据指定的方法对正文格式化（扩展的制表符，字符对齐、折行等）。</p>
<p>需要指定更多的格式选项，可以使用 DrawTextEx 函数。</p>
<h3 id="API-函数原型：-5"><a href="#API-函数原型：-5" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HDC hDC,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPCTSTR lpchText,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">int</span> nCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPRECT lpRect,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     UINT uFormat</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-5"><a href="#参数解析：-5" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hDC</td>
<td>指定“显示设备描述表”句柄</td>
</tr>
<tr>
<td>lpchText</td>
<td>1. 指向将被写入的字符串的指针，如果参数 nCount 是 -1，则字符串必须是以 \0 结束的 2. 如果 uFormat 包含 DT_MODIFYSTRING，则函数可为此字符串增加 4 个字符，存放字符串的缓冲区必须足够大，能容纳附加的字符</td>
</tr>
<tr>
<td>nCount</td>
<td>1. 指向字符串中的字符数 2. 如果 nCount 为 -1，则 lpchText 指向的字符串被认为是以 \0 结束的，DrawText 会自动计算字符数</td>
</tr>
<tr>
<td>lpRect</td>
<td>指向 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>的指针，其中包含文本将被置于其中的矩形的信息（按逻辑坐标）</td>
</tr>
<tr>
<td>uFormat</td>
<td>1. 指定格式化文本的方法 2. 此参数可以通过指定下列标志或标志的组合</td>
</tr>
</tbody></table>
<h3 id="uFormat-参数各种标志解析"><a href="#uFormat-参数各种标志解析" class="headerlink" title="uFormat 参数各种标志解析"></a><strong>uFormat 参数各种标志解析</strong></h3><table>
<thead>
<tr>
<th><strong>标志</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DT_BOTTOM</td>
<td>对齐文字到矩形的底部，当且仅当设置了 DT_SINGLELINE 标志才有效</td>
</tr>
<tr>
<td>DT_CALCRECT</td>
<td>1. 这个参数决定矩形的宽度和高度 2. 如果输出文本有多行，DrawText 函数使用 lpRect 定义的矩形的宽度，并扩展矩形的底部以容纳输出文本的最后一行 3. 如果输出文本只有一行，则 DrawText 函数改变矩形的右边界，以容纳下正文行的最后一个字符 4. 出现上述任何一种情况，DrawText 函数将返回格式化文本的高度，而不是绘制文本</td>
</tr>
<tr>
<td>DT_CENTER</td>
<td>文本水平居中显示</td>
</tr>
<tr>
<td>DT_EDITCONTROL</td>
<td>将拥有多行编辑控件的正文显示特性（尤其是平均字符宽度的计算方法，并且不会显示不可见的最后一行）</td>
</tr>
<tr>
<td>DT_END_ELLIPSIS</td>
<td>1. 对于显示的文本，如果结束的字符串的范围不在矩形内，它会被截断并以省略号标识 2. 如果一个字母不是在字符串的末尾但却超出了矩形范围，它会被换行但没有追加省略号标识 3. 除非指定了 DT_MODIFYSTRING 标志，否则字符串不会被修改</td>
</tr>
<tr>
<td>DT_EXPANDTABS</td>
<td>1. 扩展制表符，每个制表符的缺省字符数是 8 2. DT_WORD_ELLIPSIS, DT_PATH_ELLIPSIS 和 DT_END_ELLIPSIS 不能和此参数一起使用</td>
</tr>
<tr>
<td>DT_EXTERNALLEADING</td>
<td>在行的高度里包含字体的外部标头（通常外部标头不被包含在正文行的高度里）</td>
</tr>
<tr>
<td>DT_HIDEPREFIX</td>
<td>1. 忽略正文中的前缀字符（&amp;），并且前缀字符后面的字母不会出现下划线，其它前缀字符的调用方式不受影响 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_HIDEPREFIX 显示为“Fis&amp;hC”</td>
</tr>
<tr>
<td>DT_INTERNAL</td>
<td>用系统字体来计算正文尺寸</td>
</tr>
<tr>
<td>DT_LEFT</td>
<td>正文左对齐</td>
</tr>
<tr>
<td>DT_MODIFYSTRING</td>
<td>1. 允许系统修改给定的字符串来匹配显示的正文 2. 此标志必须和 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 同时使用</td>
</tr>
<tr>
<td>DT_NOCLIP</td>
<td>无裁剪绘制，使用 DT_NOCLIP 可以提高 DrawText 的效率</td>
</tr>
<tr>
<td>DT_NOFULLWIDTHCHARBREAK</td>
<td>1. 在宽字符的字符串中防止行断开，因此折行规则相当于单字符的字符串 2. 例如，我们可以用在韩国版的 Windows 中，为图标标签提供更好的可读性 3. 除非指定 DT_WORDBREAK，否则此值没有作用</td>
</tr>
<tr>
<td>DT_NOPREFIX</td>
<td>1. 关闭前缀字符的处理（通常 DrawText 解释 &amp; 为给其后的字符加下划线，解释 &amp;&amp; 为显示单个 &amp;） 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_NOPREFIX 显示为“F&amp;is&amp;&amp;hC”</td>
</tr>
<tr>
<td>DT_PATH_ELLIPSIS</td>
<td>1. 对于过长的正文，自动替换字符串中间的字符为省略号（…），以确保结果能在合适的矩形内显示 2. 如果该字符串包含反斜杠（\）字符，DT_PATH_ELLIPSIS 尽可能的保留最后一个反斜杠之后的字符 3. 除非指定了 DT_MODIFYSTRING 标志否则字符串不会被修改</td>
</tr>
<tr>
<td>DT_PREFIXONLY</td>
<td>1. 仅仅在（&amp;）前缀字符的位置下绘制一个下划线，但不绘制字符串中的任何其他字符 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_PREFIXONLY 显示为“_”</td>
</tr>
<tr>
<td>DT_RIGHT</td>
<td>正文右对齐</td>
</tr>
<tr>
<td>DT_RTLREADING</td>
<td>当设备环境的字体是希伯来文或阿拉伯文字体时，为双向正文安排从右到左的阅读顺序</td>
</tr>
<tr>
<td>DT_SINGLELINE</td>
<td>显示正文的同一行，回车和换行符都不能换行</td>
</tr>
<tr>
<td>DT_TABSTOP</td>
<td>1. 设置制表符，参数 uFormat 的 8~15 位（低位字中的高位字节）指定每个制表符的字符数，每个制表符的缺省字符数是 8 2. DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP 和 DT_NOPREFIX 不能和此参数一起使用</td>
</tr>
<tr>
<td>DT_TOP</td>
<td>正文顶端对齐</td>
</tr>
<tr>
<td>DT_VCENTER</td>
<td>使正文在矩形中垂直居中，当且仅当设置了 DT_SINGLELINE 标志才有效</td>
</tr>
<tr>
<td>DT_WORDBREAK</td>
<td>1. 当一行中的字符将会延伸到由 lpRect 指定的矩形的边框时，此行自动地在单词之间断开 2. 一个回车一换行也能使之换行 3. 如果没有指定，输出会在一行上</td>
</tr>
<tr>
<td>DT_WORD_ELLIPSIS</td>
<td>截短不符合矩形的正文，并增加省略号（与 DT_END_ELLIPSIS 类似）</td>
</tr>
</tbody></table>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回值是正文的高度（逻辑单位）；</p>
</li>
<li><p>如果指定了 DT_VCENTER 或 DT_BOTTOM，返回值是 lpRect -&gt; top 到绘制的正文的底部的偏移值；</p>
</li>
<li><p>如果 函数调用失败，返回值是 0。</p>
</li>
</ol>
<h3 id="备注：-3"><a href="#备注：-3" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>函数 DrawText 用设备环境中的字体选择、正文颜色和背景颜色来写正文。</p>
</li>
<li><p>DrawText 裁剪正文，使之不会出现在指定矩形的外面，除非指定了 DT_NOCLIP。</p>
</li>
<li><p>除非使用 DT_SINGLELINE 格式化，否则其余的格式都认为正文有多行。</p>
</li>
<li><p>如果选择的字体对指定的矩形而言太大，DrawText 并不会试图去换成一种小字体。</p>
</li>
<li><p>设备环境的正文对齐方式必须包括 TA_LEFT, TA_TOP 和 TA_NOUPDATECP 标志。</p>
</li>
</ol>
<h2 id="EndPaint"><a href="#EndPaint" class="headerlink" title="EndPaint"></a>EndPaint</h2><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>EndPaint 函数标记指定窗口的绘画过程结束。</p>
<p>这个函数在每次调用 BeginPaint 函数之后被调用（释放设备描述表），但仅仅在绘画完成以后。</p>
<h3 id="API-函数原型：-6"><a href="#API-函数原型：-6" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> PAINTSTRUCT *lpPaint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-6"><a href="#参数解析：-6" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>已经被重新绘制的窗口句柄</td>
</tr>
<tr>
<td>lpPaint</td>
<td>指向 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>的指针，用于存放绘画相关的信息（该指针在调用 BeginPaint 时被赋值）</td>
</tr>
</tbody></table>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>该函数返回值始终是非 0。</p>
<h2 id="GetClientRect"><a href="#GetClientRect" class="headerlink" title="GetClientRect"></a>GetClientRect</h2><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>GetClientRect 函数用于获取窗口客户区的坐标，客户区坐标指定客户区的左上角和右下角。</p>
<p>由于客户区坐标是相对窗口客户区的左上角而言的，因此左上角坐标为（0，0）</p>
<h3 id="API-函数原型：-7"><a href="#API-函数原型：-7" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetClientRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPRECT lpRect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-7"><a href="#参数解析：-7" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>需要获取客户区坐标的窗口句柄</td>
</tr>
<tr>
<td>lpRect</td>
<td>1. 指向 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>的指针，该结构有四个成员，分别为 left、top、right 和 bottom 2. GetClientRect 将这四个成员设定为窗口显示区域的尺寸，left 和 top 字段通常设定为 0，right 和 bottom 字段设定为显示区域的宽度和高度（像素点数）</td>
</tr>
</tbody></table>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数成功，返回值是非 0；</p>
</li>
<li><p>如果函数失败，返回值是 0。</p>
</li>
</ol>
<h2 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h2><h3 id="函数功能：-5"><a href="#函数功能：-5" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetMessage 函数的作用是从当前线程的消息队列里获取一个消息并填入 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47240-1-1.html">MSG 结构</a> 中。</p>
<p>该函数只能获取调用线程的消息，不能获得其他线程的消息。成功获取消息后，线程将从消息队列中删除该消息。</p>
<p>使用 GetMessage 函数，如果消息队列为空，函数会一直等待直到有消息到来才有返回值。如果希望函数立刻返回（无论是否获取消息），请使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-69031-1-1.html">PeekMessage</a> 函数。</p>
<h3 id="API-函数原型：-8"><a href="#API-函数原型：-8" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_     LPMSG lpMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT wMsgFilterMin,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT wMsgFilterMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-8"><a href="#参数解析：-8" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpMsg</td>
<td>指向 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47240-1-1.html">MSG 结构</a>的指针，用于存放获取到的消息</td>
</tr>
<tr>
<td>hWnd</td>
<td>1. 需要获取消息的窗口的句柄，该窗口必须属于当前线程 2. 当其值是 NULL 时，将获取所有的当前线程的窗口消息和线程消息 3. 当其值是 -1 时，只获取当前线程消息</td>
</tr>
<tr>
<td>wMsgFilterMin</td>
<td>指定被可以被获取的消息值的最小整数（消息其实就是一个被定义的整数）</td>
</tr>
<tr>
<td>wMsgFilterMax</td>
<td>指定被可以被获取的消息值的最小整数</td>
</tr>
</tbody></table>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数取得 WM_QUIT 之外的其他消息，返回值是非 0；</p>
</li>
<li><p>如果函数取得 WM_QUIT 消息，返回值是 0；</p>
</li>
<li><p>如果出现了错误，返回值是 -1。</p>
</li>
</ol>
<h3 id="备注：-4"><a href="#备注：-4" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>应用程序通常根据 GetMessage 函数的返回值决定是否结束消息循环并退出程序；</p>
</li>
<li><p>如果 hWnd 参数不为零，则 GetMessage 函数只获取属于 hWnd 窗口的消息，以及被 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-69035-1-1.html">IsChild</a> 函数确定为 hWnd 的子窗口的消息；</p>
</li>
<li><p>wMsgFilterMin 和 wMsgFilterMax 参数限定消息获取的范围，如果二者都为 0，则消息获取的范围为所有消息；</p>
</li>
<li><p>注意，即便你通过 wMsgFilterMin 和 wMsgFilterMax 参数限定消息获取的范围，但 WM_QUIT 不受此范围影响（无法阻止此消息被 PeekMessage 函数获取）；</p>
</li>
<li><p>调用此函数的过程中，如果接收到非排队消息 —— 也就是由该线程调用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-69038-1-1.html">SendMessage</a>, <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-69039-1-1.html">SendMessageCallback</a>, <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-69040-1-1.html">SendMessageTimeout</a>, 或 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-69041-1-1.html">SendNotifyMessage</a> 发送给所属窗口的消息 —— 系统先暂时挂起等待，然后再获取过滤器匹配的第一个队列消息。如果不指定过滤器，那么按照以下顺序获取消息：</p>
</li>
</ol>
<ul>
<li>Sent messages</li>
<li>Posted messages</li>
<li>Input (hardware) messages and system internal events</li>
<li>Sent messages (again)</li>
<li>WM_PAINT messages</li>
<li>WM_TIMER messages</li>
</ul>
<ol start="6">
<li>PeekMessage 函数通常不会从消息队列中删除 WM_PAINT 消息，WM_PAINT 会持续保留在消息队列中直到它们被处理，除非一个 WM_PAINT 消息指定的区域为 NULL。</li>
</ol>
<p><em>小甲鱼注释：大家应该还记得有三个消息 WM_QUIT, WM_PAINT, WM_TIMER 会被特殊处理，它们总是放在队列的最后面，直到没有其它消息的时候才被处理，连续的 WM_PAINT 消息将被合并成一个以提高绘图效率。</em></p>
<ol start="7">
<li>如果一个顶层窗口停止响应的消息超过几秒钟，系统认为窗口没有响应，并使用一个备用窗口替代，该窗口具有相同的 Z 序列、位置、尺寸和视觉属性。这使得用户可以移动、调整大小，甚至关闭该应用程序。然而，这些仅仅是动作，现有的程序事实上仍然没有响应（为了提高用户体验而制作的假象）。当一个程序被调试时，系统并不会为其生成备用窗口。</li>
</ol>
<h2 id="GetTextAlign"><a href="#GetTextAlign" class="headerlink" title="GetTextAlign"></a>GetTextAlign</h2><h3 id="函数功能：-6"><a href="#函数功能：-6" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetTextAlign 函数获得指定的设备环境下的文本对齐方式的设置。</p>
<h3 id="API-函数原型：-9"><a href="#API-函数原型：-9" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetTextAlign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-9"><a href="#参数解析：-9" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdc</td>
<td>指定设备环境句柄</td>
</tr>
</tbody></table>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用失败，返回值是 GDI_ERROR；</p>
</li>
<li><p>如果函数调用成功，返回值是文字对齐标志的状态。</p>
</li>
</ol>
<p>该返回值是下列值的组合：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TA_BASELINE</td>
<td>基准点在正文的基线上</td>
</tr>
<tr>
<td>TA_BOTTOM</td>
<td>基准点在限定矩形的底边上（限定矩形的含义请看下边备注）</td>
</tr>
<tr>
<td>TA_TOP</td>
<td>基准点在限定矩形的顶边上</td>
</tr>
<tr>
<td>TA_CENTER</td>
<td>基准点在限定矩形的中心水平对齐位置</td>
</tr>
<tr>
<td>TA_LEFT</td>
<td>基准点在限定矩形的左边上</td>
</tr>
<tr>
<td>TA_RIGHT</td>
<td>基准点在限定矩形的右边上</td>
</tr>
<tr>
<td>TA_RTLREADING</td>
<td>1. 适用于中东 Windows 版本：正文从右到左的阅读顺序排列，与缺省的从左到右正好相反 2. 只有当被选择的字体是 Hebrew 或 Arabic 时，此值才有用</td>
</tr>
<tr>
<td>TA_NOUPDATECP</td>
<td>每次输出调用后当前状态不改变</td>
</tr>
<tr>
<td>TA_UPDATECP</td>
<td>每次输出调用后当前状态改变</td>
</tr>
</tbody></table>
<p>若当前字体有一条缺省的垂直基线（如Kanji），下列值用于取代 TA_BASELINE 和 TA_CENTER：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>VTA_BASELINE</td>
<td>基准点在正文的基线上</td>
</tr>
<tr>
<td>VTA_CENTER</td>
<td>基准点与限定矩形的中心垂直对齐</td>
</tr>
</tbody></table>
<h3 id="备注：-5"><a href="#备注：-5" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>默认值是 TA_LEFT, TA_TOP 和 TA_NOUPDATECP</p>
</li>
<li><p>限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形</p>
</li>
<li><p>限定矩形的尺寸可通过调用 GetTextExtentPoint32 来获得</p>
</li>
<li><p>文字对齐标志决定 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49474-1-1.html">TextOut</a> 和 ExtTextOut 如何将正文字符串与基准点对齐</p>
</li>
<li><p>文字对齐标志不必是单个的标志位，可以等于0</p>
</li>
<li><p>标志必须按相关的组来检查，如下：</p>
</li>
</ol>
<ul>
<li>TA_LEFT, TA_RIGHT, and TA_CENTER</li>
<li>TA_BOTTOM, TA_TOP, and TA_BASELINE</li>
<li>TA_NOUPDATECP and TA_UPDATECP</li>
</ul>
<p>如果当前字体有缺省的垂直基线，相关的标志如下所示：</p>
<ul>
<li>TA_LEFT, TA_RIGHT, and VTA_BASELINE</li>
<li>TA_BOTTOM, TA_TOP, and VTA_CENTER</li>
<li>TA_NOUPDATECP and TA_UPDATECP</li>
</ul>
<ol start="7">
<li>要验证一个特定的标志在返回值中被设置，应用程序必须执行以下步骤：<br>（例子：<a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49943-1-1.html">如何设置文本对齐模式</a>）</li>
</ol>
<ul>
<li>对该标志及其相关标志实施位OR操作；</li>
<li>对结果和返回值实施位AND操作；</li>
<li>检查结果值和标志是否相等。</li>
</ul>
<h2 id="GetTextMetrics"><a href="#GetTextMetrics" class="headerlink" title="GetTextMetrics"></a>GetTextMetrics</h2><h3 id="函数功能：-7"><a href="#函数功能：-7" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetTextMetrics 函数将当前字体的信息填充到指定缓冲区（<a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-50017-1-1.html">TEXTMETRIC 结构</a>）</p>
<h3 id="API-函数原型：-10"><a href="#API-函数原型：-10" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetTextMetrics</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTEXTMETRIC lptm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-10"><a href="#参数解析：-10" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdc</td>
<td>设备环境句柄</td>
</tr>
<tr>
<td>lptm</td>
<td>指向 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-50017-1-1.html">TEXTMETRIC 结构</a>的指针，该结构用于获得字体信息</td>
</tr>
</tbody></table>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回值是非 0；</p>
</li>
<li><p>如果函数调用失败，返回值是 0。</p>
</li>
</ol>
<h3 id="备注：-6"><a href="#备注：-6" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>要确定一种字体是否为 TrueType 字体，可以通过调用 GetTextMetrics 函数，然后检查 TEXTMETRIC.tmPitchAndFamily 的值是否为 TMPF_TRUETYPE</p>
</li>
<li><p>注意，调用 GetDC 函数返回的是一个未初始化的 DC，它具有“系统”（一个位图字体）作为默认字体。因此你需要先选择一种字体到 DC</p>
</li>
</ol>
<h2 id="lstrcat"><a href="#lstrcat" class="headerlink" title="lstrcat"></a>lstrcat</h2><h3 id="函数功能：-8"><a href="#函数功能：-8" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrcat 函数的功能是将一个字符串拼接在另一个字符串后边。</p>
<p><strong>注意：实际编程中不要再使用该函数，请使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49707-1-1.html">StringCchCat</a> 代替。</strong></p>
<h3 id="API-函数原型：-11"><a href="#API-函数原型：-11" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">lstrcat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPTSTR lpString1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPTSTR lpString2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-11"><a href="#参数解析：-11" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpString1</td>
<td>一个以’\0’为结尾的字符串，该字符串空间必须大到足以容纳本身及另一个字符串</td>
</tr>
<tr>
<td>lpString2</td>
<td>一个以’\0’为结尾的字符串，该字符串将拼接到 lpString1 指向的字符串后边</td>
</tr>
</tbody></table>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回指向拼接好的字符串指针；</p>
</li>
<li><p>如果函数调用失败，返回值为 NULL，并且 lpString1 可能会变成非 ‘\0’ 结束的字符串。</p>
</li>
</ol>
<h3 id="安全建议："><a href="#安全建议：" class="headerlink" title="安全建议："></a><strong>安全建议：</strong></h3><ol>
<li><p>不正确的使用 lstrcat 函数，可能会损害应用程序的安全性</p>
</li>
<li><p>lstrcat 函数使用结构化异常处理（SEH）来捕捉访问冲突和其他错误。当该函数捕获 SEH 错误，如果没有以’\0’结尾的字符串，则返回 NULL，且不把错误通知调用者。因此，把空间不足作为错误的条件是不安全的</p>
</li>
<li><p>lpString1 必须足够大，以增加 lpString2 和结束’\0’，否则可能发生缓冲区溢出</p>
</li>
<li><p>在最坏的情况下，缓冲区溢出可能允许攻击者可执行代码注入到你的进程，尤其是当 lpString1 是一个基于堆栈的缓冲区</p>
</li>
</ol>
<h2 id="lstrcpy"><a href="#lstrcpy" class="headerlink" title="lstrcpy"></a>lstrcpy</h2><h3 id="函数功能：-9"><a href="#函数功能：-9" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrcpy 函数的功能是复制一个字符串到缓冲区。</p>
<p><strong>注意：实际编程中不要再使用该函数，请使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49713-1-1.html">StringCchCopy</a> 代替。</strong></p>
<h3 id="API-函数原型：-12"><a href="#API-函数原型：-12" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">lstrcpy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR lpString1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPTSTR lpString2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-12"><a href="#参数解析：-12" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpString1</td>
<td>1. 缓冲区，用于接收来自 lpString2 参数指向的字符串 2. 该缓冲区必须足够容纳字符串和’\0’</td>
</tr>
<tr>
<td>lpString2</td>
<td>待拷贝的字符串</td>
</tr>
</tbody></table>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回指向缓冲区的指针；</p>
</li>
<li><p>如果函数调用失败，返回值是 NULL，并且 lpString1 可能会变成非 ‘\0’ 结束的字符串。</p>
</li>
</ol>
<h3 id="安全建议：-1"><a href="#安全建议：-1" class="headerlink" title="安全建议："></a><strong>安全建议：</strong></h3><ol>
<li><p>不正确的使用 lstcpy 函数，可能会损害应用程序的安全性</p>
</li>
<li><p>lstrcpy 函数使用结构化异常处理（SEH）来捕捉访问冲突和其他错误。当该函数捕获 SEH 错误，如果没有以’\0’结尾的字符串，则返回 NULL，且不把错误通知调用者。因此，把空间不足作为错误的条件是不安全的</p>
</li>
<li><p>lpString1 必须足够大，以增加 lpString2 和结束’\0’，否则可能发生缓冲区溢出</p>
</li>
<li><p>在最坏的情况下，缓冲区溢出可能允许攻击者可执行代码注入到你的进程，尤其是当 lpString1 是一个基于堆栈的缓冲区</p>
</li>
</ol>
<h2 id="lstrlen"><a href="#lstrlen" class="headerlink" title="lstrlen"></a>lstrlen</h2><h3 id="函数功能：-10"><a href="#函数功能：-10" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrlen 函数用于计算指定字符串的长度（不包含’\0）</p>
<p><strong>注意：实际编程中不要再使用该函数，请使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49704-1-1.html">StringCchLength</a> 或 StringCbLength 代替。</strong></p>
<h3 id="API-函数原型：-13"><a href="#API-函数原型：-13" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">lstrlen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCTSTR lpString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-13"><a href="#参数解析：-13" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpString</td>
<td>指向以’\0’为终止符的字符串</td>
</tr>
</tbody></table>
<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>该函数返回指定字符串的字符数；</p>
</li>
<li><p>如果是空字符串，则返回 0。</p>
</li>
</ol>
<h2 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h2><h3 id="函数功能：-11"><a href="#函数功能：-11" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>MessageBox 函数用于显示一个模态对话框，其中包含一个系统图标、 一组按钮和一个简短的特定于应用程序消息，如状态或错误的信息。</p>
<p>消息框中返回一个整数值，该值指示用户单击了哪个按钮。</p>
<h3 id="API-函数原型：-14"><a href="#API-函数原型：-14" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-14"><a href="#参数解析：-14" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>1. 该消息框的父窗口句柄 2. 如果此参数为NULL，则该消息框没有拥有父窗口</td>
</tr>
<tr>
<td>lpText</td>
<td>消息框的内容</td>
</tr>
<tr>
<td>lpCaption</td>
<td>消息框的标题</td>
</tr>
<tr>
<td>uType</td>
<td>1. 指定一个决定对话框的内容和行为的位标志集 2. 此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td>
</tr>
</tbody></table>
<h3 id="uType参数定义解析"><a href="#uType参数定义解析" class="headerlink" title="uType参数定义解析"></a><strong>uType参数定义解析</strong></h3><table>
<thead>
<tr>
<th><strong>按钮</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MB_OK</td>
<td>默认值，有一个“确认”按钮在里面</td>
</tr>
<tr>
<td>MB_YESNO</td>
<td>有“是”和“否”两个按钮在里面</td>
</tr>
<tr>
<td>MB_ABORTRETRYIGNORE</td>
<td>有“中止”，“重试”和“跳过”三个按钮在里面</td>
</tr>
<tr>
<td>MB_YESNOCANCEL</td>
<td>有“是”，“否”和“取消”三个按钮在里面</td>
</tr>
<tr>
<td>MB_RETRYCANCEL</td>
<td>有“重试”和“取消”两个按钮在里面</td>
</tr>
<tr>
<td>MB_OKCANCEL</td>
<td>有“确定”和“取消”两个按钮在里面</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>图标</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MB_ICONEXCLAMATION</td>
<td>一个惊叹号出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/33_400_300.jpg" alt="IC534153.png"></td>
</tr>
<tr>
<td>MB_ICONWARNING</td>
<td>一个惊叹号出现在消息框（同上）</td>
</tr>
<tr>
<td>MB_ICONINFORMATION</td>
<td>一个圆圈中小写字母i组成的图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/30_400_300.jpg" alt="IC534154.png"></td>
</tr>
<tr>
<td>MB_ICONASTERISK</td>
<td>一个圆圈中小写字母i组成的图标出现在消息框（同上）</td>
</tr>
<tr>
<td>MB_ICONQUESTION</td>
<td>一个问题标记图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/32_400_300.jpg" alt="IC534152.png"></td>
</tr>
<tr>
<td>MB_ICONSTOP</td>
<td>一个停止消息图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/31_400_300.jpg" alt="IC534151.png"></td>
</tr>
<tr>
<td>MB_ICONERROR</td>
<td>一个停止消息图标出现在消息框（同上）</td>
</tr>
<tr>
<td>MB_ICONHAND</td>
<td>一个停止消息图标出现在消息框（同上）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>默认按钮</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MB_DEFBUTTON1</td>
<td>指定第一个按钮为默认按钮</td>
</tr>
<tr>
<td>MB_DEFBUTTON2</td>
<td>指定第二个按钮为默认按钮</td>
</tr>
<tr>
<td>MB_DEFBUTTON3</td>
<td>指定第三个按钮为默认按钮</td>
</tr>
<tr>
<td>MB_DEFBUTTON4</td>
<td>指定第四个按钮为默认按钮</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>消息框形态</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MB_APPLMODAL</td>
<td>1. 在 hWnd 参数标识的窗口中继续工作以前，用户一定响应消息框 2. 但是，用户可以移动到其他线程的窗口且在这些窗口中工作 3. 根据应用程序中窗口的层次机构，用户则以移动到线程内的其他窗口 4. 所有母消息框的子窗口自动地失效，但是弹出窗口不是这样 5. 如果既没有指定 MB_SYSTEMMODAL 也没有指定 MB_TASKMODAL，则 MB_APPLMODAL 为默认的</td>
</tr>
<tr>
<td>MB_SYSTEMMODAL</td>
<td>1. 除了消息框有 WB_EX_TOPMOST 类型，否则 MB_APPLMODAL 和 MB_SYSTEMMODAL 一样 2. 用系统模态消息框来改变各种各样的用户，主要的损坏错误需要立即注意（例如，内存溢出） 3. 如果不是那些与 hWnd 联系的窗口，此标志对用户对窗口的相互联系没有影响</td>
</tr>
<tr>
<td>MB_TASKMODAL</td>
<td>1. 如果参数 hWnd 为 NULL 的话，那么除了所有属于当前线程高层次的窗口失效外，MB_TASKMODAL 和 MB_APPLMODAL 一样 2. 当调用应用程序或库没有一个可以得到的窗口句柄时，可以使用此标志，但仍需要阻止输入到调用线程的其他窗口，而不是搁置其他线程</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>其他标志</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MB_DEFAULT_DESKTOP_ONLY</td>
<td>1. 接收输入的当前桌面一定是一个默认桌面，否则函数调用失败 2. 默认桌面是一个在用户已经记录且以后应用程序在此上面运行的桌面</td>
</tr>
<tr>
<td>MB_HELP</td>
<td>1. 把一个 Help 按钮增加到消息框 2. 选择 Help 按钮或按 F1 产生一个 Help 事件</td>
</tr>
<tr>
<td>MB_RIGHT</td>
<td>文本为右对齐</td>
</tr>
<tr>
<td>MB_RTLREADING</td>
<td>用在 Hebrew 和 Arabic 系统中从右到左的顺序显示消息和大写文本</td>
</tr>
<tr>
<td>MB_SETFOREGROUND</td>
<td>1. 消息框变为前景窗口 2. 在内部系统为消息个调用 SetForegroundWindow 函数</td>
</tr>
<tr>
<td>MB_TOPMOST</td>
<td>消息框用 WS_EX_TOPMOST 窗口类型来创建 MB_SERVICE_NOTIFICATION</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>1. 该消息框的父窗口句柄 2. 如果此参数为NULL，则该消息框没有拥有父窗口</td>
</tr>
<tr>
<td>lpText</td>
<td>消息框的内容</td>
</tr>
<tr>
<td>lpCaption</td>
<td>消息框的标题</td>
</tr>
<tr>
<td>uType</td>
<td>1. 指定一个决定对话框的内容和行为的位标志集 2. 此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td>
</tr>
</tbody></table>
<h3 id="返回值：-14"><a href="#返回值：-14" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><table>
<thead>
<tr>
<th><strong>返回值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>IDOK</td>
<td>用户按下了“确认”按钮</td>
</tr>
<tr>
<td>IDCANCEL</td>
<td>用户按下了“取消”按钮</td>
</tr>
<tr>
<td>IDABORT</td>
<td>用户按下了“中止”按钮</td>
</tr>
<tr>
<td>IDRETRY</td>
<td>用户按下了“重试”按钮</td>
</tr>
<tr>
<td>IDIGNORE</td>
<td>用户按下了“忽略”按钮</td>
</tr>
<tr>
<td>IDYES</td>
<td>用户按下了“是”按钮</td>
</tr>
<tr>
<td>IDNO</td>
<td>用户按下了“否”按钮</td>
</tr>
</tbody></table>
<h2 id="PostQuitMessage"><a href="#PostQuitMessage" class="headerlink" title="PostQuitMessage"></a>PostQuitMessage</h2><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>PostQuitMessage 函数向系统表明有个线程提出终止（退出）请求。</p>
<p>这个函数通常用来响应 WM_DESTROY 消息。</p>
<h3 id="API-函数原型：-15"><a href="#API-函数原型：-15" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">PostQuitMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-15"><a href="#参数解析：-15" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>nExitCode</td>
<td>指定应用程序的退出代码，此值被用作 WM_QUIT 消息的 wParam 参数</td>
</tr>
</tbody></table>
<h3 id="返回值：-15"><a href="#返回值：-15" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>该函数没有返回值。</p>
<h3 id="备注：-7"><a href="#备注：-7" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>PostQuitMessage 函数的功能是发送一个 WM_QUIT 消息给线程的消息队列并立即返回。</p>
</li>
<li><p>当线程从消息队列里取得 WM_QUIT 消息时，应当退出消息循环并将返回系统，返回给系统的退出值必须是消息 WM_QUIT 的 wParam 参数（所以 WinMain 函数的返回值是 msg.wParam）。</p>
</li>
</ol>
<h2 id="SetScrollRange"><a href="#SetScrollRange" class="headerlink" title="SetScrollRange"></a>SetScrollRange</h2><h3 id="函数功能：-12"><a href="#函数功能：-12" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>SetScrollRange 函数设置所指定滚动条范围的最小值和最大值。</p>
<p>注意：SetScrollRange 函数提供了向后的兼容性。但新的应用程序应该提倡使用 SetScrollInfo 函数代替。</p>
<h3 id="API-函数原型：-16"><a href="#API-函数原型：-16" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetScrollRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nBar,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nMinPos,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nMaxPos,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  BOOL bRedraw</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-16"><a href="#参数解析：-16" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>1. 滚动条控件的句柄或带有标准滚动条窗体的句柄 2. 由 nBar 参数的值确定</td>
</tr>
<tr>
<td>nBar</td>
<td>指定将要设置哪类滚动条的参数： 1. SB_CTL：设置滚动条控件的范围，要求参数 hwnd 必须是滚动条控件的句柄 2. SB_HORZ：设置窗体的标准水平滚动条的范围 3. SB_VERT：设置窗体的标准垂直滚动条的范围</td>
</tr>
<tr>
<td>nMinPos</td>
<td>指定滚动位置的最小值</td>
</tr>
<tr>
<td>nMaxPos</td>
<td>指定滚动位置的最大值</td>
</tr>
<tr>
<td>bRedraw</td>
<td>指定滚动条是否被重画以反映变化（如果这个参数为 TRUE，滚动条将被重画；如果为 FALSE 则不被重画）</td>
</tr>
</tbody></table>
<h3 id="返回值：-16"><a href="#返回值：-16" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回值为非 0；</p>
</li>
<li><p>如果函数调用失败，返回值为 0。</p>
</li>
</ol>
<h3 id="备注：-8"><a href="#备注：-8" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>将 SetScrollRange 函数中的 nMinPos 和 nMaxPos 参数设置为一样的值，可以达到隐藏滚动条的目的。但在处理滚动条消息时，应用程序不应该调用 SetScrollRange 函数来隐藏滚动条。新的应用程序应该调用 ShowScrollBar 函数来隐藏滚动条。</p>
</li>
<li><p>如果调用 SetScrollPos 函数之后马上调用 SetScrollRange 函数，则 SetScrollPos 函数中的 bRedraw 参数一定要设置为零值（FALSE），以防止滚动条被画两次。</p>
</li>
<li><p>标准滚动条的缺省范围是 0 到 100。滚动条控件的缺省值为 NULL（参数 nMinPos 和 nMaxPos 的值均为零）。两个范围值之间的不同之处在于由参数 nMinPos 和 nMaxPos 指定，不过不能超过 MAXLONG 定义的大小。</p>
</li>
<li><p>因为说明滚动条位置的消息 WM_HSCROLL 和 WM_VSCROLL 是 16 位数据，所以那些只依赖于说明位置数据消息的应用程序在 SetScrollRange 函数的参数 nMaxPos 中有一个实际最大值 65,535。但是，因为 SetScrolllnfo，SetScrollPos， SetScrollRange，GetScrolllnfo，GetScrollPos 和 GetScrollRange 函数都支持 32 位的滚动条位置数据，所以有一个解决 16 位 WM_HSCROLL 和 WM_VSCROLL 消息阻碍的途径，请参见函数 GetScrolllnfo 的有关技术说明。</p>
</li>
<li><p>如果参数 nBar 设置为 SB_CTL 并且参数 hWnd 所标识的不是一个标准的滚动条控件。系统将发送一个 SBM_SETRANGE 消息到窗体用以设置滚动条消息。这将允许 SetScrollRange 函数操作一个定制的伪滚动条控件。如果窗体没有处理 SBM_SETRANGE 消息，SetScrollRange 函数将调用失败。</p>
</li>
</ol>
<h2 id="SetTextAlign"><a href="#SetTextAlign" class="headerlink" title="SetTextAlign"></a>SetTextAlign</h2><h3 id="函数功能：-13"><a href="#函数功能：-13" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>SetTextAlign 函数为指定设备环境设置文本的对齐标志。</p>
<h3 id="API-函数原型：-17"><a href="#API-函数原型：-17" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SetTextAlign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  UINT fMode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-17"><a href="#参数解析：-17" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdc</td>
<td>指定设备环境句柄</td>
</tr>
<tr>
<td>fMode</td>
<td>1. 文本对齐标志 2. 在横向对齐和纵向对齐标志中只能选择一个 3. 两个标志只能选择一个来改变当前的位置</td>
</tr>
</tbody></table>
<p>使用下面的列表中的掩码指定文本对齐方式：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TA_BASELINE</td>
<td>基准点在正文的基线上</td>
</tr>
<tr>
<td>TA_BOTTOM</td>
<td>基准点在限定矩形的底边上（限定矩形的含义请看下边备注）</td>
</tr>
<tr>
<td>TA_TOP</td>
<td>基准点在限定矩形的顶边上</td>
</tr>
<tr>
<td>TA_CENTER</td>
<td>基准点在限定矩形的中心水平对齐位置</td>
</tr>
<tr>
<td>TA_LEFT</td>
<td>基准点在限定矩形的左边上</td>
</tr>
<tr>
<td>TA_RIGHT</td>
<td>基准点在限定矩形的右边上</td>
</tr>
<tr>
<td>TA_NOUPDATECP</td>
<td>1. 适用于中东 Windows 版本：正文从右到左的阅读顺序排列，与缺省的从左到右正好相反 2. 只有当被选择的字体是 Hebrew 或 Arabic 时，此值才有用</td>
</tr>
<tr>
<td>TA_RTLREADING</td>
<td>每次输出调用后当前状态不改变</td>
</tr>
<tr>
<td>TA_UPDATECP</td>
<td>每次输出调用后当前状态改变</td>
</tr>
</tbody></table>
<p>若当前字体有一条缺省的垂直基线（如Kanji），下列值用于取代 TA_BASELINE 和 TA_CENTER：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>VTA_BASELINE</td>
<td>基准点在正文的基线上</td>
</tr>
<tr>
<td>VTA_CENTER</td>
<td>基准点与限定矩形的中心垂直对齐</td>
</tr>
</tbody></table>
<p>默认值是 TA_LEFT, TA_TOP 和 TA_NOUPDATECP。</p>
<h3 id="返回值：-17"><a href="#返回值：-17" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用失败，返回值是 GDI_ERROR；</p>
</li>
<li><p>如果函数调用成功，返回值是文字对齐方式的前一个设置。</p>
</li>
</ol>
<h3 id="备注：-9"><a href="#备注：-9" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49474-1-1.html">TextOut</a> 和 ExtTextOut 函数用文字对齐标志来将一个正文字符串定位于显示器或者其他设备</p>
</li>
<li><p>该标志指定了基准点与限定正文的矩形的位置关系，基准点可以是当前位置，也可是传给正文输出函数的一个点</p>
</li>
<li><p>设置左对齐文本的做好方法可以是如下：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign (hdc, GetTextAlign(hdc) &amp; (~TA_CENTER))</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign (hdc,TA_LEFT | &lt;other flags&gt;)</span><br></pre></td></tr></table></figure>

<p>你当然可以使用 SetTextAlign (hdc, TA_LEFT) 来达到这个目的，但是这个方法会丢失所有的垂直基线或者从右到左的设置。</p>
<ol start="5">
<li>调用 SetTextAlign 函数时，如果使用 TA_UPDATECP 标志，Windows 会忽略 TextOut 的 xStart 和 yStart 参数，而使用由 MoveToEx、LineTo 或更改目前位置的另一个函数设定的位置。</li>
</ol>
<h2 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h2><h3 id="函数功能：-14"><a href="#函数功能：-14" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>ShowWindow 函数用于设置窗口的显示状态。</p>
<p>应用程序第一次调用 ShowWindow 时，应该使用 WinMain 函数的 nCmdshow 参数作为它的 nCmdShow 参数。在随后调用 ShowWindow 函数时，必须使用下列显示方式中的一个给定值，而不是由 WinMain 函数的 nCmdSHow 参数指定的值。</p>
<h3 id="API-函数原型：-18"><a href="#API-函数原型：-18" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ShowWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nCmdShow</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-18"><a href="#参数解析：-18" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>窗口句柄</td>
</tr>
<tr>
<td>nCmdShow</td>
<td>控制窗口如何显示，如果发送应用程序的程序提供了 STARTUPINFO 结构，则应用程序第一次调用 ShowWindow 时该参数被忽略。否则，在第一次调用 ShowWindow 函数时，该值应为在函数 WinMain 中 nCmdShow 参数。</td>
</tr>
</tbody></table>
<p><strong>在随后的调用中，nCmdShow 参数可以为下列值之一：</strong></p>
<table>
<thead>
<tr>
<th><strong>显示方式</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SW_FORCEMINIMIZE</td>
<td>1. 最小化窗口，即使拥有窗口的线程被挂起也会最小化 2. 在从其他线程最小化窗口时才使用这个参数</td>
</tr>
<tr>
<td>SW_HIDE</td>
<td>隐藏窗口并激活其他窗口</td>
</tr>
<tr>
<td>SW_MAXIMIZE</td>
<td>最大化指定的窗口</td>
</tr>
<tr>
<td>SW_MINIMIZE</td>
<td>最小化指定的窗口并且激活在 Z 序中的下一个顶层窗口</td>
</tr>
<tr>
<td>SW_RESTORE</td>
<td>1. 激活并显示窗口 2. 如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置 3. 在恢复最小化窗口时，应用程序应该指定这个标志。</td>
</tr>
<tr>
<td>SW_SHOW</td>
<td>在窗口原来的位置以原来的尺寸激活并显示窗口</td>
</tr>
<tr>
<td>SW_SHOWDEFAULT</td>
<td>依据在 STARTUPINFO 结构中指定的 SW_FLAG 标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给 CreateProcess 函数的。</td>
</tr>
<tr>
<td>SW_SHOWMAXIMIZED</td>
<td>激活窗口并将其最大化</td>
</tr>
<tr>
<td>SW_SHOWMINIMIZED</td>
<td>激活窗口并将其最小化</td>
</tr>
<tr>
<td>SW_SHOWMINNOACTIVE</td>
<td>1. 窗口最小化 2. 在窗口激活的情况下，这个值跟 SW_SHOWMINIMIZED 很相似</td>
</tr>
<tr>
<td>SW_SHOWNA</td>
<td>1. 以窗口原来的位置以原来的尺寸显示窗口 2. 在窗口激活的情况下，这个值跟 SW_SHOW 很相似</td>
</tr>
<tr>
<td>SW_SHOWNOACTIVATE</td>
<td>1. 以窗口最近一次的位置和尺寸显示窗口 2. 在窗口激活的情况下，这个值跟 SW_SHOWNORMAL 很相似</td>
</tr>
<tr>
<td>SW_SHOWNORMAL</td>
<td>1. 激活并显示一个窗口 2. 如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小 3. 应用程序在第一次显示窗口的时候应该指定此标志</td>
</tr>
</tbody></table>
<h3 id="返回值：-18"><a href="#返回值：-18" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果窗口之前可见，则返回值为非 0；</p>
</li>
<li><p>如果窗口之前被隐藏，则返回值为 0。</p>
</li>
</ol>
<h2 id="StringCchCat"><a href="#StringCchCat" class="headerlink" title="StringCchCat"></a>StringCchCat</h2><h3 id="函数功能：-15"><a href="#函数功能：-15" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchCat 函数的功能是将一个字符串拼接到另一个字符串。StringCchCat 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p>
<p>微软推荐使用该函数替代以下函数：</p>
<ul>
<li>strcat, wcscat, _tcsat</li>
<li>lstrcat</li>
<li>StrCat</li>
<li>StrCatBuff</li>
</ul>
<h3 id="API-函数原型：-19"><a href="#API-函数原型：-19" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPCTSTR pszSrc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-19"><a href="#参数解析：-19" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pszDest</td>
<td>1. 目标缓冲区，同时包含第一个字符串 2. 该缓冲区必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+’\0’）</td>
</tr>
<tr>
<td>cchDest</td>
<td>1. 目标缓冲区的大小（字符个数） 2. 该值必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+’\0’） 3. 这个数不能超过 STRSAFE_MAX_CCH</td>
</tr>
<tr>
<td>pszSrc</td>
<td>第二个字符串</td>
</tr>
</tbody></table>
<h3 id="返回值：-19"><a href="#返回值：-19" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是拼接好的字符串指针。我们强烈建议您使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49703-1-2.html">SUCCEEDED</a> 和 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49703-1-2.html">FAILED</a> 宏来测试这个函数的返回值。</p>
<p>返回值可以是以下任意一个值：</p>
<table>
<thead>
<tr>
<th><strong>返回代码</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>S_OK</td>
<td>字符串正常拼接</td>
</tr>
<tr>
<td>STRSAFE_E_INVALID_PARAMETER</td>
<td>1. cchDest 参数的值为 0 2. cchDest 参数的值大于 STRSAFE_MAX_CCH 3. 目标缓冲区空间已满</td>
</tr>
<tr>
<td>STRSAFE_E_INSUFFICIENT_BUFFER</td>
<td>1. 因缓冲区空间不足导致失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td>
</tr>
</tbody></table>
<h3 id="备注：-10"><a href="#备注：-10" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>使用 StringCchCat 函数需要添加头文件：strsafe.h</p>
<h2 id="StringCchCopy"><a href="#StringCchCopy" class="headerlink" title="StringCchCopy"></a>StringCchCopy</h2><h3 id="函数功能：-16"><a href="#函数功能：-16" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchCopy 函数的功能是复制一个字符串到缓冲区。StringCchCopy 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p>
<p>微软推荐使用该函数替代以下函数：</p>
<ul>
<li>strcpy, wcscpy, _tcscpy</li>
<li>lstrcpy</li>
<li>StrCpy</li>
</ul>
<h3 id="API-函数原型：-20"><a href="#API-函数原型：-20" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCopy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR pszSrc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-20"><a href="#参数解析：-20" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pszDest</td>
<td>缓冲区，用于接收拷贝过来的字符串</td>
</tr>
<tr>
<td>cchDest</td>
<td>1. 目标缓冲区的大小（字符个数） 2. 该值必须大于或等于 pszSrc + 1（待拷贝字符串的字符+’\0’） 3. 这个数不能超过 STRSAFE_MAX_CCH</td>
</tr>
<tr>
<td>pszSrc</td>
<td>待拷贝的字符串</td>
</tr>
</tbody></table>
<h3 id="返回值：-20"><a href="#返回值：-20" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是指向缓冲区的指针。我们强烈建议您使用 SUCCEEDED 和 FAILED 宏来测试这个函数的返回值。</p>
<p>返回值可以是以下任意一个值：</p>
<table>
<thead>
<tr>
<th><strong>返回代码</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>S_OK</td>
<td>字符串正常拷贝</td>
</tr>
<tr>
<td>STRSAFE_E_INVALID_PARAMETER</td>
<td>1. cchDest 参数的值为 0 2. cchDest 参数的值大于 STRSAFE_MAX_CCH</td>
</tr>
<tr>
<td>STRSAFE_E_INSUFFICIENT_BUFFER</td>
<td>1. 因缓冲区空间不足导致失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td>
</tr>
</tbody></table>
<h2 id="StringCchLength"><a href="#StringCchLength" class="headerlink" title="StringCchLength"></a>StringCchLength</h2><h3 id="函数功能：-17"><a href="#函数功能：-17" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchLength 函数用于确定字符串是否超过了规定的长度，以字符为计算单位。</p>
<p>微软推荐使用该函数替代以下函数：</p>
<ul>
<li>strlen, wcslen, _tcslen</li>
</ul>
<h3 id="API-函数原型：-21"><a href="#API-函数原型：-21" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchLength</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR psz,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchMax,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  <span class="keyword">size_t</span> *pcch</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-21"><a href="#参数解析：-21" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>psz</td>
<td>指向待检查的字符串</td>
</tr>
<tr>
<td>cchMax</td>
<td>1. psz 参数里最大允许的字符数量，包括’\0’ 2. 这个数不能超过 STRSAFE_MAX_CCH</td>
</tr>
<tr>
<td>pcch</td>
<td>1. psz 参数指向字符串的字符个数，不包括’\0’ 2. 这个值只有在 psz 指针不为 NULL，且函数成功时有效</td>
</tr>
</tbody></table>
<h3 id="返回值：-21"><a href="#返回值：-21" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是指定字符串的字符个数。我们强烈建议您使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p>
<p>返回值可以是以下任意一个值：</p>
<table>
<thead>
<tr>
<th><strong>返回代码</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>S_OK</td>
<td>psz 指向的字符串不为空，且字符串的长度（包括’\0’）小于等于 cchMax</td>
</tr>
<tr>
<td>STRSAFE_E_INVALID_PARAMETER</td>
<td>1. psz 指向空字符串 2. cchMax 的值大于STRSAFE_MAX_CCH 3. psz 指向的字符串的字符个数超过 cchMax</td>
</tr>
</tbody></table>
<h3 id="备注：-11"><a href="#备注：-11" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol>
<li><p>对比 StringCchLength 所替代的函数，StringCchLength 是可以使你的代码正确处理缓存区的一个附加功能。因为小的缓冲处理会牵连很多安全问题，例如缓存区溢出</p>
</li>
<li><p>使用 StringCchLength 函数需要添加头文件：strsafe.h</p>
</li>
</ol>
<h2 id="StringCchPrintf"><a href="#StringCchPrintf" class="headerlink" title="StringCchPrintf"></a>StringCchPrintf</h2><h3 id="函数功能：-18"><a href="#函数功能：-18" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchPrintf 函数用于把数据格式化写入到指定的缓冲区里，该函数要求提供目标缓冲区的大小，确保不会发生越界访问。</p>
<p>微软推荐使用该函数替代以下函数：</p>
<ul>
<li>sprintf, swprintf, _stprintf</li>
<li>wsprintf</li>
<li>wnsprintf</li>
<li>_snprintf, _snwprintf, _sntprintf</li>
</ul>
<h3 id="API-函数原型：-22"><a href="#API-函数原型：-22" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchPrintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR pszFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-22"><a href="#参数解析：-22" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pszDest</td>
<td>指定格式化数据将要写入的缓冲区</td>
</tr>
<tr>
<td>cchDest</td>
<td>1. 缓冲区大小 2. 应该设置足够大，以容纳字符串和结束标记（’\n’） 3. 最大允许的字符数是 STRSAFE_MAX_CCH</td>
</tr>
<tr>
<td>pszFormat</td>
<td>1. 格式化字符串 2. 与 pirntf 的格式化字符串一致</td>
</tr>
<tr>
<td>…</td>
<td>可变参数，参数的个数取决 pszFormat 参数</td>
</tr>
</tbody></table>
<h3 id="返回值：-22"><a href="#返回值：-22" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是像 sprintf 一样返回存储在其目标缓冲区的字节数。我们强烈建议您使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p>
<p>返回值可以是以下任意一个值：</p>
<table>
<thead>
<tr>
<th><strong>返回代码</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>S_OK</td>
<td>表示有足够的空间将拷贝到 pszDest，没有发生截断</td>
</tr>
<tr>
<td>STRSAFE_E_INVALID_PARAMETER</td>
<td>cchDest 的值为 0 或大于 STRSAFE_MAX_CCH</td>
</tr>
<tr>
<td>STRSAFE_E_INSUFFICIENT_BUFFER</td>
<td>1. 由于缓冲区空间不足而导致的复制失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td>
</tr>
</tbody></table>
<h3 id="备注：-12"><a href="#备注：-12" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>使用 StringCchPrintf 函数需要添加头文件：<strong>strsafe.h</strong></p>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a><strong>代码演示：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strsafe.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">TCHAR pszDest[<span class="number">30</span>]; </span><br><span class="line"><span class="keyword">size_t</span> cchDest = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">LPCTSTR pszFormat = TEXT(<span class="string">&quot;从你家到鱼C工作室需要 %f 公里！&quot;</span>);</span><br><span class="line"></span><br><span class="line">HRESULT hr = StringCchPrintf(pszDest, cchDest, pszFormat, <span class="number">123.45</span>);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>





<h2 id="TextOut"><a href="#TextOut" class="headerlink" title="TextOut"></a>TextOut</h2><h3 id="函数功能：-19"><a href="#函数功能：-19" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>TextOut 函数使用当前选择的字体、背景颜色和文本颜色，将一个字符串绘制于窗口的指定位置。</p>
<h3 id="API-函数原型：-23"><a href="#API-函数原型：-23" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nXStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nYStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCTSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> cchString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-23"><a href="#参数解析：-23" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdc</td>
<td>设备环境句柄</td>
</tr>
<tr>
<td>nXStart</td>
<td>指定用于字符串对齐的基准点的逻辑 x 坐标（有关基准点请看下边备注）</td>
</tr>
<tr>
<td>nYStart</td>
<td>指定用于字符串对齐的基准点的逻辑 y 坐标</td>
</tr>
<tr>
<td>lpString</td>
<td>1. 指向将被绘制字符串的指针 2. 该字符串不必以’\0’结束，因为 cchString 参数指定了该字符串的长度</td>
</tr>
<tr>
<td>cchString</td>
<td>lpString 字符串的长度（有多少个字符）</td>
</tr>
</tbody></table>
<h3 id="返回值：-23"><a href="#返回值：-23" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回值为非 0；</p>
</li>
<li><p>如果函数调用失败，返回值为 0。</p>
</li>
</ol>
<h3 id="备注：-13"><a href="#备注：-13" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>字符串对齐的基准点取决于当前的文本对齐模式。应用程序可以通过调用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49489-1-1.html">GetTextAlign</a> 获得当前的文本对齐模式，通过调用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49492-1-1.html">SetTextAlign</a> 修改该模式。</p>
<h2 id="TranslateMessage"><a href="#TranslateMessage" class="headerlink" title="TranslateMessage"></a>TranslateMessage</h2><h3 id="函数功能：-20"><a href="#函数功能：-20" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>TranslateMessage 函数将虚拟键消息转换为字符消息，字符消息被寄送到当前线程的消息队列里。</p>
<p>当下一次线程调用函数 GetMessage 或 PeekMessage 时被读出。</p>
<h3 id="API-函数原型：-24"><a href="#API-函数原型：-24" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">TranslateMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> MSG *lpMsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-24"><a href="#参数解析：-24" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpMsg</td>
<td>指向含有消息的 MSG 结构的指针</td>
</tr>
</tbody></table>
<h3 id="返回值：-24"><a href="#返回值：-24" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果消息被转换（字符消息被寄送到当前线程的消息队列里）则返回非零值；</p>
</li>
<li><p>如果消息是 WM_KEYDOWN，WM_KEYUP WM_SYSKEYDOWN 或 WM_SYSKEYUP，返回非零值，不考虑转换；</p>
</li>
<li><p>如果消息没被转换（字符消息没被寄送到调用线程的消息队列里）则返回值是零。</p>
</li>
</ol>
<h2 id="UpdateWindow"><a href="#UpdateWindow" class="headerlink" title="UpdateWindow"></a>UpdateWindow</h2><h3 id="函数功能：-21"><a href="#函数功能：-21" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>UpdateWindow 函数绕过应用程序的消息队列，直接发送 WM_PAINT 消息给指定窗口的窗口过程。</p>
<p>如果窗口更新的区域不为空，UpdateWindow 函数通过发送一个 WM_PAINT 消息来更新指定窗口的客户区。如果更新区域为空，则不发送消息。</p>
<h3 id="API-函数原型：-25"><a href="#API-函数原型：-25" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UpdateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-25"><a href="#参数解析：-25" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hWnd</td>
<td>指定要更新的窗口的句柄.</td>
</tr>
</tbody></table>
<h3 id="返回值：-25"><a href="#返回值：-25" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回值为非 0；</p>
</li>
<li><p>如果函数调用不成功，返回值为 0。</p>
</li>
</ol>
<h2 id="wsprintf"><a href="#wsprintf" class="headerlink" title="wsprintf"></a>wsprintf</h2><h3 id="函数功能：-22"><a href="#函数功能：-22" class="headerlink" title="函数功能："></a><strong>函数功能</strong>：</h3><ul>
<li>wsprintf 函数将格式化字符串写入到指定的缓冲区里</li>
<li>输出缓冲区里的的值取决于格式说明符（即”%”）</li>
<li>如果写入的是文字，此函数给写入的文字的末尾追加一个’\0’</li>
<li>函数的返回值是写入的长度，但不包括最后的’\0’</li>
</ul>
<p><strong>注意：实际编程中不要再使用该函数，请使用 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-49693-1-1.html">StringCchPrintf</a> 或 StringCbPrint 代替。</strong></p>
<h3 id="API-函数原型：-26"><a href="#API-函数原型：-26" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">wsprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR lpOut,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR lpFmt,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-26"><a href="#参数解析：-26" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lpOut</td>
<td>1. 指定格式化数据将要写入的缓冲区 2. 缓冲区限定最大为 1024 字节</td>
</tr>
<tr>
<td>lpFmt</td>
<td>1. 格式化字符串 2. 与 printf 的格式化字符串基本一致，但不支持浮点数</td>
</tr>
<tr>
<td>…</td>
<td>可变参数，参数的个数取决 lpFmt 参数</td>
</tr>
</tbody></table>
<h3 id="返回值：-26"><a href="#返回值：-26" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果函数调用成功，返回值与计划写入缓冲区的字符个数相等（不包含最后的’\0’）；</p>
</li>
<li><p>如果函数调用失败，返回值小于计划写入缓冲区的字符个数，可通过调用 GetLastError 获取详细的错误信息。</p>
</li>
</ol>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="MSG-结构"><a href="#MSG-结构" class="headerlink" title="MSG 结构"></a>MSG 结构</h2><h3 id="MSG-消息结构"><a href="#MSG-消息结构" class="headerlink" title="MSG 消息结构"></a><strong>MSG 消息结构</strong></h3><p>在 Windows 程序中，消息是由 MSG 结构体来表示的。</p>
<h3 id="结构原型："><a href="#结构原型：" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">  HWND   hwnd;</span><br><span class="line">  UINT   message;</span><br><span class="line">  WPARAM wParam;</span><br><span class="line">  LPARAM lParam;</span><br><span class="line">  DWORD  time;</span><br><span class="line">  POINT  pt;</span><br><span class="line">&#125; MSG, *PMSG, *LPMSG;</span><br></pre></td></tr></table></figure>



<h3 id="成员解析："><a href="#成员解析：" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hwnd</td>
<td>指定接收消息的窗口句柄 如果是线程消息，该值是 NULL</td>
</tr>
<tr>
<td>message</td>
<td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式 2. 应用程序消息只能使用低 16 位，高 16 位被系统保留 3. 传送门：<a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td>
</tr>
<tr>
<td>wParam</td>
<td>指定消息的附加消息，确切的含义取决于消息成员的值</td>
</tr>
<tr>
<td>lParam</td>
<td>指定消息的附加消息，确切的含义取决于消息成员的值</td>
</tr>
<tr>
<td>time</td>
<td>该消息被投放到消息队列的时间</td>
</tr>
<tr>
<td>pt</td>
<td>当消息被投放到消息队列的时，鼠标位于屏幕中的位置</td>
</tr>
</tbody></table>
<h2 id="PAINTSTRUCT-结构"><a href="#PAINTSTRUCT-结构" class="headerlink" title="PAINTSTRUCT 结构"></a>PAINTSTRUCT 结构</h2><p>PAINTSTRUCT 结构包含一些窗口过程用来对客户区进行绘制的信息。</p>
<h3 id="结构原型：-1"><a href="#结构原型：-1" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">  HDC  hdc;</span><br><span class="line">  BOOL fErase;</span><br><span class="line">  RECT rcPaint;</span><br><span class="line">  BOOL fRestore;</span><br><span class="line">  BOOL fIncUpdate;</span><br><span class="line">  BYTE rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT;</span><br></pre></td></tr></table></figure>



<h3 id="成员解析：-1"><a href="#成员解析：-1" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdc</td>
<td>用于绘制的设备环境句柄</td>
</tr>
<tr>
<td>fErase</td>
<td>1. 表示背景是否必须擦除，如果为非零值则擦除背景，否则不擦除背景 2. 如果创建窗口类的时候没有设置背景画刷，则负责擦除背景</td>
</tr>
<tr>
<td>rcPaint</td>
<td>一个 <a target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>，指定左上角和右下角的坐标确定一个要绘制的矩形范围</td>
</tr>
<tr>
<td>fRestore</td>
<td>系统保留</td>
</tr>
<tr>
<td>fIncUpdate</td>
<td>系统保留</td>
</tr>
<tr>
<td>rgbReserved</td>
<td>系统保留</td>
</tr>
</tbody></table>
<h2 id="RECT-结构"><a href="#RECT-结构" class="headerlink" title="RECT 结构"></a>RECT 结构</h2><p>RECT 结构定义了一个矩形的左上角和右下角的坐标。</p>
<h3 id="结构原型：-2"><a href="#结构原型：-2" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RECT</span> &#123;</span></span><br><span class="line">  LONG left;</span><br><span class="line">  LONG top;</span><br><span class="line">  LONG right;</span><br><span class="line">  LONG bottom;</span><br><span class="line">&#125; RECT, *PRECT;</span><br></pre></td></tr></table></figure>



<h3 id="成员解析：-2"><a href="#成员解析：-2" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>指定矩形左上角的 x 坐标</td>
</tr>
<tr>
<td>top</td>
<td>指定矩形左上角的 y 坐标</td>
</tr>
<tr>
<td>right</td>
<td>指定矩形右下角的 x 坐标</td>
</tr>
<tr>
<td>bottom</td>
<td>指定矩形右下角的 y 坐标</td>
</tr>
</tbody></table>
<h2 id="TEXTMETRIC-结构"><a href="#TEXTMETRIC-结构" class="headerlink" title="TEXTMETRIC 结构"></a>TEXTMETRIC 结构</h2><p>TEXTMETRIC 结构记录当前设备环境中有关字体的各种信息。</p>
<p>TEXTMETRIC 结构成员的值的单位取决于设备环境中当前选定的映射模式，默认的映射模式是 MM_TEXT，所以它们的值是以像素为单位的。</p>
<h3 id="结构原型：-3"><a href="#结构原型：-3" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRIC</span> &#123;</span></span><br><span class="line">  LONG  tmHeight;</span><br><span class="line">  LONG  tmAscent;</span><br><span class="line">  LONG  tmDescent;</span><br><span class="line">  LONG  tmInternalLeading;</span><br><span class="line">  LONG  tmExternalLeading;</span><br><span class="line">  LONG  tmAveCharWidth;</span><br><span class="line">  LONG  tmMaxCharWidth;</span><br><span class="line">  LONG  tmWeight;</span><br><span class="line">  LONG  tmOverhang;</span><br><span class="line">  LONG  tmDigitizedAspectX;</span><br><span class="line">  LONG  tmDigitizedAspectY;</span><br><span class="line">  TCHAR tmFirstChar;</span><br><span class="line">  TCHAR tmLastChar;</span><br><span class="line">  TCHAR tmDefaultChar;</span><br><span class="line">  TCHAR tmBreakChar;</span><br><span class="line">  BYTE  tmItalic;</span><br><span class="line">  BYTE  tmUnderlined;</span><br><span class="line">  BYTE  tmStruckOut;</span><br><span class="line">  BYTE  tmPitchAndFamily;</span><br><span class="line">  BYTE  tmCharSet;</span><br><span class="line">&#125; TEXTMETRIC, *PTEXTMETRIC;</span><br></pre></td></tr></table></figure>



<h3 id="成员解析：-3"><a href="#成员解析：-3" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>tmHeight</td>
<td>字符高度（tmAscent + tmDescent）</td>
</tr>
<tr>
<td>tmAscent</td>
<td>字符上部高度（基线以上）</td>
</tr>
<tr>
<td>tmDescent</td>
<td>字符下部高度（基线以下）</td>
</tr>
<tr>
<td>tmInternalLeading</td>
<td>内部间距（包含在 tmHeight 中），该间距通常被用于显示重音符号</td>
</tr>
<tr>
<td>tmExternalLeading</td>
<td>外部间距，这个值是字体设计者建议在两行文字间留出的空间大小</td>
</tr>
<tr>
<td>tmAveCharWidth</td>
<td>1. 字体中小写字符的平均宽度（一般定义为字母 x 的宽度） 2. 字体中大写字符的平均宽度一般是该值的 1.5 倍计算 3. 此值不包括字体所需要的加粗和倾斜字符</td>
</tr>
<tr>
<td>tmMaxCharWidth</td>
<td>字体中最宽字符的宽度</td>
</tr>
<tr>
<td>tmWeight</td>
<td>字体的粗细轻重程度</td>
</tr>
<tr>
<td>tmOverhang</td>
<td>加入某些拼接字体上的附加高度</td>
</tr>
<tr>
<td>tmDigitizedAspectX</td>
<td>字体设计所针对的设备水平方向</td>
</tr>
<tr>
<td>tmDigitizedAspectY</td>
<td>字体设计所针对的设备垂直方向</td>
</tr>
<tr>
<td>tmFirstChar</td>
<td>为字体定义的第一个字符</td>
</tr>
<tr>
<td>tmLastChar</td>
<td>为字体定义的最后一个字符</td>
</tr>
<tr>
<td>tmDefaultChar</td>
<td>字体中所没有字符的替代字符</td>
</tr>
<tr>
<td>tmBreakChar</td>
<td>定义文本对齐截断操作所显示的字符</td>
</tr>
<tr>
<td>tmItalic</td>
<td>如果该值非零，则为斜体字体</td>
</tr>
<tr>
<td>tmUnderlined</td>
<td>如果该值非零，则为带下横线字体</td>
</tr>
<tr>
<td>tmStruckOut</td>
<td>如果该值非零，则为带删除线字体（字符中间画一条线）</td>
</tr>
<tr>
<td>tmPitchAndFamily</td>
<td>1. 如果低位为 0，表示等宽字体，小写和大写字母平均宽度一样 2. 如果低位为 1，表示变宽字体，大写字母是小写平均宽度的 3/2 倍</td>
</tr>
<tr>
<td>tmCharSet</td>
<td>字体的字符集</td>
</tr>
</tbody></table>
<h2 id="WNDCLASS-结构"><a href="#WNDCLASS-结构" class="headerlink" title="WNDCLASS 结构"></a>WNDCLASS 结构</h2><p>​        Windows 的窗口总是基于窗口类来创建的，窗口类同时确定了处理窗口消息的窗口过程（回调函数）。</p>
<p>​        在创建应用程序窗口之前，必须调用 RegisterClass 函数来注册窗口类。该函数只需要一个参数，即指向 WNDCLASS 窗口类的指针。因为 WNDCLASS 类包含了窗口所拥有的基本属性。</p>
<h3 id="结构原型：-4"><a href="#结构原型：-4" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSW</span> &#123;</span></span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;</span><br><span class="line">    <span class="keyword">int</span>         cbClsExtra;</span><br><span class="line">    <span class="keyword">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;</span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;</span><br><span class="line">    LPCWSTR     lpszMenuName;</span><br><span class="line">    LPCWSTR     lpszClassName;</span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;</span><br></pre></td></tr></table></figure>



<h3 id="成员解析：-4"><a href="#成员解析：-4" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>style</td>
<td>指定窗口类型，各种“类风格”（详见下方↓）可以使用按位或操作符组合起来</td>
</tr>
<tr>
<td>lpfnWndProc</td>
<td>指定窗口过程（必须是回调函数）</td>
</tr>
<tr>
<td>cbClsExtra</td>
<td>预留的额外空间，一般为 0</td>
</tr>
<tr>
<td>cbWndExtra</td>
<td>预留的额外空间，一般为 0</td>
</tr>
<tr>
<td>hInstance</td>
<td>应用程序的实例句柄</td>
</tr>
<tr>
<td>hIcon</td>
<td>为所有基于该窗口类的窗口设定一个图标</td>
</tr>
<tr>
<td>hCursor</td>
<td>为所有基于该窗口类的窗口设定一个鼠标指针</td>
</tr>
<tr>
<td>hbrBackground</td>
<td>指定窗口背景色</td>
</tr>
<tr>
<td>lpszMenuName</td>
<td>指定窗口菜单</td>
</tr>
<tr>
<td>lpszClassName</td>
<td>指定窗口类名</td>
</tr>
</tbody></table>
<h3 id="style-类风格解析"><a href="#style-类风格解析" class="headerlink" title="style 类风格解析"></a><strong>style 类风格解析</strong></h3><table>
<thead>
<tr>
<th><strong>类风格</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CS_VREDRAW</td>
<td>移动或者调整窗口的高度（垂直方向）时，重绘整个窗口</td>
</tr>
<tr>
<td>CS_HREDRAW</td>
<td>移动或者调整窗口的宽度（水平方向）时，重绘整个窗口</td>
</tr>
<tr>
<td>CS_DBLCLKS</td>
<td>当用户光标在窗口内双击时，允许发送双击消息给窗口过程</td>
</tr>
<tr>
<td>CS_OWNDC</td>
<td>给予每个窗口实例分配一个唯一的 DC（注意，尽管这样是很方便，但它必须慎重使用，因为每个 DC 大约要占 800 个字节的内存）</td>
</tr>
<tr>
<td>CS_CLASSDC</td>
<td>该窗口类的所有窗口实例都共享一个窗口类 DC</td>
</tr>
<tr>
<td>CS_PARENTDC</td>
<td>1. 将子窗口的裁剪区域设置到父窗口的 DC 中去，这样子窗口便可以在父窗口上绘制自身。（注意，这是子窗口从系统缓存中获取 DC，而不是使用父窗口的 DC。） 2. 指定该风格可以提高系统性能</td>
</tr>
<tr>
<td>CS_NOCLOSE</td>
<td>禁止系统菜单的关闭选项</td>
</tr>
<tr>
<td>CS_SAVEBITS</td>
<td>1. 以位图形式保存被该窗口遮挡的屏幕部分，当给窗口移动以后，系统便可以用该保存的位图恢复屏幕移动的相应部分，从而系统不用向被该窗口遮挡的窗口发送 WM_PAINT 消息 2. 该特性对于菜单类型的窗口比较合适，因为它通常是简短的显示一下之后便消失 3. 设置该特性将增加显示该窗口的时间，因为它通常要先分配保存位图的内存</td>
</tr>
<tr>
<td>CS_BYTEALIGNCLIENT</td>
<td>在字节边界上（在 x 方向上）定位窗口的用户区域的位置</td>
</tr>
<tr>
<td>CS_BYTEALIGNWINDOW</td>
<td>在字节边界上（在 x 方向上）定位窗口的位置</td>
</tr>
<tr>
<td>CS_GLOBALCLASS</td>
<td>1. 当调用 CreateWindow 或 CreateWindowEx 函数来创建窗口时允许它的 hInstance 参数和注册窗口类时传递给 RegisterClass 的 hInstance 参数不同 2. 如果不指定该风格，则这两个 hInstance 必须相同</td>
</tr>
</tbody></table>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="GET-X-LPARAM-和-GET-Y-LPARAM-宏"><a href="#GET-X-LPARAM-和-GET-Y-LPARAM-宏" class="headerlink" title="GET_X_LPARAM 和 GET_Y_LPARAM 宏"></a>GET_X_LPARAM 和 GET_Y_LPARAM 宏</h2><p>原文链接（GET_X_LPARAM）-&gt; <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632654(v=vs.85).aspx">传送门</a></p>
<p>原文链接（GET_Y_LPARAM）-&gt; <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632655(v=vs.85).aspx">传送门</a></p>
<h3 id="宏功能："><a href="#宏功能：" class="headerlink" title="宏功能："></a><strong>宏功能：</strong></h3><p>通过 lParam 参数获得相关消息触发的坐标 (x , y)</p>
<h3 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a><strong>宏定义：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GET_X_LPARAM</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">……</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GET_Y_LPARAM</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-27"><a href="#参数解析：-27" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lParam</td>
<td>将要被转换的 lParam 参数</td>
</tr>
</tbody></table>
<h3 id="返回值：-27"><a href="#返回值：-27" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>GET_X_LPARAM(lParam) 返回坐标的 x 值；</p>
</li>
<li><p>GET_Y_LPARAM(lParam) 返回坐标的 y 值。</p>
</li>
</ol>
<h3 id="重要备注："><a href="#重要备注：" class="headerlink" title="重要备注："></a><strong>重要备注：</strong></h3><ol>
<li><p>使用该宏需要包含头文件：windowsx.h。</p>
</li>
<li><p>不要再使用 LOWORD 和 HIWORD 去获取鼠标的坐标了，因为在多显示器的情况下会得到错误的坐标。</p>
</li>
</ol>
<h2 id="SUCCEEDED-和-FAILED-宏"><a href="#SUCCEEDED-和-FAILED-宏" class="headerlink" title="SUCCEEDED 和 FAILED 宏"></a>SUCCEEDED 和 FAILED 宏</h2><p>原文链接（SUCCEEDED）-&gt; <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687197(v=vs.85).aspx">传送门</a></p>
<p>原文链接（FAILED）-&gt; <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms693474(v=vs.85).aspx">传送门</a></p>
<h3 id="宏功能：-1"><a href="#宏功能：-1" class="headerlink" title="宏功能："></a><strong>宏功能：</strong></h3><p>SUCCEEDED 宏表示测试成功，FAILED 宏表示测试失败。</p>
<h3 id="宏原型："><a href="#宏原型：" class="headerlink" title="宏原型："></a><strong>宏原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SUCCEEDED</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HRESULT hr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">……</span><br><span class="line"><span class="function">BOOL <span class="title">FAILED</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HRESULT hr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参数解析：-28"><a href="#参数解析：-28" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hr</td>
<td>1. 状态码 2. 该值可以是 HRESULT 或 SCODE 类型 3. 非负数表示成功 4. 负数表示失败</td>
</tr>
</tbody></table>
<h3 id="返回值：-28"><a href="#返回值：-28" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol>
<li><p>如果 hr 的值大于等于 0，则结果为 TRUE；</p>
</li>
<li><p>如果 hr 的值小于 0，则结果为 FALSE。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>WinAPI文档</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://yui1111.github.io/2021/10/26/WinAPI%E6%96%87%E6%A1%A3/">https://yui1111.github.io/2021/10/26/WinAPI%E6%96%87%E6%A1%A3/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>作者</h><div class="post-copyright-cc-info"><h>yui1111</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-10-26</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-10-28</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/WinAPI/">WinAPI</a></div><div class="post_share"><div class="social-share" data-image="/img/43.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/16/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"><img class="prev-cover" data-lazy-src="/img/51.jpg" onerror="onerror=null;src='/img/4041.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 多线程笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/14/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"><img class="next-cover" data-lazy-src="/img/44.jpg" onerror="onerror=null;src='/img/4041.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">博客美化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/16/C++多线程笔记/" title="C++ 多线程笔记"><img class="cover" data-lazy-src="/img/51.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-16</div><div class="title">C++ 多线程笔记</div></div></a></div><div><a href="/2021/11/17/C++多线程笔记2/" title="C++多线程笔记2"><img class="cover" data-lazy-src="/img/44.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-17</div><div class="title">C++多线程笔记2</div></div></a></div><div><a href="/2021/11/18/C++多线程笔记3/" title="C++ 多线程笔记3"><img class="cover" data-lazy-src="/img/52.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-18</div><div class="title">C++ 多线程笔记3</div></div></a></div><div><a href="/2021/11/19/C++多线程笔记4/" title="C++ 多线程笔记4"><img class="cover" data-lazy-src="/img/32.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-19</div><div class="title">C++ 多线程笔记4</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/12.jpg" onerror="this.onerror=null;this.src='/img/4041.jpg'" alt="avatar"/><div class="author-info__name">yui1111</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yui1111"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yui1111" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/88488687" target="_blank" title="Bilibili"><i class="fas fa-link"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BeginPaint"><span class="toc-number">1.1.</span> <span class="toc-text">BeginPaint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A"><span class="toc-number">1.1.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateWindow"><span class="toc-number">1.2.</span> <span class="toc-text">CreateWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dwStyle-%E7%AA%97%E5%8F%A3%E9%A3%8E%E6%A0%BC%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.4.</span> <span class="toc-text">dwStyle 窗口风格解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DefWindowProc"><span class="toc-number">1.3.</span> <span class="toc-text">DefWindowProc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-2"><span class="toc-number">1.3.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DestroyWindow"><span class="toc-number">1.4.</span> <span class="toc-text">DestroyWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-3"><span class="toc-number">1.4.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DispatchMessage"><span class="toc-number">1.5.</span> <span class="toc-text">DispatchMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-4"><span class="toc-number">1.5.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-4"><span class="toc-number">1.5.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-2"><span class="toc-number">1.5.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DrawText"><span class="toc-number">1.6.</span> <span class="toc-text">DrawText</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-5"><span class="toc-number">1.6.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uFormat-%E5%8F%82%E6%95%B0%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.4.</span> <span class="toc-text">uFormat 参数各种标志解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-5"><span class="toc-number">1.6.5.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-3"><span class="toc-number">1.6.6.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EndPaint"><span class="toc-number">1.7.</span> <span class="toc-text">EndPaint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-6"><span class="toc-number">1.7.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-6"><span class="toc-number">1.7.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-6"><span class="toc-number">1.7.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetClientRect"><span class="toc-number">1.8.</span> <span class="toc-text">GetClientRect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-2"><span class="toc-number">1.8.1.</span> <span class="toc-text">函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-7"><span class="toc-number">1.8.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-7"><span class="toc-number">1.8.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-7"><span class="toc-number">1.8.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetMessage"><span class="toc-number">1.9.</span> <span class="toc-text">GetMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-5"><span class="toc-number">1.9.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-8"><span class="toc-number">1.9.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-8"><span class="toc-number">1.9.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-8"><span class="toc-number">1.9.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-4"><span class="toc-number">1.9.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTextAlign"><span class="toc-number">1.10.</span> <span class="toc-text">GetTextAlign</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-6"><span class="toc-number">1.10.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-9"><span class="toc-number">1.10.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-9"><span class="toc-number">1.10.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-9"><span class="toc-number">1.10.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-5"><span class="toc-number">1.10.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTextMetrics"><span class="toc-number">1.11.</span> <span class="toc-text">GetTextMetrics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-7"><span class="toc-number">1.11.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-10"><span class="toc-number">1.11.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-10"><span class="toc-number">1.11.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-10"><span class="toc-number">1.11.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-6"><span class="toc-number">1.11.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lstrcat"><span class="toc-number">1.12.</span> <span class="toc-text">lstrcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-8"><span class="toc-number">1.12.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-11"><span class="toc-number">1.12.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-11"><span class="toc-number">1.12.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-11"><span class="toc-number">1.12.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.12.5.</span> <span class="toc-text">安全建议：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lstrcpy"><span class="toc-number">1.13.</span> <span class="toc-text">lstrcpy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-9"><span class="toc-number">1.13.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-12"><span class="toc-number">1.13.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-12"><span class="toc-number">1.13.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-12"><span class="toc-number">1.13.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%AE%EF%BC%9A-1"><span class="toc-number">1.13.5.</span> <span class="toc-text">安全建议：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lstrlen"><span class="toc-number">1.14.</span> <span class="toc-text">lstrlen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-10"><span class="toc-number">1.14.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-13"><span class="toc-number">1.14.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-13"><span class="toc-number">1.14.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-13"><span class="toc-number">1.14.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MessageBox"><span class="toc-number">1.15.</span> <span class="toc-text">MessageBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-11"><span class="toc-number">1.15.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-14"><span class="toc-number">1.15.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-14"><span class="toc-number">1.15.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uType%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90"><span class="toc-number">1.15.4.</span> <span class="toc-text">uType参数定义解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-14"><span class="toc-number">1.15.5.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostQuitMessage"><span class="toc-number">1.16.</span> <span class="toc-text">PostQuitMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-3"><span class="toc-number">1.16.1.</span> <span class="toc-text">函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-15"><span class="toc-number">1.16.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-15"><span class="toc-number">1.16.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-15"><span class="toc-number">1.16.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-7"><span class="toc-number">1.16.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SetScrollRange"><span class="toc-number">1.17.</span> <span class="toc-text">SetScrollRange</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-12"><span class="toc-number">1.17.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-16"><span class="toc-number">1.17.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-16"><span class="toc-number">1.17.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-16"><span class="toc-number">1.17.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-8"><span class="toc-number">1.17.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SetTextAlign"><span class="toc-number">1.18.</span> <span class="toc-text">SetTextAlign</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-13"><span class="toc-number">1.18.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-17"><span class="toc-number">1.18.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-17"><span class="toc-number">1.18.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-17"><span class="toc-number">1.18.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-9"><span class="toc-number">1.18.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShowWindow"><span class="toc-number">1.19.</span> <span class="toc-text">ShowWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-14"><span class="toc-number">1.19.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-18"><span class="toc-number">1.19.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-18"><span class="toc-number">1.19.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-18"><span class="toc-number">1.19.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringCchCat"><span class="toc-number">1.20.</span> <span class="toc-text">StringCchCat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-15"><span class="toc-number">1.20.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-19"><span class="toc-number">1.20.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-19"><span class="toc-number">1.20.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-19"><span class="toc-number">1.20.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-10"><span class="toc-number">1.20.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringCchCopy"><span class="toc-number">1.21.</span> <span class="toc-text">StringCchCopy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-16"><span class="toc-number">1.21.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-20"><span class="toc-number">1.21.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-20"><span class="toc-number">1.21.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-20"><span class="toc-number">1.21.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringCchLength"><span class="toc-number">1.22.</span> <span class="toc-text">StringCchLength</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-17"><span class="toc-number">1.22.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-21"><span class="toc-number">1.22.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-21"><span class="toc-number">1.22.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-21"><span class="toc-number">1.22.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-11"><span class="toc-number">1.22.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringCchPrintf"><span class="toc-number">1.23.</span> <span class="toc-text">StringCchPrintf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-18"><span class="toc-number">1.23.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-22"><span class="toc-number">1.23.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-22"><span class="toc-number">1.23.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-22"><span class="toc-number">1.23.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-12"><span class="toc-number">1.23.5.</span> <span class="toc-text">备注：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A"><span class="toc-number">1.23.6.</span> <span class="toc-text">代码演示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TextOut"><span class="toc-number">1.24.</span> <span class="toc-text">TextOut</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-19"><span class="toc-number">1.24.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-23"><span class="toc-number">1.24.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-23"><span class="toc-number">1.24.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-23"><span class="toc-number">1.24.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%EF%BC%9A-13"><span class="toc-number">1.24.5.</span> <span class="toc-text">备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TranslateMessage"><span class="toc-number">1.25.</span> <span class="toc-text">TranslateMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-20"><span class="toc-number">1.25.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-24"><span class="toc-number">1.25.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-24"><span class="toc-number">1.25.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-24"><span class="toc-number">1.25.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UpdateWindow"><span class="toc-number">1.26.</span> <span class="toc-text">UpdateWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-21"><span class="toc-number">1.26.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-25"><span class="toc-number">1.26.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-25"><span class="toc-number">1.26.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-25"><span class="toc-number">1.26.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wsprintf"><span class="toc-number">1.27.</span> <span class="toc-text">wsprintf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%EF%BC%9A-22"><span class="toc-number">1.27.1.</span> <span class="toc-text">函数功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A-26"><span class="toc-number">1.27.2.</span> <span class="toc-text">API 函数原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-26"><span class="toc-number">1.27.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-26"><span class="toc-number">1.27.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MSG-%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">MSG 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MSG-%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">MSG 消息结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">结构原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">2.1.3.</span> <span class="toc-text">成员解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAINTSTRUCT-%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">PAINTSTRUCT 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8E%9F%E5%9E%8B%EF%BC%9A-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">结构原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%A7%A3%E6%9E%90%EF%BC%9A-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">成员解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RECT-%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">RECT 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8E%9F%E5%9E%8B%EF%BC%9A-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">结构原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%A7%A3%E6%9E%90%EF%BC%9A-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">成员解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TEXTMETRIC-%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">TEXTMETRIC 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8E%9F%E5%9E%8B%EF%BC%9A-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">结构原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%A7%A3%E6%9E%90%EF%BC%9A-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">成员解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WNDCLASS-%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">WNDCLASS 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8E%9F%E5%9E%8B%EF%BC%9A-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">结构原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%A7%A3%E6%9E%90%EF%BC%9A-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">成员解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#style-%E7%B1%BB%E9%A3%8E%E6%A0%BC%E8%A7%A3%E6%9E%90"><span class="toc-number">2.5.3.</span> <span class="toc-text">style 类风格解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">3.</span> <span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-X-LPARAM-%E5%92%8C-GET-Y-LPARAM-%E5%AE%8F"><span class="toc-number">3.1.</span> <span class="toc-text">GET_X_LPARAM 和 GET_Y_LPARAM 宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">宏功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">宏定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-27"><span class="toc-number">3.1.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-27"><span class="toc-number">3.1.4.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%A4%87%E6%B3%A8%EF%BC%9A"><span class="toc-number">3.1.5.</span> <span class="toc-text">重要备注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SUCCEEDED-%E5%92%8C-FAILED-%E5%AE%8F"><span class="toc-number">3.2.</span> <span class="toc-text">SUCCEEDED 和 FAILED 宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%8A%9F%E8%83%BD%EF%BC%9A-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">宏功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">宏原型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A-28"><span class="toc-number">3.2.3.</span> <span class="toc-text">参数解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-28"><span class="toc-number">3.2.4.</span> <span class="toc-text">返回值：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="计算机网络学习笔记2"><img data-lazy-src="/img/31.png" onerror="this.onerror=null;this.src='/img/4041.jpg'" alt="计算机网络学习笔记2"/></a><div class="content"><a class="title" href="/2021/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="计算机网络学习笔记2">计算机网络学习笔记2</a><time datetime="2021-11-23T08:01:10.000Z" title="发表于 2021-11-23 16:01:10">2021-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="计算机网络学习笔记1"><img data-lazy-src="/img/45.png" onerror="this.onerror=null;this.src='/img/4041.jpg'" alt="计算机网络学习笔记1"/></a><div class="content"><a class="title" href="/2021/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="计算机网络学习笔记1">计算机网络学习笔记1</a><time datetime="2021-11-20T15:34:59.000Z" title="发表于 2021-11-20 23:34:59">2021-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/" title="C++ 多线程笔记4"><img data-lazy-src="/img/32.jpg" onerror="this.onerror=null;this.src='/img/4041.jpg'" alt="C++ 多线程笔记4"/></a><div class="content"><a class="title" href="/2021/11/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/" title="C++ 多线程笔记4">C++ 多线程笔记4</a><time datetime="2021-11-19T14:19:28.000Z" title="发表于 2021-11-19 22:19:28">2021-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/" title="C++ 多线程笔记3"><img data-lazy-src="/img/52.jpg" onerror="this.onerror=null;this.src='/img/4041.jpg'" alt="C++ 多线程笔记3"/></a><div class="content"><a class="title" href="/2021/11/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/" title="C++ 多线程笔记3">C++ 多线程笔记3</a><time datetime="2021-11-18T13:24:36.000Z" title="发表于 2021-11-18 21:24:36">2021-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/" title="C++多线程笔记2"><img data-lazy-src="/img/44.jpg" onerror="this.onerror=null;this.src='/img/4041.jpg'" alt="C++多线程笔记2"/></a><div class="content"><a class="title" href="/2021/11/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/" title="C++多线程笔记2">C++多线程笔记2</a><time datetime="2021-11-17T05:05:55.000Z" title="发表于 2021-11-17 13:05:55">2021-11-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/43.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 By yui1111</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to yui1111's blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/css/cute.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>