<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面试题</title>
      <link href="2021/12/09/Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/12/09/Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer<strong>类</strong></h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a><strong>示例一</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 二</span></span><br><span class="line">Integer m = <span class="number">1</span>;</span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">System.out.println(m == <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Integer m = 1</code>底层使用<code>Integer.ValueOf(1)</code>来实现</p><p>底层代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IntegerCache.low</code>和<code>IntegerCache.high</code>分别为-128 和 127.也就是说在 -127~128 这个范围内不会创建新的<code>Integer</code>对象所以 <code>m==n</code> 返回 <code>true</code>.</p><p><code>IntegerCache.cache[]</code>是一个静态数组在类加载的时候就创建好了。</p><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a><strong>示例二</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> i4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>只要有基本数据类型，判断的是<strong>值</strong>是否相同，所以都为<code>true</code></p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a><strong>三元运算符</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj1);<span class="comment">// 1.0</span></span><br></pre></td></tr></table></figure><p>三元运算符为一个整体，所以 Object 就变为范围大的那个值，所以输出1.0</p><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><h3 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h3><p>一共创建了几个对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;abc&quot;</span>;<span class="comment">// 一个</span></span><br></pre></td></tr></table></figure><p>jdk 底层会将 <code>&quot;hello&quot;</code> 和 <code>&quot;abc&quot;</code> 优化，所以 <code>String a = &quot;hello&quot; + &quot;abc&quot;;</code> 等价于 <code>String a = &quot;helloabc&quot;;</code>，而不是在常量池创建三个对象：<code>&quot;hello&quot;</code> ，<code>&quot;abc&quot;</code>，<code>&quot;helloabc&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="2021/12/07/Java/"/>
      <url>2021/12/07/Java/</url>
      
        <content type="html"><![CDATA[<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h2><p>创建一个对象时，在一个类的调用顺序时：</p><ol><li>调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们<strong>定义的顺序调用</strong>）</li><li>调用普通代码块和普通属性的初始化</li><li>调用构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">codeBlock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(); <span class="comment">/**/</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">class A &#123;</span></span><br><span class="line"><span class="comment">    private int n2 = getN2();</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;A 的普通代码块&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;A 静态代码块&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    private static int n1 = getN1();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static int getN1() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;getN1被调用...&quot;);</span></span><br><span class="line"><span class="comment">        return 100;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public int getN2() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;getN2被调用...&quot;);</span></span><br><span class="line"><span class="comment">        return 200;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public A() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;A() 被调用&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>A 静态代码块<br>getN1被调用…<br>getN2被调用…<br>A 的普通代码块<br>A() 被调用</p></blockquote><p>如果有继承关系，执行的顺序为：父类静态属性 –&gt; 子类静态属性 –&gt; 父类普通属性 –&gt; 子类普通属性 –&gt; 父类构造器 –&gt; 子类构造器</p><p><strong>静态代码块只能调用静态成员，普通代码块可以使用任意成员</strong></p><p><code>final</code> <code>static</code>一起使用不会进行类加载(代码块也不会调用)：<code>public final statuc int num = 1000;</code></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>接口就是给出一些没有实现的方法，封装到一起没到某个类要使用的时候，再根据具体情况把这些方法写出来。如果一个类实现(implements)接口，则需要将该接口的所有抽象方法都实现。</p><p>在 jdk8 后，可以有默认实现方法，需要使用<code>default</code>关键字修饰，也可以有静态方法</p><p>接口中的所有方法是 <code>public</code> 方法，接口中抽象方法，可以不用 <code>abstract</code>修饰</p><p>抽象类去实现接口时，可以不是实现接口的抽象方法</p><p>接口中的属性，只能是<code>final</code>而且是<code>public static final</code>修饰符。比如：<code>int a = 1</code>，实际上是<code>public static final int a = 1</code>。</p><p><strong>小结</strong></p><blockquote><p>当子类继承了父类，就自动拥有父类的功能，如果子类需要扩展功能可以通过实现接口的方式扩展，可以理解实现接口时对Java但继承机制的一种补充。</p><p>继承的价值主要在于：解决代码的<strong>复用性和可维护性</strong></p><p>接口的价值主要在于：设计，设计好各种规范(方法)，让其它类去实现这些方法，让其更加灵活</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h2><p>一个类的内部有完整的嵌套了另一个类结构，被嵌套的类就称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><strong>局部内部类</strong></h3><p>局部内部类是定义在外部类的局部位置，通常在方法中。局部内部类<strong>可以直接访问外部类的所有成员</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">//  私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">//  局部内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类不能添加访问修饰符，但是可以用<code>final</code>修饰，作用域：仅仅在定义它的方法或代码块中。</p><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，需要使用外部类名.this.成员去访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.m1();<span class="comment">//InnerClass n1 = 800</span></span><br><span class="line">        <span class="comment">//OuterClass n1 = 100</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">//  私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">//  局部内部类</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">800</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;InnerClass n1 = &quot;</span> + n1);</span><br><span class="line">                System.out.println(<span class="string">&quot;OuterClass n1 = &quot;</span> + Outer.<span class="keyword">this</span>.n1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h3><p>匿名内部类是定义在外部类的局部位置，它本质还是一个类，但该类没有名字，而且它同时还是一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  基于接口的匿名内部类</span></span><br><span class="line">        IA tiger = <span class="keyword">new</span> IA() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎呼唤...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;特有的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry();</span><br><span class="line">        System.out.println(tiger.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tiger</code>的编译类型为 <code>IA</code>运行类型就是匿名内部类。</p><p>原理：jdk 底层会分配类名<code>Outer04$1</code>，在创建内部类 <code>Outer04$1</code>后立刻就创建了<code>Outer04$1</code>实例，并把地址返回给 <code>tiger</code>。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h3><p>其他类中创建成员内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner01</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassExercise02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种</span></span><br><span class="line">        Outer01 outer01 = <span class="keyword">new</span> Outer01();</span><br><span class="line">        Outer01.Inner01 inner01 = outer01.<span class="function">new <span class="title">Inner01</span><span class="params">()</span></span>;</span><br><span class="line">        inner01.hi();</span><br><span class="line">        <span class="comment">// 第二种</span></span><br><span class="line">        Outer01.Inner01 inner011 = <span class="keyword">new</span> Outer01().<span class="function">new <span class="title">Inner01</span><span class="params">()</span></span>;</span><br><span class="line">        inner011.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p><strong>常用方法</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/08/tk917b6lF8vpx3Z.png" alt="image-20211208213101914"></p><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a><strong>异常类</strong></h2><h3 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a><strong>异常体系图</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/09/B27P9eELCKYozID.png" alt="image-20211209132502605"></p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能有异常，一旦有异常直接进入 catch 中 </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获到异常</span></span><br><span class="line">    <span class="comment">// 当异常发生时系统将异常封装成 Exception 对象 e，传递给 catch</span></span><br><span class="line">    <span class="comment">// 得到异常对象后，程序员自己处理</span></span><br><span class="line">    <span class="comment">// 注意：如果没有发生异常，catch 代码块将不会执行</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不管 try 代发快是否发生异常，始终要执行 finally，所以，通常将释放资源的代码 放在 finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a><strong>自定义异常类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><p><strong>继承图</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/09/RGmhQfwuzWpVx2L.png" alt="image-20211209213739028"></p><p><strong>String 类实现了接口 Serializable 【String 可以串行化(序列化)：可以在网络传输)</strong></p><p><strong>String 类实现了接口 Comparable 【String 对象可以比较大小】</strong></p><p><strong>String 是 final 类，不能被继承</strong></p><p>**String 有属性 <code>private final char value[];</code>用于存放字符串内容，不可修改(对象不能修改)**，<u><strong>即<code>value</code>不能指向新的地址，但是单个字符的内容是可以改变的</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">char</span>[] value = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">value[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// 可行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] s = &#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;q&#x27;</span>&#125;;</span><br><span class="line">value = s; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="两种创建String对象的区别"><a href="#两种创建String对象的区别" class="headerlink" title="两种创建String对象的区别"></a>两种创建String对象的区别</h3><p><strong>方式一</strong>：直接赋值 <code>String s = &quot;hso&quot;;</code></p><p><strong>方式二</strong>：调用构造器 <code>String s2 = new String(&quot;hso&quot;);</code></p><blockquote><p>方式一：<strong>先从常量池查看是否有<code>&quot;hso&quot;</code>数据空间</strong>，如果有，直接指向；如果没有则重新创建，然后指向。s <u><strong>最终指向的是常量池的空间地址</strong></u></p><p>方式二：<strong>先从堆中创建空间，里面维护了<code>value</code>属性，指向常量池的<code>&quot;hso&quot;</code>空间</strong>。如果常量池没有<code>&quot;hso&quot;</code>，则重新创建，如果有，直接通过<code>value</code>指向，**<u>最终指向的是堆中的空间地址</u>**</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/09/YWu561QA2tXrOfq.png" alt="image-20211209221436474"></p><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p><code>intern()</code> 方法最终返回的是常量池的地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hso&quot;</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;hso&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a == b.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(b == b.intern()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a><strong>例题一</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String c = a + b;</span><br><span class="line">String d = <span class="string">&quot;helloabc&quot;</span>;</span><br><span class="line">System.out.println(d == c.intern());<span class="comment">// true</span></span><br><span class="line">System.out.println(d == c);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/09/7xOv2MwbLF8tfzh.png" alt="image-20211209230314419"></p><p><strong>重要规则</strong>： <code>String c1 = &quot;ab&quot; + &quot;cd&quot;;</code>常量相加，看的是常量池。<code>String c1 = a + b;</code>变量相加，是在堆中。</p><p>底层为：<code>StringBuilder sb = new StringBuilder(); sb.append(a); sb.append(b);</code> <code>sb</code>实在堆中，并且 <code>append</code>是在原来字符串的基础上追加的。</p><h3 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a><strong>例题二</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test ex = <span class="keyword">new</span> Test();</span><br><span class="line">ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：hsp and aava</p><p>还没调用<code>change</code>函数时的内存分布图</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/11/aMJBcizSVrH6fdo.png" alt="image-20211211090511733"></p><p>调用<code>ex.change(ex.str, ex.ch)</code>后会在栈中开辟新的空间，形参<code>str</code>指向堆中的<code>value</code>，形参<code>ch</code>指向<strong>堆</strong>中<code>java</code>的那片空间,调用<code>change</code>函数后形参<code>str</code>就不指向<code>value</code>而<strong>直接指向常量池</strong>中的<code>&quot;java&quot;</code>。形参<code>ch</code>调用后直接改变<strong>堆</strong>中<code>java</code>的值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/11/R67pwePNqinWc4t.png" alt="image-20211211090546722"></p><p>也就是说<code>ex</code>对象指向的地方并没有改变所以最后<code>ex.str</code>输出的还是<code>&quot;hsp&quot;</code></p><p>有这道题衍生出，如果想要改变<code>ex.str</code>的值要怎么办呢？由内存图可得，让str指向常量池中的<code>&quot;java&quot;</code>即可。在类Test加一个<code>change2</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change2</span><span class="params">(Test ex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ex.str = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    ex.ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test ex = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="comment">//        ex.change(ex.str, ex.ch);</span></span><br><span class="line">        ex.change2(ex);</span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是引用传值，所以<code>main</code>中<code>ex</code>也会跟着改变，最后内存分布图为：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/11/COdaTiok6grBlQI.png" alt="image-20211211101628251"></p><p>结果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/11/1bwexI4ljUCZEMP.png" alt="image-20211211101246082"></p><h3 id="String-、StringBuffer-、StringBuilder"><a href="#String-、StringBuffer-、StringBuilder" class="headerlink" title="String 、StringBuffer 、StringBuilder"></a>String 、StringBuffer 、StringBuilder</h3><p>String：不可变字符序列，效率低，但是<strong>复用率高</strong></p><p>StringBuffer：可变字符序列，效率较高(增删)、<strong>线程安全</strong></p><p>StringBuilder：可变字符序列，<strong>效率最高</strong>，线程不安全，适合在单线程使用</p><h3 id="String使用注意说明"><a href="#String使用注意说明" class="headerlink" title="String使用注意说明"></a>String使用注意说明</h3><blockquote><p><code>String s = &quot;a&quot;;</code> //创建了一个字符串</p><p><code>s += &quot;b&quot;;</code> // 实际上原来的 “a” 字符串对象已经丢弃了，现在又产生一个字符串 s + “b”(也就是 “ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大地影响程序的性能 </p><p>结论：如果我们对 String 做大量修改，不要使用 String</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>集合体系框架图</strong></p><ol><li><p>单列集合</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/12/Qb2JscKLTGjSEiO.png" alt="image-20211212141632697"></p></li><li><p>双列集合</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/12/zIlFftdgbOwo9Bp.png" alt="image-20211212141608685"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记2</title>
      <link href="2021/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>2021/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h1><h2 id="应用层原理"><a href="#应用层原理" class="headerlink" title="应用层原理"></a><strong>应用层原理</strong></h2><h3 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a><strong>网络应用的体系结构</strong></h3><p>可能的应用架构：</p><ul><li><p>客户-服务器模式（C/S：Client / Server）</p></li><li><p>对等模式(P2P：Peer To Peer)</p></li><li><p>混合体:客户-服务器和对等体系结构</p></li></ul><h3 id="客户-服务器（C-S）体系结构"><a href="#客户-服务器（C-S）体系结构" class="headerlink" title="客户-服务器（C/S）体系结构"></a><strong>客户-服务器（C/S）体系结构</strong></h3><p>服务器：</p><ul><li>一直运行</li><li>固定的 IP 地址和周知的端口号（约定)</li><li>扩展性：服务器场数据中心进行扩展，扩展性差</li></ul><p>客户端:</p><ul><li>主动与服务器通信</li><li>与互联网有间歇性的连接</li><li>可能是动态 IP 地址</li><li>不直接与其它客户端通信</li></ul><p><strong>缺点 ：可拓展性差 达到一定能限（阈值），性能暴跌 （断崖式）可靠性差</strong></p><h3 id="对等体（P2P）体系结构"><a href="#对等体（P2P）体系结构" class="headerlink" title="对等体（P2P）体系结构"></a><strong>对等体（P2P）体系结构</strong></h3><ul><li>(几乎）没有一直运行的服务器</li><li>任意端系统之间可以进行通信</li><li>每一个节点既是客户端又是服务器<ul><li><strong>自扩展性-新peer节点带来新的</strong><br><strong>服务能力，当然也带来新的服务请求</strong></li></ul></li><li>参与的主机间歇性连接且可以改变地址<ul><li><strong>难以管理（缺点）</strong></li></ul></li><li>例子：Gnutella，迅雷</li></ul><h3 id="C-S和P2P体系结构的混合体"><a href="#C-S和P2P体系结构的混合体" class="headerlink" title="C/S和P2P体系结构的混合体"></a><strong>C/S和P2P体系结构的混合体</strong></h3><p>Napster</p><ul><li>**文件搜索：集中 **<ul><li><strong>主机在中心服务器上注册其资源</strong></li><li><strong>主机向中心服务器查询资源位置</strong></li></ul></li><li>文件传输：P2P<ul><li><strong>任意 Peer 节点之间</strong></li></ul></li></ul><p>即时通信</p><ul><li>在线检测：集中<ul><li>当用户上线时，向中心服务器注册其 IP 地址</li><li>用户与中心服务器联系，以找到其在线好友的位置</li></ul></li><li><strong>两个用户之间聊天：P2P</strong></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h3><p>进程:在主机上运行的应用程序</p><ul><li>在同一个主机内，使用<br><strong>进程间通信机制</strong>通信（操作系统定义)</li><li>不同主机，通过<strong>交换报文(Message）</strong>来通信<ul><li>使用OS提供的通信服<br>务</li><li>按照应用协议交换报文<ul><li>借助传输层提供的服务</li></ul></li></ul></li></ul><p><strong>客户端进程：发起通信的进程，服务器进程：等待连接的进程</strong></p><p><strong>注意：P2P 架构的应用也有客户端进程和服务器进程之分</strong></p><h3 id="分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）"><a href="#分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）" class="headerlink" title="分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）"></a><strong>分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/24/21LKOkeo5QxNayp.png" alt="image-20211124092145619"></p><ul><li>问题1：进程标示和寻址问题（服务用户）</li><li>问题2：传输层-应用层提供服务是如何（服务）<ul><li>位置：层间界面的 SAP （TCP/IP ：socket）</li><li>形式：应用程序接口 API （TCP/IP ：socket API）</li></ul></li><li>问题3：如何使用传输层提供的服务，实现应用进 程之间的报文交换，实现应用（用户使用服务）<ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，使用 OS 提供的 API ，调用网络基础设施提 供通信服务传报文，实现应用时序等；</li></ul></li></ul><h4 id="问题1：对进程进行编址（addressing）"><a href="#问题1：对进程进行编址（addressing）" class="headerlink" title="问题1：对进程进行编址（addressing）"></a><strong>问题1：对进程进行编址（addressing）</strong></h4><ul><li><p>进程为了接收报文，必须有一个标识</p><p>即: SAP (发送也需要标示)</p><ul><li><strong>主机:唯一的 32 位 IP 地址</strong><br>仅仅有 IP 地址不能够唯一标示一个进程;在一台端系统上有很多应用进程在运行</li><li><strong>所采用的传输层协议：TCP or UDP</strong></li><li><u>**端口号(Port Numbers) 用来区分不同的应用进程 **</u></li></ul></li><li><p>一些知名端口号的例子:</p><ul><li>HTTP: TCP 80 ，Mail: TCP 25 ，ftp: TCP 2</li></ul></li><li><p>一个进程:用 IP+port 标示端节点</p></li><li><p>本质上，一对主机进程之间的通信由 2 个端节点构成</p></li></ul><h4 id="问题2：传输层提供的服务-需要穿过层间的信息"><a href="#问题2：传输层提供的服务-需要穿过层间的信息" class="headerlink" title="问题2：传输层提供的服务-需要穿过层间的信息"></a><strong>问题2：传输层提供的服务-需要穿过层间的信息</strong></h4><p>层间接口必须要携带的信息</p><ul><li><strong>要传输的报文(对于本层来说：SDU)</strong> (SDU——未经本层封装的) （发的什么）</li><li><strong>谁传的:对方的应用进程的标示：IP + TCP (UDP)端口</strong> （谁发的）</li><li><strong>传给谁:对方的应用进程的标示:对方的 IP + TCP (UDP)端口号</strong> （发给谁）</li></ul><p>传输层实体（tcp 或者 udp 实体）根据这些信息进行 TCP 报文段 (UDP 数据报)的封装</p><ul><li>源端口号，目标端口号，数据等</li><li>将 IP 地址往下交 IP 实体，用于封装 IP 数据报:源 IP,目标 IP</li></ul><blockquote><p>如果Socket API 每次传输报文，都携带如此多 的信息，太繁琐易错，不便于管理</p><p>用个代号标示通信的双方或者单方：socket</p><p>就像OS打开文件返回的句柄一样 (对句柄的操作，就是对文件的操作)</p></blockquote><h5 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a><strong>TCP socket</strong></h5><ul><li>TCP 服务，两个进程之间的通信需要之前要建立连扫<br>两个进程通信会持续一段时间，通信关系稳定</li><li>可以用一个整数表示两个应用实体之间的通信关系<br>，本地标示</li><li>穿过层间接口的信息量最小</li><li>TCP socket: 源 IP，源端口，目标 IP，目标 IP，目标</li></ul><p><strong>TCP socket 是一个整数（类似文件描述符）代表一个四元组（我的IP和端口号 对方的IP和端口号）</strong>，<strong>便于管理使得穿过层间的信息量最小</strong>，<strong>是应用层和传输层的一个约定本地会话的标识</strong></p><p><strong>对于使用面向连接服务(TCP）的应用而言，套接字是4元组的一个具有本地意义的标识</strong></p><ul><li><p>4元组: <strong>(源 IP，源 port，目标 IP，目标 port)</strong></p></li><li><p>唯一的指定了一个会话（2个进程之间的会话关系)o应用使用这个标示，与远程的应用进程通信</p></li><li><p>不必在每一个报文的发送都要指定这4元组</p></li><li><p>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</p></li><li><p>简单，便于管理</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/24/McUve8aQFdbyt9J.png" alt="image-20211124093510780"></p><p><strong>穿过层间接口的包括 ICI 和 SDU</strong></p><h5 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a><strong>UDP socket</strong></h5><ul><li><p>UDP服务，两个进程之间的通信需要之前无需建立连接<br>每个报文都是独立传输的<br>前后报文可能给不同的分布式进程</p></li><li><p>因此，只能用一个整数表示本应用实体的标示<br>因为这个报文可能传给另外一个分布式进程·1○穿过层间接口的信息大小最小</p></li><li><p>UDP socket:本IP,本端口</p><ul><li><strong>但是传输报文时:必须要提供对方 IP，port</strong></li><li><strong>接收报文时:传输层需要上传对方的 IP，port</strong></li></ul></li></ul><p><strong>对于使用无连接服务(UDP）的应用而言，套接字是2元组的一个具有本地意义的标识</strong></p><ul><li>2元组: IP，port (源端指定)</li><li>UDP 套接字指定了应用所在的一个端节点（end point）</li><li>在发送数据报时，采用创建好的本地套接字 (标示ID），就不必在发送每个报文中指明自己所采用的 ip 和 port</li><li>但是在发送报文时，必须要指定对方的 ip 和 udpport (另外一个段节点)</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/24/e4wCojD1ZpRGMEt.png" alt="image-20211124093802473"></p><h5 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a><strong>套接字（Socket）</strong></h5><p><u><strong>进程向套接字发送报文或从套接字接收报文</strong></u></p><p>套接字&lt;-&gt;门户</p><ul><li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的<br>门将报文交付给接受进程</li><li>接收进程从另外一端的门户收到报文（依赖于传输层设施)</li></ul><h4 id="问题3：如何使用传输层提供的服务实现应用"><a href="#问题3：如何使用传输层提供的服务实现应用" class="headerlink" title="问题3：如何使用传输层提供的服务实现应用"></a><strong>问题3：如何使用传输层提供的服务实现应用</strong></h4><ol><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，<strong>通过 API 调用网络基础设施提供通信服务</strong>传报文，解析报文，实现应用时序等</li></ol><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a><strong>应用层协议</strong></h3><p>定义了:运行在不同端系统上的应用进程如何相互交换报文</p><ul><li>交换的报文类型:请求和应答报文</li><li>各种报文类型的<strong>语法</strong>:报文中的客个字段及其描述</li><li>字段的<strong>语义</strong>:即字段取值的含义进程何时、如何发送报文及对报文进行响应的<strong>规则</strong></li></ul><p>应用协议仅仅是应用的一个组成部分<br>Web应用:HTTP协议，web客户端，web服务器，HTML(超文本标记语言)</p><p>公开协议： 由RFC文档定义，允许互操作 如 HTTP, SMTP<br>专用（私有）协议：协议不公开 如：Skype</p><h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a><strong>Internet 传输层提供的服务</strong></h3><p><strong>TCP 服务</strong></p><blockquote><p><strong>可靠的传输服务</strong><br><strong>流量控制</strong>：发送方不会淹没接受方<br><strong>拥塞控制</strong>：当网络出现拥 塞时，能抑制发送方<br><strong>不能提供的服务</strong>：时间保证、最小吞吐保证和安全<br><strong>面向连接</strong>：要求在客户端 进程和服务器进程之间建 立连接</p></blockquote><p><strong>UDP 服务</strong></p><blockquote><p><strong>不可靠数据传输</strong><br><strong>不提供的服务</strong>：可靠，流量控制、拥塞控制、时间、带宽保证、建立 连接</p></blockquote><p>为什么要有 UDP?</p><h4 id="UDP-存在的必要性"><a href="#UDP-存在的必要性" class="headerlink" title="UDP 存在的必要性"></a><strong>UDP 存在的必要性</strong></h4><ul><li><p>能够区<strong>分不同的进程</strong>，而 IP 服务不能</p><ul><li>在 IP 提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li><p><strong>无需建立连接</strong>，省去了建立连接时间，适合事务性的应用</p></li><li><p><strong>不做可靠性的工作</strong>，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用</p><ul><li>因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发〉</li></ul></li><li><p>没有拥塞控制和流量控制，<strong>应用能够按照设定的速度发送数据</strong></p><ul><li>而在 TCP上 面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有<strong>流量控制和拥塞控制</strong></li></ul></li></ul><h3 id="安全-TCP"><a href="#安全-TCP" class="headerlink" title="安全 TCP"></a><strong>安全 TCP</strong></h3><p><strong>TCP &amp; UDP</strong></p><blockquote><p>都没有加密；明文通过互联网传输 ，甚至密码</p></blockquote><p><strong>SSL</strong></p><blockquote><p>在TCP上面实现，提供加密的 TCP 连接<br>私密性<br>数据完整性<br>端到端的鉴别</p></blockquote><p><strong>SSL在应用层</strong>：应用采用 SSL 库，SSL 库使用 TCP 通信</p><p><strong>SSL socket API</strong></p><blockquote><p>应用通过 API 将明文交给 socket，SSL 将其加密在互联网上传输</p></blockquote><p>常见的例子：Https –&gt; Http + SSL（Https 跑在 SSL + TCP 上）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/24/4EkYwOeHMzPXtnD.png" alt="image-20211124100125798"></p><h2 id="Web-and-Http"><a href="#Web-and-Http" class="headerlink" title="Web and Http"></a><strong>Web and Http</strong></h2><p>一些术语</p><ul><li><p>Web页:由一些对象组成</p></li><li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p></li><li><p>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接)</p></li><li><p>通过URL对每个对象进行引用<br>访问协议，用户名，口令字，端口等；</p></li><li><p>URL 格式</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/25/EyYqu6FX97gLHfe.png" alt="image-20211125211225105"></p></li></ul><h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a><strong>HTTP 概况</strong></h3><p><strong>HTTP：超文本传输协议</strong></p><ul><li>Web 的应用层协议</li><li>客户 / 服务器模式<ul><li>客户: 请求、接收和显示 Web 对象的浏览器</li><li>服务器: 对请求进行响应，发送对象的 Web 服务器</li></ul></li><li>HTTP 1.0: RFC 1945</li><li>HTTP 1.1: RFC 2068</li></ul><p><strong>使用 TCP：</strong></p><blockquote><p>客户发起一个与服务器的 TCP 连接 (建立套接字) ，端口号为 80 –&gt;<br>服务器接受客户的 TCP 连接 –&gt;<br>在浏览器(HTTP客户端) 与 Web 服务器(HTTP 服务器 server)交换 HTTP 报文 (应用层协议报文)  –&gt;<br>TCP 连接关闭</p></blockquote><p><strong>HTTP是无状态的</strong>：服务器并不维护关 于客户的任何信息</p><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a><strong>HTTP 连接</strong></h3><p><strong>非持久 HTTP</strong>：最多只有一个对象在 TCP 连接上发送、下载多个对象需要多个 TCP 连接、HTTP/1.0 使用非持久连接</p><p><strong>持久 HTTP</strong>：多个对象可以在一个（在客户端和服务器之间的）TCP 连接上传输、HTTP/1.1 默认使用持久连接</p><h3 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a><strong>响应时间模型</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/25/5JxrSXVCqu2WhaQ.png" alt="image-20211125212244794"></p><p>**往返时间 RTT (round-trip time)**：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略）</p><p><strong>响应时间：</strong>一个 RTT 用来发起 TCP 连接、一个 RTT 用来 HTTP 请求并等待 HTTP 响应、文件传输时间</p><p>共：<strong>2RTT+ 传输时间</strong></p><blockquote><p><strong>非持久 HTTP 的缺点：</strong></p><ul><li>每个对象要2个 RTT</li><li>操作系统必须为每个TCP连接分 配资源</li><li>但浏览器通常打开并行TCP连接 ，以获取引用对象</li></ul></blockquote><blockquote><p><strong>持久 HTTP:</strong></p><ul><li>服务器在发送响应后，仍保持 TCP 连接</li><li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</li></ul><p><strong>非流水方式的持久 HTTP：</strong></p><ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个 RTT</li></ul><p><strong>流水方式的持久 HTTP：</strong></p><ul><li>HTTP/1.1 的默认模式</li><li>客户端遇到一个引用对象就立即 产生一个请求</li><li>所有引用（小）对象只花费一个 RTT 是可能的</li></ul></blockquote><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a><strong>HTTP 请求报文</strong></h3><p>两种类型的 HTTP 报文：<strong>请求、响应</strong></p><p>HTTP 请求报文：ASCII (人能阅读)</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/25/qGwsJC8ylfM6eap.png" alt="image-20211125213556865"></p><p><strong>HTTP 请求报文：通用格式</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/25/TudZoaClryzGpvA.png" alt="image-20211125213646487"></p><p><strong>提交表单输入</strong></p><ol><li>Post 方式：网页通常包括表单输 入、包含在实体主体 (entity body )中的 输入被提交到服务器</li><li>URL 方式：方法：GET、输入通过请求行的 URL 字段上载</li></ol><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a><strong>HTTP 响应报文</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/25/5anteQO94pIuYHr.png" alt="image-20211125213840289"></p><p><strong>HTTP 响应状态码</strong></p><p>位于服务器 → 客户端的响应报文中的首行一些状态码的例子:</p><ol><li>200 OK<ul><li>请求成功，请求对象包含在响应报文的后续部分</li></ul></li><li>301 Moved Permanently<ul><li>请求的对象己经被永久转移了;新的URL在响应报文的Location:首部行中指定客户端软件自动用新的URL去获取对象</li></ul></li><li>400 Bad Request<ul><li>一个通用的差错代码，表示该请求不能被服务器解读</li></ul></li><li>404 Not Found<ul><li>请求的文档在该服务上没有找到</li></ul></li><li>505 HTTP version Not supported</li></ol><h3 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a><strong>用户-服务器状态：cookies</strong></h3><p><strong>大多数主要的门户网站使 用 cookies 4个组成部分：</strong></p><ol><li><strong>在 HTTP 响应报文中有一个 cookie 的首部行</strong></li><li><strong>在 HTTP 请求报文含有一个 cookie 的首部行</strong></li><li><strong>在用户端系统中保留有一个 cookie 文件，由用户的浏览器管理</strong></li><li><strong>在 Web 站点有一个后端数据库</strong></li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p>Susan 总是用同一个 PC 使用 Internet Explore 上网，她第一次访问了一个使用了 Cookie 的电子商务网站，当最初的 HTTP 请求到达服务器时，该 Web 站点 产生一个唯一的 ID，并以此作为索引在它的后端数据库中产生一个项</p><p><strong>Cookies: 维护状态</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/25/eLguyWG74B5fNdq.png" alt="image-20211125214438927"></p><p><strong>Cookies能带来什么：</strong>用户验证、购物车、推荐、用户状态 (Web e-mail)</p><p><strong>如何维持状态：</strong>协议端节点：在多个事务上 ，发送端和接收端维持状态。cookies: http 报文携带状态信息</p><h3 id="Web缓存-代理服务器"><a href="#Web缓存-代理服务器" class="headerlink" title="Web缓存 (代理服务器)"></a><strong>Web缓存 (代理服务器)</strong></h3><p>不访问<strong>原始</strong>服务器，就满足客户的请求</p><ul><li>用户设置浏览器：通过缓存访问 Web</li><li>浏览器将所有的 HTTP 请求发给缓存<ul><li>在缓存中的对象：缓存直接返回对象</li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul></li></ul><p>缓存既是客户端又是服务器，通常缓存是由 ISP 安装 (大学、公司、居民区 ISP)</p><p>使用 Web 缓存带来的好处：1. 降低客户端的请求响应时间。2. 可以大大减少一个机构内部网络与 Internent 接入链路上的流量。3、互联网大量采用了缓存：可以使较弱的 ICP 也能够有效提供内容</p><h4 id="缓存示例"><a href="#缓存示例" class="headerlink" title="缓存示例"></a><strong>缓存示例</strong></h4><blockquote><p>假设平均对象大小 = 100 kb，机构内浏览器对原始服务器的平均请求率为 = 15 请求/s，平均到浏览器的速率：1.5 Mbps，机构内部路由器到原始服务器再返回到路由器的的延时（ Internet 延时）= 2s，接入链路带宽：1.54 Mbps</p><p>假设：平均对象大小 = 100kb、机构内浏览器对原始服务器的 平均请求率为 = 15请求/s，平均到浏览器的速率：1.5Mbps，机构内部路由器到原始服务器 再返回到路由器的的延时 （ Internet 延时）= 2s，接入链路带宽：1.54Mbps。<strong>接入链路宽带：1.54 Mbps –&gt; 154 Mbps</strong></p><p>结果：LAN 的流量强度 = 15%，接入链路上的流量强度 = 99%、总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s</p><p><strong>代价: 增加了接入链路带宽（非常昂贵！）</strong></p><p><strong>排队延迟降低</strong></p></blockquote><p><strong>t (queue) = I/(1 - I) * L / R</strong><br><strong>I —— 流量强度， L/R —— 一个分组的传输时间排队延迟非常大</strong></p><h3 id="缓存例子：安装本地缓存"><a href="#缓存例子：安装本地缓存" class="headerlink" title="缓存例子：安装本地缓存"></a><strong>缓存例子：安装本地缓存</strong></h3><p>假设平均对象大小 = 100kb 机构内浏览器对原始服务器的平均请求率为 = 15请求/s 平均到浏览器的速率：1.5Mbps <strong>机构内部路由器到原始服务器再返回到路由器的的延时 (Internet 延时）= 2s</strong>，接入链路带宽：1.54Mbps </p><p>结果：LAN 利用率: 15% 。接入网络利用率： ？。 总体延迟 = ? How to compute link utilization, delay? <strong>代价: web缓存(廉价!)</strong></p><p><strong>计算链路利用率，有缓存的延迟：</strong></p><ul><li><p>假设缓存命中率 0.4，40%请求在缓存中被满足，其他60%的请求需要被原始服务器满足（也就是说重新请求原始服务器发送数据）</p></li><li><p>接入链路利用率: 60%的请求采用接入链路</p></li><li><p>进过接入链路到达浏览器的数据速率 = 0.6 * 1.50 Mbps = 0.9 Mbps，利用率= 0.9/1.54 = 0.58</p></li><li><p><strong>总体延迟：总体延迟 = 0.6 * (从原始服务器获取对象的延迟) + 0.4 * (从缓存获取对象的延迟) = = 0.6 (2.01) + 0.4 (~msecs)  = = ~ 1.2 secs</strong></p></li></ul><p>比安装 154Mbps 链路还来得小 (而且比较便宜!)</p><p><strong>条件GET方法（对象版本和服务器版本一致性问题）</strong></p><p>目标：如果缓存器中的对 象拷贝是最新的，就不要发送对象</p><p>缓存器: 在HTTP请求中指 定缓存拷贝的日期 If-modified-since: &lt;date&gt;</p><p>服务器: 如果缓存拷贝陈 旧，则响应报文没包含对象: HTTP/1.0 304 Not Modified</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP*"></a><strong>FTP</strong>*</h2><h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP: 文件传输协议"></a><strong>FTP: 文件传输协议</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/F4BycUiqaVMv8su.png" alt="image-20211128092429764"></p><blockquote><p>向远程主机上传输文件或从远程主机接收文件<br>客户/服务器模式，客户端：发起传输的一方，服务器：远程主机<br>ftp: RFC 959<br>ftp 服务器：端口号为21</p></blockquote><h3 id="FTP：控制连接与数据连接分开"><a href="#FTP：控制连接与数据连接分开" class="headerlink" title="FTP：控制连接与数据连接分开"></a><strong>FTP：控制连接与数据连接分开</strong></h3><blockquote><p>FTP 客户端与 FTP 服务器啊通过端口 21 联系，并使用 TCP 为传输协议。客户端通过控制连接获得身份确认。客户端通过控制连接发送命令浏览远程目录。收到一个文件传输命令时，服务器打开一个到客户端的数据连接。一个文件传输完成后，服务器关闭连接。</p><p>服务器打开第二个 TCP 数据连接用来传输另一个文件<br>控制连接：<strong>外带（“out of band：）传送</strong><br>FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应<br><strong>有状态的协议</strong></p></blockquote><h3 id="FTP-命令、响应"><a href="#FTP-命令、响应" class="headerlink" title="FTP 命令、响应"></a><strong>FTP 命令、响应</strong></h3><p><strong>命令样例</strong></p><blockquote><p>在控制连接上以 ASCII 文本方式传送<br>USER username<br>PASS password<br>LIST：请服务器返回远程主机当前目录的文件列表<br>RETR filename：从远程主 机的当前目录检索文件 (gets)<br>STOR filename：向远程主 机的当前目录存放文件 (puts)</p></blockquote><p><strong>返回码样例</strong></p><blockquote><p>状态码和状态信息 (同HTTP)<br>331 Username OK, password required<br>125 data connection already open;  transfer starting<br>425 Can’t open data connection<br>452 Error writing file</p></blockquote><h2 id="EMail"><a href="#EMail" class="headerlink" title="EMail"></a>EMail</h2><p>**三个主要组成部分: ** 用户代理，邮件服务器，简单邮件传输协议：SMTP</p><p><strong>用户代理：</strong>又名”邮件阅读器“，撰写、编辑和阅读邮件，如：Outlook、Foxmail。输入和输入邮件保存在服务器上</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/A81vnpHmNVFl5kT.png" alt="image-20211128151734152"></p><p><strong>邮件服务器</strong></p><blockquote><p> 邮箱中管理和维护发送给用户的邮件<br> 输出报文队列保持待发送邮件报文<br> 邮件服务器之间的SMTP协议 ：发送email报文<br> 客户：发送方邮件服务器<br>服务器：接收端邮件服务器</p></blockquote><h3 id="EMail-SMTP-RFC-2821-原理"><a href="#EMail-SMTP-RFC-2821-原理" class="headerlink" title="EMail: SMTP [RFC 2821] 原理"></a><strong>EMail: SMTP [RFC 2821] 原理</strong></h3><blockquote><p>使用 TCP 在客户端和服务器之间传送报文，端口号为 25<br>直接传输：从发送方服务器到接收方服务器<br>传输的3个阶段：握手、传输报文、关闭<br>命令/相应交互：命令：ASCII 文本；响应：状态码和状态信息<br>报文必须为 7 位 ASCII 码</p></blockquote><p><strong>举例：Alice 给 Bob 发送报文</strong></p><p>Alice 使用用户代理撰写邮件并发送给 <code>bob@someschool.edu</code>。Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中<br>SMTP 的客户端打开到 Bob 邮件服务器的 TCP 连接。SMTP 客户端通过 TCP 连接发送 Alice 的邮件<br>Bob 的邮件服务器将邮件放到 Bob 的邮箱，Bob调用他的用户代理阅读邮件</p><h3 id="简单的-SMTP-交互"><a href="#简单的-SMTP-交互" class="headerlink" title="简单的 SMTP 交互"></a><strong>简单的 SMTP 交互</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S: 220 hamburger.edu</span><br><span class="line">C: HELO crepes.fr</span><br><span class="line">S: 250 Hello crepes.fr, pleased to meet you</span><br><span class="line">C: MAIL FROM: &lt;alice@crepes.fr&gt;</span><br><span class="line">S: 250 alice@crepes.fr... Sender ok</span><br><span class="line">C: RCPT TO: &lt;bob@hamburger.edu&gt;</span><br><span class="line">S: 250 bob@hamburger.edu ... Recipient ok</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 Enter mail, end with &quot;.&quot; on a line by itself</span><br><span class="line">C: Do you like ketchup?</span><br><span class="line">C: How about pickles?</span><br><span class="line">C: .</span><br><span class="line">S: 250 Message accepted for delivery</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 hamburger.edu closing connection</span><br></pre></td></tr></table></figure><h3 id="SMTP：总结"><a href="#SMTP：总结" class="headerlink" title="SMTP：总结"></a><strong>SMTP：总结</strong></h3><ul><li>SMTP使用持久连接</li><li>SMTP要求报文（首部和主体）为7位ASCII编码</li><li>SMTP服务器使用 CRLF.CRLF 决定报文的尾部</li></ul><p><strong>HTTP比较：</strong></p><ul><li>HTTP：拉（pull）</li><li>SMTP：推（push）</li><li>二者都是ASCII形式的 命令/响应 交互、状态码</li><li>HTTP：每个对象封装在各自的响应报文中</li><li>SMTP：多个对象包含在一个报文中</li></ul><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a><strong>邮件报文格式</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/WYKEt6HUnw3CkGm.png" alt="image-20211128153744928"></p><p><strong>报文格式：多媒体扩展</strong></p><p>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056</p><p>在报文首部用额外的行申明MIME内容类型</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/hTfqAXvQj2DHS3Z.png" alt="image-20211128154303599"></p><p><a href="https://juejin.cn/post/6844904197519835150">常用 Base64 对 STMP 的 ASCII 码进行拓展，传输更多内容</a></p><blockquote><p>Base64 常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。<strong>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。</strong>使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p></blockquote><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a><strong>邮件访问协议</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/R3mXQ9g5elUc7OB.png" alt="image-20211128154334007"></p><h4 id="两推一拉"><a href="#两推一拉" class="headerlink" title="两推一拉"></a><strong>两推一拉</strong></h4><blockquote><p>SMTP: 传送到接收方的邮件服务器<br>邮件访问协议：从服务器访问邮件</p><ul><li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul><li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li></ul></li><li>IMAP：Internet 邮件访问协议（Internet Mail Access Protocol）[RFC 1730]<ul><li>更多特性 (更复杂)</li><li>在服务器上处理存储的报文</li></ul></li><li>HTTP：Hotmail , Yahoo! Mail等</li></ul></blockquote><h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a><strong>POP3协议</strong></h4><p><strong>用户确认阶段：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/SwkMcQKXo1vnYVl.png" alt="image-20211128155613140"></p><blockquote><p>客户端命令：user–&gt;申明用户名; pass –&gt; 口令<br>服务器响应：+OK；-ERR</p></blockquote><p><strong>事务处理阶段</strong>，客户端：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/28/8KCJNp7WAziqcUM.png" alt="image-20211128155647279"></p><blockquote><p>list: 报文号列表<br>retr: 根据报文号检索报文<br>dele: 删除<br>quit</p></blockquote><p><strong>POP3</strong></p><blockquote><p>先前的例子使用 “下载并删除”模式。<br>如果改变客户机，Bob 不能阅读邮件<br>“下载并保留”：不同客户机上为报文的拷贝<br>POP3在会话中是无状态的</p></blockquote><p><strong>IMAP</strong></p><blockquote><p>IMAP服务器将每个报文 与一个文件夹联系起来<br>允许用户用目录来组织 报文<br>允许用户读取报文组件<br>IMAP在会话过程中保留 用户状态：<br>目录名、报文ID与目录名 之间映射</p></blockquote><h2 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a><strong>DNS(Domain Name System)</strong></h2><h3 id="DNS-的必要性"><a href="#DNS-的必要性" class="headerlink" title="DNS 的必要性"></a><strong>DNS 的必要性</strong></h3><ul><li>IP 地址标识主机、路由器</li><li>但 IP 地址不好记忆，不便人类使用(没有意义)</li><li>人类一般倾向于使用一些有意义的字符串来标识 Internet 上的设备。如：<a href="http://www.google.com/">www.google.com</a></li><li>存在着“字符串”— IP 地址的转换的必要性</li><li>人类用户提供要访问机器的“字符串”名称</li><li>由 DNS 负责转换成为二进制的网络地址</li></ul><p><strong>DNS 系统需要解决的问题</strong></p><ol><li><strong>如何命名设备</strong><ul><li>用有意义的字符串：好记，便于人类用使用</li><li><strong>解决一个平面命名的重名问题：层次化命名</strong></li></ul></li><li><strong>如何完成名字到 IP 地址的转换</strong><ul><li><strong>分布式的数据库维护和响应名字查询</strong></li></ul></li><li><strong>如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</strong></li></ol><h3 id="DNS-总体思路和目标"><a href="#DNS-总体思路和目标" class="headerlink" title="DNS 总体思路和目标"></a><strong>DNS 总体思路和目标</strong></h3><p><strong>DNS 的主要思路</strong></p><blockquote><p><strong>分层</strong>的、基于域的命名机制<br>若干<strong>分布式</strong>的数据库完成名字到IP地址的转换<br>运行在 UDP 之上端口号为 53 的<strong>应用服务</strong><br>核心的 Internet 功能，但以应用层协议实现<br><strong>在网络边缘处理复杂性 （互联网最核心的功能（DNS）在边缘系统实现的）</strong></p></blockquote><p><strong>DNS 的目的</strong></p><blockquote><p>实现主机名 — IP 地址的转换(name/IP translate) （主要功能/主要目的）<br><strong>主机别名到 规范名字 的转换：Host aliasing</strong><br><strong>邮件服务器别名到邮件服务器的 正规名字 的转换：Mail server aliasing</strong><br><strong>负载均衡：Load Distribution（分配具体的服务器提供服务）</strong></p></blockquote><h3 id="问题1：DNS名字空间-The-DNS-Name-Space"><a href="#问题1：DNS名字空间-The-DNS-Name-Space" class="headerlink" title="问题1：DNS名字空间(The DNS Name Space)"></a><strong>问题1：DNS名字空间(The DNS Name Space)</strong></h3><p><strong>DNS域名结构</strong></p><ul><li><p>一个层面命名设备会有很多重名</p></li><li><p>NDS采用层次树状结构的命名方法</p></li><li><p>Internet 根被划为几百个顶级域(top lever domains)</p><blockquote><p>通用的(generic)<br>.com、 .edu 、 .gov 、 .int 、 .mil 、 .net 、 .org 、 .firm 、 .hsop 、 .web 、 .arts 、 .rec  </p><p>国家的(countries)<br>.cn 、 .us 、 .nl 、 .jp</p></blockquote></li><li><p>每个(子)域下面可划分为若干子域(subdomains)</p></li><li><p>树叶是主机</p></li></ul><p><strong>DNS 名字空间</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/zBQ1JZ7viPEXTHb.png" alt="image-20211129213356708"></p><p>域名(Domain Name)</p><ul><li><p><strong>从本域往上，直到树根</strong></p></li><li><p><strong>中间使用“.”间隔不同的级别</strong></p><ul><li><p>如：ustc.edu.cn</p><p>​      auto.ustc.edu.cn</p><p>​      <a href="http://www.auto/">www.auto</a>. ustc.edu.cn</p></li></ul></li><li><p>域的域名：可以用于表示一个域</p></li><li><p>主机的域名：一个域上的一个主机</p></li><li><p>域名的管理</p><ul><li><p>一个域管理其下的子域</p><p>如：.jp 被划分为 ac.jp co.jp</p><p>​      .cn 被划分为 edu.cn com.cn</p></li><li><p><strong>创建一个新的域，必须征得它所属域的同意</strong></p></li></ul></li><li><p><strong>域与物理网络无关</strong></p><ul><li><p><strong>域遵从组织界限，而不是物理网络</strong></p><p>一个域的主机可以不在一个网络；一个网络的主机不一定在一个域</p></li><li><p><strong>域的划分是逻辑的，而不是物理的</strong></p></li></ul></li></ul><h3 id="问题2：解析问题-名字服务器-Name-Server"><a href="#问题2：解析问题-名字服务器-Name-Server" class="headerlink" title="问题2：解析问题-名字服务器(Name Server)"></a><strong>问题2：解析问题-名字服务器(Name Server)</strong></h3><h4 id="一个名字服务器的问题"><a href="#一个名字服务器的问题" class="headerlink" title="一个名字服务器的问题"></a><strong>一个名字服务器的问题</strong></h4><ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库</li></ul><h4 id="区域-zone"><a href="#区域-zone" class="headerlink" title="区域(zone)"></a><strong>区域(zone)</strong></h4><ul><li>区域的划分有区域管理者自己决定</li><li>将 DNS 名字空间划分为互不相交的区域，每个区域都是树的一部分</li><li>名字服务器：<ul><li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record)</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul><p><strong>名字空间划分为若干区域</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/b4BlVOsmT5euPi6.png" alt="image-20211129215524387"></p><p><strong>权威DNS服务器：组织机构的DNS服务器， 提供组织机构服务器（如 Web和mail）可访问的主机和IP之间的映射</strong><br>组织机构可以选择实现自己维护或由某个服务提供商来维护</p><h4 id="TLD-服务器"><a href="#TLD-服务器" class="headerlink" title="TLD 服务器"></a><strong>TLD 服务器</strong></h4><p>顶级域(TLD)服务器：负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如 cn, uk, fr, ca, jp ）</p><p>Network solutions 公司维护 com TLD 服务器</p><p>Educause公司维护edu TLD服务器</p><h4 id="区域名字服务器维护资源记录"><a href="#区域名字服务器维护资源记录" class="headerlink" title="区域名字服务器维护资源记录"></a><strong>区域名字服务器维护资源记录</strong></h4><p><strong>资源记录(resource records)</strong></p><p>作用：维护 域名-IP地址(其它)的映射关系</p><p>位置：Name Server的分布式数据库中</p><p><strong>RR格式: (domain_name, ttl, type,class,Value)</strong></p><blockquote><p>Domain_name: 域名<br>Ttl: time to live : 生存时间(权威，缓冲记录)<br>Class 类别 ：对于Internet，值为IN<br>Value 值：可以是数字，域名或ASCII串<br>Type 类别：资源记录的类型</p></blockquote><p><strong>DNS 记录</strong></p><p>DNS ：保存资源记录(RR)的分布式数据库</p><p>RR 格式：(name, value, type, ttl)</p><table><thead><tr><th align="center">Type</th><th align="center">Name</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">Name 为主机</td><td align="center">Value 为 IP 地址</td></tr><tr><td align="center">NS</td><td align="center">Name 域名(如foo.com)</td><td align="center">Value 为 为该域名的权威服务器的域名</td></tr><tr><td align="center">CNAME</td><td align="center">Name 为规范名字的别名</td><td align="center">Value 为规范名字</td></tr><tr><td align="center">MX</td><td align="center">————————–</td><td align="center">Value为name对应的邮件服务器的名字</td></tr></tbody></table><p><strong>TTL：生存时间，决定了资源记录应当从缓存中删除的时间</strong></p><p>信息1 （叫什么）<br><strong>TYPE = NS Name放的是子域的名字<br>Value 子域名字服务器（权威 DNS 服务器）的名字</strong></p><p>信息2 （在哪）<br><strong>Type = A Name放的是名字（子域的名字）</strong><br><strong>Value 对应服务器的 IP 地址</strong></p><h3 id="DNS-大致工作过程"><a href="#DNS-大致工作过程" class="headerlink" title="DNS 大致工作过程"></a><strong>DNS 大致工作过程</strong></h3><p><strong>一台设备上网必备的IP信息</strong><br><strong>我的IP地址 我的子网掩码 我的local name serve 我的default getway（路由器）</strong></p><p>应用调用 解析器(resolver)<br>解析器作为客户 向Name Server发出查询报文 （封装在UDP段中）<br>Name Server返回响应报文(name/ip)</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/qO8CQZxAGSutl4d.png" alt="image-20211129221054857"></p><p>并不严格属于层次结构<br>每个ISP (居民区的ISP、公司、大学）都有一 个本地DNS服务器<br>也称为“默认名字服务器”<br>当一个主机发起一个DNS查询时，查询被送到 其本地DNS服务器<br>起着代理的作用，将查询转发到层次结构中</p><h4 id="名字服务器-Name-Server"><a href="#名字服务器-Name-Server" class="headerlink" title="名字服务器(Name Server)"></a><strong>名字服务器(Name Server)</strong></h4><p>名字解析过程<br>目标名字在Local Name Server中<br>情况1：查询的名字在该区域内部<br>情况2：缓存(cashing)</p><p>当与本地名字服务器不能解析名字时，联系根名字服务器 顺着根-TLD 一直找到 权威名字服务器</p><p><strong>递归查询</strong></p><blockquote><p><strong>名字解析负担都 放在当前联络的 名字服务器上</strong><br>问题：根服务器 的负担太重<br>解决： 迭代查询 (iterated queries)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/rsj1ngcZCBQaVYy.png" alt="image-20211129221409344"></p><p><strong>迭代查询</strong></p><blockquote><p>主机cis.poly.edu 想知道主机 gaia.cs.umass.edu 的 IP 地址<br><strong>根（及各级域名）服务器返回的不是查询结果，而 是下一个 NS 的地址</strong><br><strong>最后由权威名字服务器给出解析结果</strong><br>当前联络的服务器给出可以联系的服务器的名字<br>“我不知道这个名字，但可以向这个服务器请求</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/SRhmYkWeDEjxdas.png" alt="image-20211129221420914"></p><h3 id="DNS-协议、报文"><a href="#DNS-协议、报文" class="headerlink" title="DNS 协议、报文"></a><strong>DNS 协议、报文</strong></h3><p>DNS协议：查询和响应报文的报文格式相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/ZG7KfNsYSjOcHoA.png" alt="image-20211129221439349"></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/29/MqrHx8pJ9nD6IBo.png" alt="image-20211129221501466"></p><p><strong>提高性能：缓存</strong></p><blockquote><p>一旦名字服务器学到了一个映射，就将该映射 缓存起来<br>根服务器通常都在本地服务器中缓存着<br>使得根服务器不用经常被访问<br>目的：提高效率<br>可能存在的问题：如果情况变化，缓存结果和 权威资源记录不一致<br>解决方案：TTL（默认2天）</p></blockquote><h3 id="问题3：维护问题：新增一个域"><a href="#问题3：维护问题：新增一个域" class="headerlink" title="问题3：维护问题：新增一个域"></a><strong>问题3：维护问题：新增一个域</strong></h3><ul><li><p><strong>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</strong><br>（Type = NS、 Type = A 相当于指针）</p></li><li><p>在新增子域的名字服务器上运行名字服务器，负责本域<br>的名字解析:名字-&gt;IP地址<br>例子:在com域中建立一个“Network Utopia”</p></li><li><p>到注册登记机构注册域名networkutopia.com</p><ul><li>需要向该机构提供权威 DNS 服务器（基本的、和辅助的）的名字和IP地址</li><li>登记机构在com TLD 服务器中插入两条 RR 记录:<br>( networkutopia.com,dns1.networkutopia.com,NS )( dns1.networkutopia.com,212.212.212.1,A)</li></ul></li><li><p>在networkutopia.com的权威服务器中确保有</p><ul><li>用于Web服务器的 <a href="http://www.networkuptopia.com/">www.networkuptopia.com</a> 的类型为 A 的记录</li><li>用于邮件服务器 mail.networkutopia.com 的类型为 MX 的记录 </li></ul></li></ul><h2 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a><strong>P2P 应用</strong></h2><p>没有（或极少）一直运行的服务器，任意端系统都可以直接通信，利用 peer 的服务能力，Peer 节点间歇上网，每次 IP 地址都有可能变化。</p><p>例如(括号里的为实例)：文件分发 (BitTorrent)、流媒体 (KanKan)、VoIP (Skype)</p><h3 id="文件分发-C-S-vs-P2P"><a href="#文件分发-C-S-vs-P2P" class="headerlink" title="文件分发: C/S vs P2P"></a><strong>文件分发: C/S vs P2P</strong></h3><p>问题: 从一台服务器分发文件（大小 F）到N个peer 需要多少时间？</p><p><strong>C/S 模式</strong></p><blockquote><p>服务器传输：都是由服务器发送给 peer，服务器必须顺序传输（上载）N 个文件拷贝:</p><ul><li><strong>发送一个copy: F/u(s)（上载）</strong></li><li><strong>发送N个copy: NF/u(s) （上载）</strong></li></ul><p>客户端: 每个客户端必须下载一个文件拷贝</p><ul><li>dmin = 客户端最小的下载速率</li><li><strong>下载带宽最小的客户端下载的 时间：F/d(min) （下载）</strong></li></ul></blockquote><p><u><strong>采用 C/S 方法 将一个 F 大小的文件 分发给 N 个客户端耗时 D(c/s) &gt;= max{ NF / u(s)（随着 N 线性增长 ）,F / d(min) }(瓶颈却决于服务器的性能和客户端性能的相对强弱)</strong></u></p><p><strong>文件分发时间: P2P模式</strong></p><blockquote><p>服务器传输：最少需要<strong>上载</strong>一份拷贝</p><ul><li><strong>发送一个拷贝的时间：F/u(s)（上载）</strong></li></ul><p>客户端: 每个客户端必须<strong>下载</strong>一个拷贝</p><ul><li><strong>最小下载带宽客户单耗时: F/d(min)（下载）</strong></li></ul><p>客户端: 所有客户端总体下载量 NF</p><ul><li><strong>最大上载带宽是：u(s)（服务器的）+ ∑u(i) (所有客户端的)（上载）</strong></li><li><strong>除了服务器可以上载，其他所有的 peer 节点都可以上载</strong></li></ul></blockquote><p><u><strong>采用P2P方法 将一个F大小的文件 分发给N个客户端耗时 D(p2p) &gt; max{ F / u(s), F / d(min),NF / (u(s) + ∑u(i)) }</strong></u></p><h4 id="C-S-vs-P2P-例子"><a href="#C-S-vs-P2P-例子" class="headerlink" title="C/S vs. P2P: 例子"></a><strong>C/S vs. P2P: 例子</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/30/GpzYPuZAvItQK2h.png" alt="image-20211130162013544"></p><p>C/S 线性<br>P2P 非线性, 性能高可拓展性强, 难管理（动态性强）</p><p>非结构化 P2P 任意连接<br>DHT 结构化 P2P 如：环形、树 <strong>节点哈希 内容哈希, 按一定规律存内容</strong></p><h3 id="P2P-文件共享"><a href="#P2P-文件共享" class="headerlink" title="P2P 文件共享"></a><strong>P2P 文件共享</strong></h3><p>例子<br>Alice 在其笔记本电脑上运行 P2P 客户端程序间歇性地连接到 Internet，每次从其 ISP 得到新的 IP 地址。请求“双截棍.MP3”应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方</p><p>Alice 选择其中一个对等方， 如Bob。文件从Bob’s PC传送到 Alice的笔记本上：HTTP 当 Alice下载时，其他用户也可以从Alice处下载 Alice 的<strong>对等方既是一个 Web 客户端，也是一个瞬时 Web 服务器</strong></p><p><strong>所有的对等方都是服务器 –&gt; 可扩展性好！</strong></p><p><strong>两大问题</strong></p><ol><li>如何定位所需资源</li><li>如何处理对等方的加入与离开</li></ol><p><strong>可能的方案</strong></p><ol><li>集中 2. 分散 3. 半分散</li></ol><h3 id="P2P：集中式目录"><a href="#P2P：集中式目录" class="headerlink" title="P2P：集中式目录"></a><strong>P2P：集中式目录</strong></h3><p>最初的“Napster”设计</p><ol><li>当对等方连接时，它告知中心服务器： IP地址、内容</li><li>Alice查询 “双截棍 .MP3”</li><li>Alice 从 Bob处请求文件</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/30/9B2hy1gUAPFozKv.png" alt="image-20211130164535185"></p><p><strong>集中式目录中存在的问题</strong></p><ol><li>单点故障 2. 性能瓶颈 3. 侵犯版权</li></ol><p><strong>文件传输是分散的，而定位内容则是高度集中的</strong></p><h3 id="查询洪泛：Gnutella（完全分布式）"><a href="#查询洪泛：Gnutella（完全分布式）" class="headerlink" title="查询洪泛：Gnutella（完全分布式）"></a><strong>查询洪泛：Gnutella（完全分布式）</strong></h3><p>特点：</p><blockquote><p><strong>全分布式</strong><br><strong>没有中心服务器</strong><br>开放文件共享协议<br><strong>许多Gnutella客户端 实现了Gnutella协议</strong><br>类似HTTP有许多的 浏览器</p></blockquote><p><strong>覆盖网络：图</strong></p><p><strong>如果X和Y之间有一个 TCP连接，则二者之间存在一条边</strong><br><strong>所有活动的对等方和边就是覆盖网络</strong><br>边并不是物理链路<br>给定一个对等方，通常 所连接的节点少于10个</p><h4 id="泛洪查询-flooding"><a href="#泛洪查询-flooding" class="headerlink" title="泛洪查询 flooding"></a><strong>泛洪查询 flooding</strong></h4><p>我的客户端向所有邻居发出查询 所有邻居的客户端向其邻居发出查询 …<br>拥有资源的节点通过反向的方法将查询的结果发回来</p><p><strong>我的客户端就知道那个节点有资源——解决目录的问题——再向拥有资源的节点发出请求，得到资源</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/30/576rz3LuHo2bKvC.png" alt="image-20211130165050278"></p><p>Gnutella：对等方加入（网络的建立）</p><ol><li>对等方X必须首先发现某些已经在覆盖网络中的其他对 等方：使用可用对等方列表 <strong>自己维持一张对等方列表（经常开机的对等方的IP、死党列表）</strong> 联系维持列表的Gnutella站点</li><li>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</li><li>X向Y发送一个Ping报文，Y转发该Ping报文</li><li><strong>所有收到Ping报文的对等方以Pong报文响应 IP地址、共享文件的数量及总字节数</strong></li><li><strong>X收到许多Pong报文，然后它能建立其他TCP连接</strong></li></ol><h3 id="利用不匀称性：KaZaA（混合体）"><a href="#利用不匀称性：KaZaA（混合体）" class="headerlink" title="利用不匀称性：KaZaA（混合体）"></a><strong>利用不匀称性：KaZaA（混合体）</strong></h3><p><strong>每个对等方要么是一个组长，要么隶属于一个组长</strong></p><ul><li>对等方与其组长之间有 TCP连接</li><li>组长对之间有TCP连接</li></ul><p>组长跟踪其所有的孩子的内容</p><p>组长与其他组长联系</p><ul><li>转发查询到其他组长</li><li>获得其他组长的数据拷贝</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/30/w4qTFVKzb8MQjfs.png" alt="image-20211130165244625"></p><h4 id="KaZaA：查询"><a href="#KaZaA：查询" class="headerlink" title="KaZaA：查询"></a><strong>KaZaA：查询</strong></h4><blockquote><p><strong>每个文件有一个散列标识码（唯一Hash，上载时赋予）和一个描述符</strong><br>客户端向其组长发送关键字查询<br>组长用匹配（描述）进行响应：<br>    对每个匹配：元数据、散列标识码和IP地址<br>如果组长将查询转发给其他组长，其他组长也 以匹配进行响应<br>客户端选择要下载的文件<br>    <strong>向拥有文件的对等方发送一个带散列标识码的 HTTP请求</strong></p></blockquote><h4 id="Kazaa小技巧"><a href="#Kazaa小技巧" class="headerlink" title="Kazaa小技巧"></a><strong>Kazaa小技巧</strong></h4><p>请求排队</p><ul><li>限制并行上载的数量</li><li>确保每个被传输的文件从上载节点接收一定量的带宽</li></ul><p>激励优先权</p><ul><li>鼓励用户上载文件</li><li>加强系统的扩展性</li></ul><p>并行下载</p><ul><li>从多个对等方下载同一个文件的不同部分<ul><li>HTTP的字节范围首部</li><li>更快地检索一个文件</li></ul></li></ul><h4 id="Distributed-Hash-Table-DHT"><a href="#Distributed-Hash-Table-DHT" class="headerlink" title="Distributed Hash Table (DHT)"></a><strong>Distributed Hash Table (DHT)</strong></h4><p><strong>哈希表 、DHT 方案、 环形 DHT 以及覆盖网络 Peer 波动</strong></p><h3 id="（实际的例子）P2P文件分发：-BitTorrent"><a href="#（实际的例子）P2P文件分发：-BitTorrent" class="headerlink" title="（实际的例子）P2P文件分发： BitTorrent"></a><strong>（实际的例子）P2P文件分发： BitTorrent</strong></h3><p><strong>文件被分为一个个块 256KB 每个节点有一个bit map（hash），用map标记是否具备，有则标识为1否则为0</strong></p><p><strong>网络中的这些peers发送接收文件块，相互服务</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/30/Alm4QTZw1rpyNtB.png" alt="image-20211130165643404"></p><p>Peer 加入torrent:<br><strong>一开始没有块（吸血鬼），但是将会通 过其他节点处累积文件块</strong><br>向跟踪服务器注册，获得 peer节点列表，和部分peer 节点构成邻居关系 (“连接 ”)<br><strong>当peer下载时，该peer可以同时向其他节点提供上载服务</strong><br>Peer可能会变换用于交换块的peer节点<br><strong>扰动churn: peer节点可能会上线或者下线</strong><br><strong>一旦一个peer拥有整个文件（种子）</strong>，它会（自私的）离开或者保留（利他主义）在torrent中</p><h4 id="BitTorrent-请求，发送文件块"><a href="#BitTorrent-请求，发送文件块" class="headerlink" title="BitTorrent: 请求，发送文件块"></a><strong>BitTorrent: 请求，发送文件块</strong></h4><p>请求块：<br>在任何给定时间，不同 peer节点拥有一个文件块 的子集<br>周期性的，Alice节点向 邻居询问他们拥有哪些块 的信息<br><strong>Alice向peer节点请求它 希望的块，稀缺的块（稀缺优先，对集体有利）</strong></p><p><strong>1、（集体提出）客户端优先请求稀缺的（稀缺优先，对集体有利）</strong><br><strong>2、（集体定的规则）优先向提供服务好的客户端服务（个人利益与集体利益绑定）</strong><br><strong>3、（造成个人遵守）客户端优先请求稀缺的 （利他等于利己）</strong></p><p>发送块：一报还一报 titfor-tat<br><strong>Alice向4个peer发送块，这些块向它自己提供最大带宽的服务</strong><br>其他peer被Alice阻塞 (将不会 从Alice处获得服务)<br><strong>每10秒重新评估（谁对它好）一次：前4位</strong><br><strong>每个30秒：随机选择其他peer 节点，向这个节点发送块</strong><br>“优化疏通” 这个节点<br><strong>新选择的节点可以加入这个top 4</strong></p><p>(1) Alice “优化疏通” Bob<br>(2) Alice 变成了Bob的前4位提供者; Bob答谢Alice<br>(3) Bob 变成了Alice的前4提供者</p><p><strong>更高的上载速率： 发现更好的交易伙伴，获得更快的文件传输速率!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记1</title>
      <link href="2021/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>2021/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<p>注：课程来自<a href="https://www.bilibili.com/video/BV1JV411t7ow">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程</a></p><h1 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a><strong>计算机网络概念</strong></h1><h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a><strong>什么是Internet</strong></h2><h3 id="什么是-Internet-：从具体构成角度"><a href="#什么是-Internet-：从具体构成角度" class="headerlink" title="什么是 Internet ：从具体构成角度"></a><strong>什么是 Internet ：从具体构成角度</strong></h3><blockquote><ol><li><strong>零件的角度</strong></li></ol><ul><li>节点<ul><li>主机及其上运行的应用程序</li><li>路由器、交换机等网络交换设备</li></ul></li><li>边：通信链路<ul><li>接入网链路：主机连接到互联网的链路</li><li>主干链路：路由器间的链路</li></ul></li><li>协议</li></ul><ol start="2"><li><strong>网络互联设备的角度</strong></li></ol><ul><li>数以亿计的、互联的计 算设备:<ul><li>主机 = 端系统</li><li>运行网络应用程序</li></ul></li><li>通信链路<ul><li>光纤、同轴电缆、无线电 、卫星</li><li>传输速率 = 带宽（bps）</li></ul></li><li>分组交换设备：转发分 组 (packets)<ul><li>路由器和交换机</li></ul></li></ul></blockquote><blockquote><p>协议控制发送、接收消息：如 TCP、IP、HTTP、FTP、 PPP</p><p>Internet：“网络的网络”</p><ul><li>公共Internet vs. 专用 intranet</li><li>松散的层次结构，互连的 ISP</li></ul><p>Internet标准</p><ul><li>RFC: Request for comments</li><li>IETF: Internet Engineering Task Force</li></ul></blockquote><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a><strong>协议</strong></h4><p>定义了在两个或多个通信实体（对等层的实体）之间交换的报文格式和次序，<br>以及在报文传输和/或接收或 其他事件方面所采取的动作</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/20/pFCwxJE8W1OYe4Q.png" alt="image-20211120232826174"></p><h3 id="什么是Internet：从服务角度"><a href="#什么是Internet：从服务角度" class="headerlink" title="什么是Internet：从服务角度"></a><strong>什么是Internet：从服务角度</strong></h3><p>进行通信的分布式应用的角度</p><blockquote><ul><li>使用通信设施进行通信的分 布式应用</li><li>Web、VoIP、email、分布式 游戏、电子商务、社交网络 ……</li><li>通信基础设施为apps提供编 程接口（通信服务）</li><li>将发送和接收数据的apps与 互联网连接起来</li><li>为app应用提供服务选择，类 似于邮政服务：<ul><li>无连接不可靠服务</li><li>面向连接的可靠服务</li></ul></li></ul></blockquote><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a><strong>网络边缘</strong></h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a><strong>网络结构</strong></h3><blockquote><ul><li>网络边缘：<ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul></li><li>网络核心：<ul><li>互连着的路由器</li><li>网络的网络</li></ul></li><li>接入网、物理媒体：<ul><li>有线或者无线通信链路</li></ul></li></ul></blockquote><h3 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a><strong>网络边缘</strong></h3><blockquote><ul><li>端系统（主机）：<ul><li>运行应用程序</li><li>如 Web、email</li><li>在“网络的边缘”</li></ul></li><li>客户/服务器模式（C/S）<ul><li>客户端向服务器请求、接收服务</li><li>如 Web 浏览器/服务器；email 客户端/服务器</li></ul></li><li>对等（peer-peer ）模式<ul><li>很少（甚至没有）专门的服务器</li><li>如 Gnutella、KaZaA、Emule</li></ul></li></ul></blockquote><h4 id="采用网络设施的面向连接服务"><a href="#采用网络设施的面向连接服务" class="headerlink" title="采用网络设施的面向连接服务"></a><strong>采用网络设施的面向连接服务</strong></h4><p><strong>目标</strong>：在端系统之间传输数据，</p><ul><li><p>握手：在数据传输之前 做好准备</p><p>就如人类协议中的：你好、你好。两个通信主机之间为<strong>连接建立状态</strong></p></li><li><p>TCP – 传输控制协议（ Transmission Control Protocol ）</p><p>Internet上面向连接的服务</p></li></ul><p><strong>TCP 服务 [RFC 793]</strong></p><ul><li>可靠地、按顺序地传送数据 —— 确认和重传</li><li>流量控制 —— 发送方不会淹没接收方</li><li>拥塞控制 —— 当网络拥塞时，发送方降低 发送速率</li></ul><h4 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a><strong>采用基础设施的无连接服务</strong></h4><p><strong>目标</strong>：在端系统之间传输数据 —— 无连接服务</p><ul><li>UDP – 用户数据报协议 (User Datagram Protocol) [RFC 768]:<ul><li>无连接</li><li>不可靠数据传输</li><li>无流量控制</li><li>无拥塞控制</li></ul></li></ul><p>使用 TCP 的应用：HTTP (Web), FTP (文件传 送), Telnet (远程登录), SMTP (email)</p><p>使用 UDP的应用：流媒体、远程会议、 DNS、 Internet 电话</p><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a><strong>网络核心</strong></h2><p>网络核心：路由器的网状网络，主要是用于<strong>数据交换</strong></p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a><strong>电路交换</strong></h3><p>电路交换：为每个呼叫预留一条 专有电路：如电话网。端到端的资源被分配给从源端 到目标端的呼叫 “call”：</p><p>下图中，每段链路有 4 条线路，该呼叫采用了上面链路的第 2 各线路，右边链路的第 1 个线路（piece）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/DvTUq5jh3umQ29y.png" alt="image-20211121140700357"></p><p>这种连接资源不会同享但每个呼叫一旦建立起来就能够保证性能。但**如果呼叫没有数据发送，被分配 的资源就会被浪费 (no sharing)**，电路交换通常被传统电话网络采用。</p><blockquote><p>网络资源（如带宽）被 分成片 (把结点的通讯能力分解成小片) </p><ul><li>为呼叫分配片</li><li>如果某个呼叫没有数据， 则其资源片处于空闲状态 （不共享）</li><li>将带宽分成片<ul><li>频分(Frequency-division multiplexing) –&gt; (FDM)</li><li>时分(Time-division multiplexing) –&gt; (TDM)</li><li>波分(Wave-division multiplexing) –&gt; (WDM)</li></ul></li></ul></blockquote><h4 id="FDM-与-TDM"><a href="#FDM-与-TDM" class="headerlink" title="FDM 与 TDM"></a><strong>FDM 与 TDM</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/ho7NCwVKmqlaizT.png" alt="image-20211121142107226"></p><h4 id="计算举例"><a href="#计算举例" class="headerlink" title="计算举例"></a><strong>计算举例</strong></h4><p>在一个电路交换网络上，从主机A到主机B发送 一个640,000比特的文件需要多长时间？</p><p>条件：所有的链路速率为1.536 Mbps，每条链路使用时隙数为24的TDM，建立端-端的电路需500 ms。</p><blockquote><p>每条链路的速率（一个时间片）：1.536Mbps/24 = 64kbps </p><p>传输时间：640kb/64kps = 10s </p><p>共用时间：传输时间+建立链路时间= 10s + 500ms = 10.5s</p></blockquote><h4 id="电路交换不适合计算机之间的通信"><a href="#电路交换不适合计算机之间的通信" class="headerlink" title="电路交换不适合计算机之间的通信"></a><strong>电路交换不适合计算机之间的通信</strong></h4><ol><li><p>连接建立时间长</p></li><li><p>计算机之间的通信有突发性，如果使用线路交换，则<strong>浪费的片较多</strong></p><p>即使这个呼叫没有数据传递，<strong>其所占据的片也不能 够被别的呼叫使用</strong> (非共享)</p></li><li><p>可靠性不高</p></li></ol><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h3><p>以分组为单位存储-转发方式</p><ol><li>网络带宽资源不再分分为一个个片，传输时使用<strong>全部带宽</strong></li><li>主机之间传输的数据被分为一个个分组</li></ol><p><strong>资源共享</strong>，按需使用：</p><ul><li>存储-转发：分组每次移 动一跳（ hop ） <strong>相当于分段使用链路</strong><ul><li>在转发之前，节点必须收到 整个分组</li><li>延迟比线路交换要大</li><li>排队时间</li></ul></li></ul><h4 id="存储-转发"><a href="#存储-转发" class="headerlink" title="存储-转发"></a><strong>存储-转发</strong></h4><ul><li>被传输到下一个链路之前， 整个分组必须到达路由器：存储-转发</li><li>在一个速率为R bps的链路 ，一个长度为L bits 的分组 的存储转发延时： </li></ul><h4 id="排队延迟和丢失"><a href="#排队延迟和丢失" class="headerlink" title="排队延迟和丢失"></a><strong>排队延迟和丢失</strong></h4><p>如果到达速率 &gt; 链路的输出速率，分组将会排队，等待传输。如果路由器的缓存用完了，分组将会被抛弃</p><h4 id="网络核心的关键功能"><a href="#网络核心的关键功能" class="headerlink" title="网络核心的关键功能"></a><strong>网络核心的关键功能</strong></h4><p>路由: 决定分组采用的源到 目标的路径</p><p>转发: 将分组从路由器的输 入链路转移到输出链路</p><h4 id="统计多路复用"><a href="#统计多路复用" class="headerlink" title="统计多路复用"></a><strong>统计多路复用</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/FqidVzDlhkRuE6Z.png" alt="image-20211121143542988"></p><p>A&amp;B 时分复用 链路资源 A &amp; B </p><p>分组没有固定的模式 –&gt; 统计多路复用</p><h4 id="分组交换优缺点"><a href="#分组交换优缺点" class="headerlink" title="分组交换优缺点"></a><strong>分组交换优缺点</strong></h4><p>优点：共享性</p><p>缺点：排队延迟和可能丢失</p><p><strong>相当于多个电路交换，延迟更大（排队延迟，存储/转发延迟），而来换取了共享性</strong></p><h4 id="分组交换-vs-电路交换"><a href="#分组交换-vs-电路交换" class="headerlink" title="分组交换 vs 电路交换"></a><strong>分组交换 vs 电路交换</strong></h4><p>分组交换与电路交换相比，分组交换更适合计算机之间的通信：</p><ol><li>分组交换适合于对<strong>突发式数据传输</strong> </li><li>资源共享</li><li>简单，不必建立呼叫</li><li>在每个交换节点中不用维护主机之间的通信状态</li></ol><h4 id="分组交换按照有无网络层的连接分类"><a href="#分组交换按照有无网络层的连接分类" class="headerlink" title="分组交换按照有无网络层的连接分类"></a><strong>分组交换按照有无网络层的连接分类</strong></h4><p>分组交换——分组的存储转发一段一段从源端传到目标端</p><ul><li>数据报网络:<ul><li>分组的目标地址决定下一跳</li><li>在不同的阶段，路由可以改变</li><li>类似:问路</li><li>Internent</li></ul></li><li>虚电路网络:<ul><li>每个分组都带标签（虚电路标识VC ID），标签决定下一跳</li><li>在呼叫建立时决定路径，在整个呼叫中路径保持不变</li><li>路由器维持每个呼叫的状态信息</li><li>X.25和ATM</li></ul></li></ul><h4 id="数据报-datagram-的工作原理"><a href="#数据报-datagram-的工作原理" class="headerlink" title="数据报(datagram) 的工作原理"></a><strong>数据报(datagram) 的工作原理</strong></h4><ul><li>在通信之前,无须建立起一个连接,有数据就传输</li><li>每一个分组都独立路由(路径不一样,可能会失序)</li><li>路由器根据分组的目标地址进行路由(不维护主机和主机之间的状态)</li></ul><h4 id="虚电路-virtual-circuit-的工作原理"><a href="#虚电路-virtual-circuit-的工作原理" class="headerlink" title="虚电路(virtual circuit)的工作原理"></a><strong>虚电路(virtual circuit)的工作原理</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/JoswRZ97F3fucqx.png" alt="image-20211121144536578"></p><h4 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a><strong>网络分类</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/pa3MWUjglvQiIRC.png" alt="image-20211121145125717"></p><h2 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a><strong>接入网和物理媒体</strong></h2><p>把网络边缘接入网络核心。</p><p>Q: 怎样将端系统和边缘路由器连接？</p><ul><li>住宅接入网络</li><li>单位接入网络 （学校、公 司）</li><li>无线接入网络</li></ul><h3 id="住宅接入：modem"><a href="#住宅接入：modem" class="headerlink" title="住宅接入：modem"></a><strong>住宅接入：modem</strong></h3><ul><li>将上网数据调制加载音频信号上， 在电话线上传输，在局端将其中的 数据解调出来；反之亦然<ul><li>调频、调幅、调相位、综合调制</li></ul></li><li>拨号调制解调器<ul><li>56Kbps 的速率直接接入路由器 (通常更低)</li><li>不能同时上网和打电话：不能 总是在线</li></ul></li></ul><h4 id="电缆模式"><a href="#电缆模式" class="headerlink" title="电缆模式"></a><strong>电缆模式</strong></h4><p>fiber optic transport——光纤传输</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/FYL9R23JluZXecD.png" alt="image-20211121191451878"></p><h3 id="接入网-digital-subscriber-line-DSL"><a href="#接入网-digital-subscriber-line-DSL" class="headerlink" title="接入网: digital subscriber line (DSL)"></a><strong>接入网: digital subscriber line (DSL)</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/gtDPnwHTluxbBeS.png" alt="image-20211121191018438"></p><ul><li>采用现存的到交换局DSLAM的电话线<ul><li>DSL线路上的数据被传到互联网</li><li>DSL线路上的语音被传到电话网</li></ul></li><li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps)</li><li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps) </li></ul><h4 id="线缆网络"><a href="#线缆网络" class="headerlink" title="线缆网络"></a><strong>线缆网络</strong></h4><p>有线电视信号线缆双向改造 </p><p>FDM: 在不同频段传输不同信道的数据， 数字电视和上网数据（上下行）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/hDLu8ZCA4FHeGxV.png" alt="image-20211121191223232"></p><blockquote><ul><li>HFC: hybrid fiber coax<ul><li>非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输速率</li></ul></li><li>线缆和光纤网络将个家庭用户接入到 ISP 路由器</li><li>各用户共享到线缆头端的接入网络<ul><li> 与DSL不同, DSL每个用户一个专用线路到 CO（central office）</li></ul></li></ul></blockquote><h4 id="家庭网络"><a href="#家庭网络" class="headerlink" title="家庭网络"></a><strong>家庭网络</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/kA2D5BonaUhtISs.png" alt="image-20211121191543422"></p><h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a><strong>物理媒体</strong></h4><ul><li><p>Bit: 在发送-接收对间传播</p></li><li><p>物理链路：连接每个发送-接 收对之间的物理媒体</p></li><li><p><strong>导引型媒体:信号沿着固体媒介被导引</strong>：同轴电缆、光纤、 双绞线</p></li><li><p><strong>非导引型媒体:开放的空间传输电磁波或者光信号</strong>，在电磁或者光信号中承载数字数据</p></li><li><p>双绞线 (TP)</p></li></ul><h4 id="同轴电缆、光纤"><a href="#同轴电缆、光纤" class="headerlink" title="同轴电缆、光纤"></a><strong>同轴电缆、光纤</strong></h4><ul><li><p>同轴电缆：两根同轴的铜导线、双向、基带电缆：1. 电缆上一个单个信道 2. Ethernet、宽带电缆：1. 电缆上有多个信道 2. HFC</p></li><li><p>光纤和光缆：</p><p>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输</p><p>高速：点到点的高速传输（如10 Gps-100Gbps传输速率 ）</p><p>低误码率：在两个中继器之间可以有很长的距离，不受 电磁噪声的干扰</p><p>安全</p></li></ul><h3 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a><strong>无线链路</strong></h3><ul><li>开放空间传输电磁波，携带要传输的数据</li><li>无需物理“线缆”</li><li>双向</li><li>传播环境效应：反射、吸收、干扰</li></ul><h4 id="无线链路类型"><a href="#无线链路类型" class="headerlink" title="无线链路类型:"></a><strong>无线链路类型:</strong></h4><ul><li>地面微波（up to 45 Mbps channels）</li><li>LAN：WiFi（11Mbps, 54 Mbps,540Mbps…）</li><li>wide-area： 蜂窝网络（3G cellular：几Mbps、4G：10Mbps、5G：数Gbps）</li><li>卫星<ul><li>每个信道Kbps 到45Mbps (或者 多个聚集信道)</li><li>270 msec端到端延迟</li><li>同步静止卫星和低轨卫星</li></ul></li></ul><h3 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="** Internet结构和ISP**"></a>** Internet结构和ISP**</h3><p>按ISP划分互联网</p><h4 id="互联网结构：网络的网络"><a href="#互联网结构：网络的网络" class="headerlink" title="互联网结构：网络的网络"></a>互联网结构：网络的网络</h4><ul><li><p>端系统通过接入ISPs (Internet Service Providers)连接到互联网</p><ul><li>住宅，公司和大学的ISPs</li></ul></li><li><p>接入ISPs相应的必须是互联的</p><ul><li>因此任何2个端系统可相互发送分组到对方</li></ul></li><li><p>导致的“网络的网络”非常复杂</p><ul><li>发展和演化是通过<strong>经济的和国家的政策</strong>来驱动的</li></ul></li><li><p>让我们<strong>采用渐进方法</strong>来描述当前互联网的结构</p></li></ul><p>Q: 给定数百万接入ISPs，如何将它们互联到一起？</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/Lon4J67dvAuWDZ9.png" alt="image-20211121211543277"></p><p>选项: 将每个接入ISP都连接到全局ISP（全局范围内覆盖）？ 客户 ISPs 和提供者 ISPs 有经济合约</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/Nvdrxyth3gmOC2R.png" alt="image-20211121211606376"></p><p>竞争：但如果全局ISP是有利可为的业务，那会有竞争者<br>合作：通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系</p><p>Internet exchange point</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/UhbNOKfCYw7asRG.png" alt="image-20211121211859580"></p><p>然后业务会细分（全球接入和区域接入），区域网络将出现，用与将接入ISPs连接到全局ISPs<br>然后内容提供商网络 (Internet Content Providers,e.g., Google, Microsoft, Akamai) 可能会构建它们自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务,减少自己的运营支出<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/iR9zWNaYSq5Ihkt.png" alt="image-20211121211926263"></p><p>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、 但是之间有着多重连接）</p><ul><li><p>“tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), 国家或者国际 范围的覆盖</p></li><li><p>content provider network (e.g., Google): 将它们的数据中心接入ISP，方便周边 用户的访问；通常私有网络之间用专网绕过第一层 ISP 和区域</p></li></ul><h4 id="松散的层次模型"><a href="#松散的层次模型" class="headerlink" title="松散的层次模型"></a><strong>松散的层次模型</strong></h4><p>中心：第一层ISP（如UUNet, BBN/Genuity, Sprint, AT&amp;T）国家/国际覆盖，速率极高</p><ul><li>直接与其他第一层ISP相连</li><li>与大量的第二层ISP和其他客户网络相连</li></ul><p>第二层ISP: 更小些的 (通常是区域性的) ISP</p><ul><li>与一个或多个第一层ISPs，也可能与其他第二层ISP</li></ul><p>第三层ISP与其他本地ISP</p><ul><li>接入网 (与端系统最近)</li></ul><p>一个分组要经过许多网络！</p><p>很多内容提供商(如：Google, Akamai )可能会部署自己的网 络,连接自己的在各地的DC（数据中心），走自己的数据<br>连接若干local ISP和各级（包括一层）ISP,更加靠近用户</p><h3 id="ISP之间的连接"><a href="#ISP之间的连接" class="headerlink" title="ISP之间的连接"></a>ISP之间的连接</h3><ul><li>POP: 高层ISP面向客户网络的接入点，涉及费用结算<ul><li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li></ul></li><li>对等接入：2个ISP对等互接，不涉及费用结算</li><li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算（对等接入）</li><li>ICP自己部署专用网络，同时和各级ISP连接</li></ul><h2 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a><strong>分组延时、丢失和吞吐量</strong></h2><h3 id="分组延时的发生"><a href="#分组延时的发生" class="headerlink" title="分组延时的发生"></a>分组延时的发生</h3><p>在路由器缓冲区的分组队列中会发生：</p><ol><li>分组到达链路的速率超过了链路输出的能力</li><li>分组等待排到队头、被传输</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/7X3EiQdNuMwbIYq.png" alt="image-20211121212459423"></p><h3 id="四种分组延时"><a href="#四种分组延时" class="headerlink" title="四种分组延时"></a><strong>四种分组延时</strong></h3><blockquote><ol><li>节点处理延时：检查 bit级差错、检查分组首部和决定将分组导向何处</li><li>排队延时：在输出链路上等待传输的 时间、依赖于路由器的拥塞程度</li><li>传输延时：R=链路带宽(bps)、L=分组长度(bits)、将分组发送到链路上的 时间= L/R、存储转发延时</li><li>传播延时：d = 物理链路的长度、s = 在媒体上的传播速度 (~2x108 m/sec)、传播延时 = d/s</li></ol></blockquote><p>以车队作类比</p><blockquote><p>情况一</p><p>汽车以100 km/hr 的速度传播，收费站服务每辆车需 12s (传输时间)<br>汽车~ bit; 车队 ~ 分组<br>Q: 在车队在第二个收费站排 列好之前需要多长时间？即：从车队的第一辆车到达第 一个收费站开始计时，到这个车队的最后一辆车离开第二个 收费站，共需要多少时间</p><p>将车队从收费站输送到公路上的时间 = 12*10 = 120s<br>最后一辆车从第一个收费站到第二个收费站的传播 时间：100km/(100km/hr)= 1 hr<br>A: 62 minutes</p></blockquote><blockquote><p>情况二（局域网）</p><p>汽车以1000 km/hr 的速度传播汽车，收费站服务每辆车需 1分钟<br>Q:在所有的汽车被第一个收费站服务之前，汽车会 到达第二个收费站吗？</p><p>Yes！7分钟后，第一辆汽车 到达了第二个收费站，而第一个收费站仍有3辆汽车<br>在整个分组被第一个路由器 传输之前，第一个比特已经 到达了第二个路由器！</p></blockquote><h3 id="节点延时"><a href="#节点延时" class="headerlink" title="节点延时"></a><strong>节点延时</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/21/JCVUmlQghPb5IE3.png" alt="image-20211121213815675"></p><h3 id="排队延时"><a href="#排队延时" class="headerlink" title="排队延时"></a><strong>排队延时</strong></h3><p>R=链路带宽 (bps)，L=分组长度 (bits)， a=分组到达队列的平均速率。流量强度 = La/R</p><ul><li><strong>La/R ~ 0: 平均排队延时很小</strong></li><li><strong>La/R -&gt; 1: 延时变得很大，趋近无穷</strong></li><li><strong>La/R &gt; 1: 比特到达队列的速率超过了从该队 列输出的速率，平均排队延时将趋向无穷大！ 设计系统时流量强度不能大于1！</strong></li></ul><h3 id="Internet的延时和路由"><a href="#Internet的延时和路由" class="headerlink" title="Internet的延时和路由"></a><strong>Internet的延时和路由</strong></h3><p>Traceroute 诊断程序: 提供从源端，经过路由器，到目的的延时测量</p><ul><li>For all i：<ul><li>沿着目的的路径，向每个路由器发送3个探测分组</li><li>路由器 i 将向发送方返回一个分组</li><li>发送方对发送和回复之间间隔计时</li></ul></li></ul><p>windwos 下可以使用 <code>tracert 目标地址</code></p><h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a><strong>分组丢失</strong></h3><p>链路的队列缓冲区容量有限,当分组到达一个满的队列时，该分组将会丢失，丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><strong>吞吐量</strong></h3><p>吞吐量: 在源端和目标端之间传输的速率（数据量/单位时间）<br>瞬间吞吐量: 在一个时间点的速率<br>平均吞吐量: 在一个长时间内平均值</p><h2 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a><strong>协议层次和服务模型</strong></h2><h3 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a><strong>协议层次</strong></h3><p>网络功能繁杂：数字信号的物理信 号承载、点到点、路由、rdt、进 程区分、应用等</p><p>现实来看，网络的许多构成元素和 设备：主机、路由器、各种媒体的链路、应用、协议、硬件、软件</p><blockquote><p>层次化方式实现复杂网络功能</p><ul><li>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务</li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务</li><li>在实现本层协议的时候，直接利用了下层所提供的服务</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的+更下层所提供的服务</li></ul></blockquote><h3 id="服务和服务访问点"><a href="#服务和服务访问点" class="headerlink" title="服务和服务访问点"></a><strong>服务和服务访问点</strong></h3><ul><li>服务( Service)：低层实体向上层实体提供它们之间的通信的能力<ul><li>服务用户(service user)</li><li>服务提供者(service provider )</li></ul></li><li>原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的—形式</li><li>服务访问点 SAP (Services Access Point) ：<strong>用于下层的服务提供者，来区分不同上层用户的一些信息，穿过层阶的一些信息称为服务访问点</strong>（上层使用下层提供的服务通过层间的接口—地点）<ul><li>如：邮箱</li><li>地址(address)：下层的一个实体支撑着上层的多个实体， SAP有标志不同上层实体的作用</li><li>可以有不同的实现，队列</li><li>如：传输层的SAP: 端口(port)</li></ul></li></ul><h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a><strong>服务的类型</strong></h3><p>面向连接的服务和无连接的服务：</p><p>如果两个用户在通讯之前<strong>建立起“握手”的关系，分配好资源，为通讯做好准备</strong>，这种就称为面向连接的服务，反之则为无连接的服务</p><h4 id="面向连接的服务"><a href="#面向连接的服务" class="headerlink" title="面向连接的服务"></a><strong>面向连接的服务</strong></h4><blockquote><p>连接(Connection)：两个通信实体为进行通信而建立的一 种结合</p><p>面向连接的服务通信的过程：建立连接，通信，拆除连接</p><p>面向连接的服务的例子：网络层的连接被成为虚电路</p><p>适用范围：对于大的数据块要传输; 不适合小的零星报文</p><p>特点：保序</p><p>服务类型:</p><ul><li>可靠的信息流 传送页面(可靠的获得,通过接收方的确认)</li><li>可靠的字节流 远程登录</li><li>不可靠的连接 数字化声音</li></ul></blockquote><h4 id="无连接的服务"><a href="#无连接的服务" class="headerlink" title="无连接的服务"></a><strong>无连接的服务</strong></h4><blockquote><p>无连接服务：两个对等层实体在通信前不需要建 立一个连接，不预留资源；不需要通信双方都是 活跃；(例：寄信)</p><p>特点：不可靠、可能重复、可能失序</p><p>IP分组，数据包；</p><p>适用范围：适合传送零星数据；</p><p>服务类型：</p><ul><li>不可靠的数据报 电子方式的函件</li><li>有确认的数据报 挂号信</li><li>请求回答 信息查询</li></ul></blockquote><h3 id="协议和服务"><a href="#协议和服务" class="headerlink" title="协议和服务"></a><strong>协议和服务</strong></h3><h4 id="协议和服务的差别"><a href="#协议和服务的差别" class="headerlink" title="协议和服务的差别"></a><strong>协议和服务的差别</strong></h4><ul><li>服务(Service)：<strong>低层实体向上层实体</strong>提供它们之间的通信的能力，是通过原语(primitive)来操作的，<strong>垂直</strong>关系</li><li>协议(protocol) ：<strong>对等层实体(peer entity)<strong>之间在相互通信的过程中，需要遵循的规则的集合，</strong>水平</strong>关系</li></ul><h4 id="服务与协议的联系"><a href="#服务与协议的联系" class="headerlink" title="服务与协议的联系"></a><strong>服务与协议的联系</strong></h4><ul><li>本层<strong>协议的实现</strong>要靠下层提供的服务来实现</li><li>本层实体通过协议为上层<strong>提供更高级的服务</strong></li></ul><h3 id="数据单元-DU"><a href="#数据单元-DU" class="headerlink" title="数据单元(DU)"></a><strong>数据单元(DU)</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/22/MXrBvikIP1DxLw4.png" alt="image-20211122215841764"></p><p>ICI : 接口控制信息 - <em>Interface</em> <em>Control</em> <em>Information</em></p><h4 id="上层的PDU对于本层是SDU，封装后对于本层是PDU"><a href="#上层的PDU对于本层是SDU，封装后对于本层是PDU" class="headerlink" title="上层的PDU对于本层是SDU，封装后对于本层是PDU"></a><strong>上层的PDU对于本层是SDU，封装后对于本层是PDU</strong></h4><p>两者的封装关系：</p><ul><li>一对一：<strong>一个SDU 进行封装变成一个PDU（协议数据单元）</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/22/sChjJ2dBr8NyHc6.png" alt="一对一"></p><ul><li>一对多：<strong>一个较大的SDU分成多个再进行封装，成多个PDU</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/22/ej3opiB5wyt89Ds.png" alt="一对多"></p><ul><li>多对一：<strong>多个很小的 SDU封装成一个PDU</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/22/DnZTuJWgFjKvPt1.png" alt="多对一"></p><p>每一层的<strong>协议数据单元</strong>都有不同的称呼：</p><ul><li><p>应用层：<strong>应用报文(message)</strong></p></li><li><p>传输层：<strong>TCP段：报文段(segmet)<strong>或者简称为</strong>段</strong>，<strong>UDP：数据报</strong></p></li><li><p>网络层：<strong>分组(packet)<strong>，如果网络是无连接的又称为</strong>数据报(datagram)</strong></p></li><li><p>链路层：<strong>帧(frame)</strong></p></li><li><p>物理层：<strong>位(bit)</strong></p></li></ul><h3 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a><strong>Internet协议栈</strong></h3><ul><li><p>应用层：实现各种各样的网络应用<br>为人类用户或者其他应用进程提供网络应用服务<br>FTP,SMTP,HTTP,DNS</p></li><li><p>传输层:主机之间的数据传输（UTP、TCP）</p><ol><li><strong>在网络层提供的端到端通信基础上，细分为进程到进程</strong></li><li>将不可靠的通信变成可靠地通信</li></ol></li><li><p>网络层:为数据报从源到目的<strong>选择路由</strong>（转发、路由）<br><strong>主机主机之间的通信，端到端通信，不可靠</strong><br>IP,路由协议</p></li><li><p>链路层:相邻网络节点间的数据传输（相邻两点间，以帧位单位的传输）<br><strong>2个相邻2点的通信，点到点通信，可靠或不可靠</strong><br>点对对协议PPP,802.11(wifi),Ethernet</p></li><li><p>物理层：提供相邻两点之间电磁波的承载，能够将链路层传下来的 bit 交给对等的上层把它变为电磁波信号，光信号</p></li></ul><h3 id="ISO-OSI-参考模型"><a href="#ISO-OSI-参考模型" class="headerlink" title="ISO/OSI 参考模型"></a>ISO/OSI 参考模型</h3><ul><li>表示层: 允许应用解释传输的数据, e.g., 加密，压缩，机器相关的表示转换</li><li>会话层: 数据交换的同步，检查点，恢复</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/22/ZnlN74v9UspomQw.png" alt="image-20211122231655445"></p><h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a><strong>封装和解封装</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/22/S1jFOIHv5dsCkg2.png" alt="image-20211122231807219"></p><blockquote><p><strong>链路层交换机主要用于组建局域网，而路由器则主要负责连接外网并寻找网络中最合适数据传输的路径</strong></p><p>最后需要说明的是：路由器一般都具有防火墙功能，能够对一些网络数据包选择性的进行过滤。现在的一些路由器都具备交换机的功能，也有具备路由器功能的交换机，称为三层交换机。相比较而言，路由器的功能较交换机要强大，但是速度也相对较慢，价格较为昂贵，而三层交换机既有交换机的线性转发报文的能力，又有路由器的路由功能，因此得到了广泛的应用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程笔记4</title>
      <link href="2021/11/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/"/>
      <url>2021/11/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-临界区"><a href="#Windows-临界区" class="headerlink" title="Windows 临界区"></a><strong>Windows 临界区</strong></h2><p>windows 临界区与 <code>std::mutex</code> 类似，效果几乎可以等同于 <code>std::mutex</code></p><p>不过 Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。</p><p><code>std::mutex</code> 则不允许同一个线程重复加锁。</p><p>windows中的临界区同 <code>mutex</code> 一样，可以保护一个代码段。但 windows 的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。</p><h2 id="自动析构技术"><a href="#自动析构技术" class="headerlink" title="自动析构技术"></a><strong>自动析构技术</strong></h2><p>C++：<code>lock_guard</code> 防止忘了释放信号量，自动释放<br>windows：可以写个类自动释放临界区：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWinLock</span> &#123;</span>        </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CWinLock(CRITICAL_SECTION *pCritmp) : m_pCritical(pCritmp)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(m_pCritical);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CWinLock()</span><br><span class="line">    &#123;</span><br><span class="line">        LeaveCriticalSection(m_pCritical);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CRITICAL_SECTION *m_pCritical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述这种类 RAII 类（Resource Acquisition is initialization），即”资源获取及初始化“。容器，智能指针属于这种类。</p><h2 id="递归独占互斥量-std-recursive-mutex"><a href="#递归独占互斥量-std-recursive-mutex" class="headerlink" title="递归独占互斥量 std::recursive_mutex"></a><strong>递归独占互斥量 std::recursive_mutex</strong></h2><p><code>std::mutex</code> 独占式互斥量</p><p><code>std::recursive_mutex</code>：允许在同一个线程中同一个互斥量多次被 <code>lock()</code> ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比 <code>std::mutex</code> 低。</p><p>如果你真的用了 <code>recursive_mutex</code> 要考虑代码是否有优化空间，如果能调用一次 <code>lock()</code> 就不要调用多次。</p><h2 id="带超时的互斥量-std-timed-mutex-和-std-recursive-timed-mutex"><a href="#带超时的互斥量-std-timed-mutex-和-std-recursive-timed-mutex" class="headerlink" title="带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex"></a><strong>带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex</strong></h2><p>std::timed_mutex 与 std::mutex 类似，只是多了几个成员函数</p><ol><li><p><code>try_lock_for()</code>: 参数是一段时间，等待一段时间，如果我拿到了锁，或者等待超过时间没拿到锁，就继续流程，返回值为 <code>bool</code> 类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex my_mutex;</span><br><span class="line"><span class="keyword">if</span>(my_mutex.try_lock_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>)) <span class="comment">// 等待 100ms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在规定时间内返回 <code>true</code> 否则返回 <code>false</code></p></li><li><p><code>try_lock_until()</code>: 参数是一个未来的时间点，在这个现在这个时间到指定的未来时间内拿到锁，或者超过指定的时间没拿到锁就会继续流程，返回值为 <code>bool</code> 类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex my_mutex;</span><br><span class="line"><span class="keyword">if</span>(my_mutex.try_lock_until(chrono::steady_clock::now() + <span class="number">10</span>s))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的区别就是一个参数是时间段，一个参数是时间点</p></li></ol><p><code>std::recursive_timed_mutex</code>：是待超时的<strong>递归</strong>独占互斥量 与 <code>std::recursive_mutex</code> 类似</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程笔记3</title>
      <link href="2021/11/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/"/>
      <url>2021/11/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h2 id="std-future其他的成员函数wait-for"><a href="#std-future其他的成员函数wait-for" class="headerlink" title="std::future其他的成员函数wait_for()"></a><strong>std::future其他的成员函数wait_for()</strong></h2><p><code>wait_for()</code> 返回的是一个枚举类型 <code>std::future_status</code></p><p><code>std::future_status</code> 是枚举类型，表示异步任务的执行状态。类型的取值有</p><ol><li><code>std::future_status::timeout</code> : 表示线程还没执行完</li><li><code>std::future_status::ready</code> ：表示线程在规定时间内完成</li><li><code>std::future_status::deferred </code> : 表示 <code>std::async()</code> 使用了 <code>std::launch::deferred</code></li></ol><p><code>wait_for()</code> 用于卡住当前流程，等待 <code>std::async()</code> 的异步任务运行一段时间，然后返回其状态 <code>std::future_status</code>。如果 <code>std::async()</code> 的参数是 <code>std::launch::deferred</code>（延迟执行），则不会卡住主流程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(mythread);</span><br><span class="line"><span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));   <span class="comment">// 等待1秒去执行子线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(status == <span class="built_in">std</span>::future_status::timeout) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 超时，表示线程还没执行完</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time out!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="built_in">std</span>::future_status::ready)   <span class="comment">// 表示线程成功返回</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread successfully completed! return value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="built_in">std</span>::future_status::deferred)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 async 的第一个参数被设置为 std::lauch::deferred，则条件成立</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread is delayed&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我么也可以通过 <code>wait_for()</code> 来判断系统通过 <code>std::async(mythread)</code> 创建的异步任务是否创建了线程</p><p>如果进入 <code>else if(status == std::future_status::deferred)</code> 则表示系统资源紧张而直接在主线程中调用了线程入口函数 <code>mythread()</code></p><h2 id="std-shard-future类模板"><a href="#std-shard-future类模板" class="headerlink" title="std::shard_future类模板"></a><strong>std::shard_future类模板</strong></h2><p><code>std::future</code> 与 <code>std::shared_future</code> 不同</p><ol><li><p><code>std::future</code> 的 <code>get()</code> 成员函数是转移数据，也就是说采用了移动语义</p><p>我们可以使用 <code>result</code> 中的 <code>valid()</code> 函数来判断是否还有值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async([]&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line">result.get();</span><br><span class="line"><span class="keyword">bool</span> isget = result.valid();</span><br></pre></td></tr></table></figure><p><code>isget == false</code> 则说明 <code>result</code> 没有值</p></li><li><p><code>std::shared_future</code> 的 <code>get()</code> 成员函数是复制数据</p></li></ol><h2 id="std-atomic原子操作"><a href="#std-atomic原子操作" class="headerlink" title="std::atomic原子操作"></a><strong>std::atomic原子操作</strong></h2><h3 id="原子操作概念引出范例"><a href="#原子操作概念引出范例" class="headerlink" title="原子操作概念引出范例"></a>原子操作概念引出范例</h3><p>两个线程同时进行加法运算，导致最后结果不准确，因为线程的不断切换中会打断代码导致没运行完整<br>通过互斥量来进行加锁解锁才会让加法计算运行准确<br>原子操作可以理解为：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式<br>也就是说：是在多线程中 不会被打断的程序执行片段，原子操作，效率上比互斥量更胜一筹<br>互斥量的加锁一般是针对一个代码段（多行代码），二原子操作针对的一般都是一个变量，而不是一个代码段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;<span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g_i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;g_i = &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理来说 <code>g_i</code> 应该为 200000 ，但因为线程的切换导致不会加到 200000，且每次结果都不会相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/19/MIzc1ifugsWJl8H.png" alt="image-20211119220525072"></p><h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a><strong>std::atomic</strong></h3><p>std::atomic 是一个类模板，用于封装某个类型的值，有两种初始化方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">0</span>&#125;;<span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure><p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，<strong>不可能出现半完成状态</strong></p><p>一般atomic原子操作，针对<code>++，--，+=，-=，&amp;=，|=，^=</code>是支持的，其他操作不一定支持。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; atm &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这里只有读取 <code>atm</code> 是原子操作，但是整个这一行代码 <code>cout &lt;&lt; atm &lt;&lt; endl;</code> 并不是原子操作，导致最终显示在屏幕上的值是一个“<strong>曾经值</strong>”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> atm2 = atm; <span class="comment">//不可以</span></span><br></pre></td></tr></table></figure><p>这种拷贝初始化不可以，会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">atm2</span><span class="params">(atm.load())</span></span>;</span><br></pre></td></tr></table></figure><p><code>load()</code>：以原子方式读 <code>atomic</code> 对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atm2.store(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p><code>store()</code>：以原子方式写入内容</p><p>原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程笔记2</title>
      <link href="2021/11/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/"/>
      <url>2021/11/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h2 id="std-async-函数模板-与-std-future-类模板"><a href="#std-async-函数模板-与-std-future-类模板" class="headerlink" title="std::async 函数模板 与 std::future 类模板"></a><strong>std::async 函数模板 与 std::future 类模板</strong></h2><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async()****"></a>std::async()****</h3><p><code>std::async()</code> 是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个 <code>std::future</code> 对象，<code>std::future</code> 是一个类模板</p><ul><li><p>什么叫 “启动一个异步任务”</p><p>启动一个异步任务就是自动创建一个线程并开始执行对应的线程入口函数，它返回一个 <code>std::future</code> 对象</p><p>这个对象里面就含有线程入口函数所返回的结果（线程返回的结果）我们可以通过调用 <code>future</code> 对象的成员函数 <code>get()</code> 来获取结果</p></li><li><p>函数中可以额外的传递一个参数</p><p>该参数类型是 <code>std::lunnch</code> 类型（枚举）来达到一些目的</p><ol><li><p><code>std::launch::deferred</code> 表示线程入口函数调用被延迟到 <code>std::future</code> 的 <code>wait()</code> 或 <code>get()</code> 函数时调用才执行，延迟调用，<strong>并且没有创建新线程</strong>，是在<strong>主线程中调用线程入口函数</strong></p><p>如果 <code>wait()</code> 或 <code>get()</code> 没有被调用 则线程<strong>不会被执行</strong></p></li><li><p><code>std::launch::async</code> 在调用 <code>async()</code> 函数的时候就开始创建线程,不会等待 <code>get()</code> </p></li></ol></li></ul><h3 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::<strong>future</strong></h3><p><code>std::future</code> 提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：<code>future</code> 中保存着一个值，这个值是在将来的某个时刻能够拿到。</p><p><code>std::future</code> 对象的 <code>get()</code> 成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像 <code>join()</code>。但是，它是可以获取结果的。</p><p><code>std::future</code> 对象的 <code>wait()</code> 成员函数，用于等待线程返回，本身并不返回结果，这个效果和 <code>std::thread</code> 的 <code>join()</code> 更像。</p><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a><strong>具体实例</strong></h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a><strong>类定义</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dr</span><span class="params">(<span class="number">5000</span>)</span></span>; <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(dr);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><strong>main函数</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">    <span class="keyword">int</span> tmpper = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main() threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(&amp;A::mythread, &amp;a, tmpper);   <span class="comment">// 第二个参数是对象引用才能保证线程里用的是同一个对象</span></span><br><span class="line"><span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::deferred, &amp;A::mythread, &amp;a, tmpper);</span></span><br><span class="line">    <span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::async, &amp;A::mythread, &amp;a, tmpper);    </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;return value = &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main() End!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用 <code>std::launch::async</code> </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/17/ZetKAFvsJl3O8BC.png" alt="image-20211117190358167"></p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/17/uzofJ91tl5maQsP.png" alt="image-20211117190444180"></p><p>​        <code>async()</code><strong>强制</strong>创建了一个新的线程</p><ol start="2"><li><p>使用 <code>std::launch::deferred</code> </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/17/ufvaI45oZEer1wp.png" alt="image-20211117190712373"></p><p>则是在主线程中<strong>调用了</strong>这个函数，并没有创建新的线程</p></li><li><p>使用 <code>std::launch::deferred | std::launch::async</code></p><p>这里这个 <code>|</code> ： 这意味着 <code>std::async</code> 的行为可能是 <strong>创建新线程并立即执行</strong> 或者 <strong>创建新线程并且延迟调用</strong></p><p>系统<strong>自动决定</strong>异步还是同步方式运行</p></li><li><p>不带额外参数</p><p>与 3. 中<strong>效果完全一致</strong></p></li></ol><h3 id="std-async和std-thread-区别"><a href="#std-async和std-thread-区别" class="headerlink" title="std::async和std::thread()区别"></a><strong>std::async和std::thread()区别</strong></h3><p><code>std::thread()</code> 如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）<br><code>std::async()</code> 创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</p><p>由于系统资源限制：</p><ol><li>如果用 <code>std::thread</code> 创建线程太多，则可能创建失败，系统报告异常崩溃</li><li>如果用 <code>std::async</code> 一般就不会报异常不会崩溃，因为，如果系统资源紧张导致无法创建新线程的时候，<code>std::async</code> 这种不加额外参数的调用就不会创建新线程。而是后续调用了<code>.get()</code> 来请求结果，那么这个异步任务就运行在执行这条 <code>get()</code> 语句所在的线程上</li></ol><h2 id="std-packaged-task-类模板"><a href="#std-packaged-task-类模板" class="headerlink" title="std::packaged_task 类模板"></a><strong>std::packaged_task 类模板</strong></h2><p><code>std::packaged_task</code>: 打包任务，把任务包装起来，可用于包装各种<strong>可调用对象</strong>的模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dr</span><span class="params">(<span class="number">5000</span>)</span></span>; <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(dr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; mypt(mythread);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt), <span class="number">1</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::future</code> 对象里包含有线程入口函数的返回结果，<code>result</code> 保存 <code>mythread</code> 的返回值.</p><p>我们也可以吧函数换成 lambda 表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">([](<span class="keyword">int</span> mypar) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::chrono::milliseconds dr(<span class="number">5000</span>); <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(dr);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::packaged_task</code>也是可调用对象</p><p>lambda 表达式的直接调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">([](<span class="keyword">int</span> mypar) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::chrono::milliseconds dr(<span class="number">5000</span>); <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(dr);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">mypt(<span class="number">150</span>);<span class="comment">// 直接调用，并没有创建线程</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="使用容器保存任务"><a href="#使用容器保存任务" class="headerlink" title="使用容器保存任务"></a>使用容器保存任务</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; my_tasks;</span><br><span class="line">my_tasks.emplace_back(<span class="built_in">std</span>::move(mypt)); <span class="comment">// 使用移动语义，加入进去后 mypt 就空了</span></span><br><span class="line"><span class="comment">// 从容器中取出 packaged_task</span></span><br><span class="line"><span class="keyword">auto</span> iter = my_tasks.begin();</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt2 = <span class="built_in">std</span>::move(*iter);  <span class="comment">// move 后 容器中还有一项，并没有被删除</span></span><br><span class="line">my_tasks.erase(iter);   <span class="comment">// 删除第一个元素，迭代器已经失效，所以后续代码不能再使用 iter</span></span><br><span class="line">mypt2(<span class="number">150</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt2.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="std-promise-类模板"><a href="#std-promise-类模板" class="headerlink" title="std::promise 类模板"></a><strong>std::promise 类模板</strong></h2><p>通过 <code>promise</code> 保存一个值，在将来某个时刻我们通过把一个 <code>future</code> 绑定到 <code>promise</code> 上来得到这个绑定的值</p><p>可以通过 <code>promise</code> 来实现两个线程中的数据传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; myprom;   <span class="comment">// 声明一个 std::promise 对象，保存值为int</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread, <span class="built_in">std</span>::ref(myprom), <span class="number">180</span>)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; ful = myprom.get_future();<span class="comment">// promise 和 future 绑定，用于获取线程返回值</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(mythread2, <span class="built_in">std</span>::ref(ful))</span></span>;<span class="comment">// 两个线程中数据传递</span></span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程笔记</title>
      <link href="2021/11/16/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>2021/11/16/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="条件变量-std-condition-variable-以及成员函数"><a href="#条件变量-std-condition-variable-以及成员函数" class="headerlink" title="条件变量 std::condition_variable 以及成员函数"></a><strong>条件变量 std::condition_variable 以及成员函数</strong></h2><h3 id="条件变量condition-variable"><a href="#条件变量condition-variable" class="headerlink" title="条件变量condition_variable"></a><strong>条件变量condition_variable</strong></h3><p>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable my_cond;</span><br></pre></td></tr></table></figure><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a><strong>wait()</strong></h3><p><code>wait()</code>第一个参数为<code>std::unique_lock&lt;std::mutex&gt;</code>，第二个参数为可选参数【<strong>可调用对象</strong>如 lambda 表达式 或者 函数】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 收集玩家命令线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;inMsgRecvQueue() insert &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sb</span><span class="params">(my_mutex1)</span></span>;</span><br><span class="line">            </span><br><span class="line">            msgRecvQueue.emplace_back(i);</span><br><span class="line">            my_cond.notify_all();   <span class="comment">// 尝试把 outMsgRecvQueue() 中的 wait() 唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出命令线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> command = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sb</span><span class="params">(my_mutex1)</span></span>;</span><br><span class="line">            my_cond.wait(sb,[<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span>(!msgRecvQueue.empty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 一旦走到这 队列中一定会有数据</span></span><br><span class="line">            command = msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            sb.unlock(); <span class="comment">// 提前 unlock ，以免影响效率</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread ID = &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; outMsgRecvQueue Start And Get Value! = &quot;</span> &lt;&lt; command &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">// end while</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用于收集玩家发送过来的命令</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">    <span class="built_in">std</span>::mutex my_mutex1;   <span class="comment">// 创建一个互斥量</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable my_cond;    <span class="comment">// 生成一个条件变量对象    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>如果有第二个参数</p><ul><li><p>如果第二个参数返回值为 <code>false</code> 那么 <code>wait()</code> 将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用 <code>notify_one()</code> 或者 <code>notify_all()</code> 成员函数为止</p></li><li><p>如果第二个参数返回值为 <code>true</code> 那么 <code>wait()</code> 将重新解锁上互斥量，并继续执行之后的代码</p></li></ul></li><li><p>如果没有第二个参数</p><ul><li>就与第二个参数为 <code>false</code> 效果相同，将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用 <code>notify_one()</code> 或者 <code>notify_all()</code> 成员函数为止</li></ul></li></ol><p>当唤醒其他线程中的 <code>wait()</code> 后</p><ol><li><code>wait()</code> 不断尝试重新获取互斥量的锁，如果获取不到 就会一直反复获取锁，如果获取到就继续执行 2.</li><li><ul><li>如果 <code>wait()</code> 有第二个参数（当前为 lambda 表达式）且返回值为 <code>false</code> 那 <code>wait()</code> 又对<strong>互斥量解锁</strong>并堵塞到这，等待再次被唤醒</li><li>如果 <code>wait()</code> 有第二个参数（当前为 lambda 表达式）且返回值为 <code>true</code> 则 <code>wait()</code> 返回，<strong>将互斥量再次上锁</strong> 流程继续（此时互斥量已经被锁住）</li><li>如果 没有第二个参数 <code>wait()</code> <strong>将互斥量再次上锁</strong> 直接返回，流程继续</li></ul></li></ol><h3 id="notify-one-与-notify-all"><a href="#notify-one-与-notify-all" class="headerlink" title="notify_one() 与 notify_all()"></a><strong>notify_one()</strong> 与 <strong>notify_all()</strong></h3><ul><li><code>notify_one()</code>唤醒一个线程中的 <code>wait()</code></li><li><code>notify_all()</code> 唤醒所有线程中的 <code>wait()</code></li></ul><h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a><strong>虚假唤醒</strong></h3><p><code>notify_one()</code> 或者 <code>notify_all()</code> 唤醒 <code>wait()</code> 后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在 <code>wait()</code> 中再次进行判断解决虚假唤醒。<br>解决：<code>wait</code> 中要有第二个参数（lambda），并且这个 <code>lambda</code> 中要正确判断所处理的公共数据是否存在。</p><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a><strong>深入思考</strong></h2><p>上面的代码可能导致出现一种情况：<br>因为<code>outMsgRecvQueue()</code>与<code>inMsgRecvQueue()</code>并不是一对一执行的，所以当程序循环执行很多次以后，可能在<code>msgRecvQueue</code> 中已经有了很多消息，但是，<code>outMsgRecvQueue</code>还是被唤醒一次只处理一条数据。这时可以考虑把<code>outMsgRecvQueue</code>多执行几次，或者对<code>inMsgRecvQueue</code>进行限流。</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinAPI文档</title>
      <link href="2021/10/26/WinAPI%E6%96%87%E6%A1%A3/"/>
      <url>2021/10/26/WinAPI%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>注：转载自<a href="https://fishc.com.cn/forum-207-1.html">小甲鱼-鱼c论坛</a> ，归纳一下方便自己学习//SetScrollRange</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="BeginPaint"><a href="#BeginPaint" class="headerlink" title="BeginPaint"></a>BeginPaint</h2><h3 id="函数功能："><a href="#函数功能：" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>BeginPaint 函数为指定窗口进行绘画作准备，并用将和绘画有关的信息填充到一个 <a href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>中。</p><h3 id="API-函数原型："><a href="#API-函数原型：" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">BeginPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HWND hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPPAINTSTRUCT lpPaint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hwnd</td><td>需要重新绘制的窗口句柄</td></tr><tr><td>lpPaint</td><td>指向 <a href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>的指针，用于存放绘画相关的信息</td></tr></tbody></table><h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功，返回值是指定窗口的“显示设备描述表”句柄；</p></li><li><p>如果函数失败，返回值是 NULL，表明没有得到显示设备的内容。</p></li></ol><h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>BeginPaint 函数自动设置显示设备内容的剪切区域，而排除任何更新区域外的区域。该更新区域可以通过 InvalidateRect 或 InvalidateRgn 函数设置，也可以是系统在改变大小、移动、创建、滚动后设置的，或者其他的影响客户区的操作来设置的。</p></li><li><p>如果更新区域被标记为可擦除的，BeginPaint 发送一个 WM_ERASEBKGND 消息给窗口。</p></li><li><p>一个应用程序除了响应 WM_PAINT 消息外，不应该调用 BeginPaint。</p></li><li><p>每次调用 BeginPaint 都应该有相应的 EndPaint 函数。</p></li><li><p>如果被绘画的客户区中有一个 caret（caret：插入符。是窗口客户区中的一个闪烁的线，块，或位图。插入符通常表示文本或图形将被插入的地方。即一闪一闪的光标），BeginPaint 自动隐藏该符号，而保证它不被擦除。</p></li><li><p>如果窗口类有一个背景刷，BeginPaint 使用这个刷子来擦除更新区域的背景。</p></li></ol><h2 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h2><h3 id="函数功能：-1"><a href="#函数功能：-1" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>CreateWindow 函数创建一个重叠式窗口、弹出式窗口或子窗口。它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。函数也指该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。</p><p>若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数。</p><h3 id="API-函数原型：-1"><a href="#API-函数原型：-1" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code>说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND WINAPI <span class="title">CreateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpClassName,    <span class="comment">// 窗口类名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpWindowName,   <span class="comment">// 窗口标题</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD dwStyle,          <span class="comment">// 窗口风格，或称窗口格式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> x,                  <span class="comment">// 初始 x 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> y,                  <span class="comment">// 初始 y 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> nWidth,             <span class="comment">// 初始 x 方向尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> nHeight,            <span class="comment">// 初始 y 方向尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWndParent,        <span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HMENU hMenu,            <span class="comment">// 窗口菜单句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HINSTANCE hInstance,    <span class="comment">// 程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPVOID lpParam          <span class="comment">// 创建参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-1"><a href="#参数解析：-1" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpClassName</td><td>1. 窗口类名称，可以是一个指向 NULL 结束的字符串或一个整型数值 2. 如果是字符串，它指定了窗口的类名。这个类名可以是任何用函数 RegisterClass 注册的类名，或是任何预定义的控制类名 3. 如是一个整型量，它是由此前调用 theGlobalAddAtom 函数产生的全局量。这个小于 0xC000 的 16 位数必须是 lpClassName 参数字的低 16 位，该参数的高位必须是 0</td></tr><tr><td>lpWindowName</td><td>1. 窗口标题，一个指向 NULL 结束的字符串指针 2. 如果窗口风格指定了标题条，由 lpWindowName 指向的窗口标题将显示在标题条上 3. 当使用 Createwindow 函数来创建控制例如按钮，选择框和静态控制时，可使用 lpWindowName 来指定控制文本</td></tr><tr><td>dwStyle</td><td>指定创建窗口的风格（详见下方↓）</td></tr><tr><td>x</td><td>1. 指定窗口的初始水平位置（x 坐标） 2. 对一个层叠或弹出式窗口，x 参数是屏幕坐标系的窗口的左上角的初始 x 坐标 3. 对于子窗口，x 是子窗口左上角相对父窗口客户区左上角的初始 x 坐标 4. 如果该参数被设为 CW_USEDEFAULT 则系统为窗口选择缺省的左上角坐标并忽略 y 参数，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口或子窗口设定，则 x 和 y 参数被设为零。</td></tr><tr><td>y</td><td>1. 指定窗口的初始垂直位置（y 坐标） 2. 对一个层叠或弹出式窗口，y 参数是屏幕坐标系的窗口的左上角的初始 y 坐标 3. 对于子窗口，y 是子窗口左上角相对父窗口客户区左上角的初始 y 坐标 4. 对于列表框，y 是列表框客户区左上角相对父窗口客户区左上角的初始 y 坐标 5. 如果层叠窗口是使用 WS_VISIBLE 风格位创建的并且 x 参数被设为 CW_USEDEFAULT，则系统将忽略 y 参数</td></tr><tr><td>nWidth</td><td>1. 以设备单元指明窗口的宽度 2. 对于层叠窗口，nWidth 的值或是屏幕坐标的窗口宽度或是 CW_USEDEFAULT 3. 若 nWidth 是 CW_USEDEFAULT，则系统为窗口选择一个默认的高度和宽度（默认宽度为从初始 x 坐标开始到屏幕的右边界，缺省高度为从初始 y 坐标开始到目标区域的顶部。)，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口和子窗口设定 CW_USEDEFAULT 标志则 nWidth 和 nHeight 被设为零</td></tr><tr><td>nHeight</td><td>1. 以设备单元指明窗口的高度 2. 对于层叠窗口，nHeight 是屏幕坐标的窗口宽度 3. 若 nWidth 被设为 CW_USEDEFAULT，则系统忽略 nHeight 参数，自动为 nWidth 和 nHeight 设置默认参数</td></tr><tr><td>hWndParent</td><td>1. 指向被创建窗口的父窗口或所有者窗口的句柄 2. 若要创建一个子窗口或一个从属窗口，需提供一个有效的窗口句柄 3. 创建一个单纯的消息窗口，可以提供 HWND_MESSAGE 或提供一个己存在的消息窗口的句柄</td></tr><tr><td>hMenu</td><td>1. 指向窗口菜单句柄，或依据窗口风格指明一个子窗口标识 2. 对于层叠或弹出式窗口，hMenu 指定窗口使用的菜单：如果使用了菜单类，则 hMenu 可以为 NULL 3. 对于子窗口，hMenu 指定了该子窗口标识（一个整型量），一个对话框使用这个整型值将事件通知父类。应用程序确定子窗口标识，这个值对于相同父窗口的所有子窗口必须是唯一的</td></tr><tr><td>hInstance</td><td>与窗口相关联的模块实例的句柄</td></tr><tr><td>lpParam</td><td>1. 指向一个值的指针，该值传递给窗口 WM_CREATE 消息。该值通过在 IParam 参数中的 CREATESTRUCT 结构传递 2. 如果应用程序调用 CreateWindow 创建一个 MDI 客户窗口，则 lpParam 必须指向一个 CLIENTCREATESTRUCT 结构</td></tr></tbody></table><h3 id="dwStyle-窗口风格解析"><a href="#dwStyle-窗口风格解析" class="headerlink" title="dwStyle 窗口风格解析"></a><strong>dwStyle 窗口风格解析</strong></h3><table><thead><tr><th><strong>窗口风格</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>WS_BORDER</td><td>创建一个带边框的窗口</td></tr><tr><td>WS_CAPTION</td><td>创建一个有标题框的窗口（包含了 WS_BODER 风格）</td></tr><tr><td>WS_CHILD</td><td>创建一个子窗口，这个风格的窗口不能拥有菜单也不能与 WS_POPUP 风格合用</td></tr><tr><td>WS_CHILDWINDOW</td><td>与 WS_CHILD 相同</td></tr><tr><td>WS_CLIPCHILDREN</td><td>当在父窗口内绘图时，排除子窗口区域，在创建父窗口时使用这个风格</td></tr><tr><td>WS_CLIPSIBLINGS</td><td>1. 排除子窗口之间的相对区域，也就是，当一个特定的窗口接收到 WM_PAINT 消息时，WS_CLIPSIBLINGS 风格将所有层叠窗口排除在绘图之外，只重绘指定的子窗口 2. 如果未指定该风格，并且子窗口是层叠的，则在重绘子窗口的客户区时，就会重绘邻近的子窗口</td></tr><tr><td>WS_DISABLED</td><td>1. 创建一个初始状态为禁止的子窗口，一个禁止状态的窗口不能接受来自用户的输入信息 2. 在窗口创建之后，可以调用 EnableWindow 函数来启用该窗口</td></tr><tr><td>WS_DLGFRAME</td><td>创建一个带对话框边框风格的窗口，这种风格的窗口不能带标题条</td></tr><tr><td>WS_GROUP</td><td>1. 指定一组“控制窗口”的第一个“控制窗口” 2. 这个“控制窗口”组由第一个“控制窗口”和随后定义的“控制窗口”组成，自第二个“控制窗口”开始每个“控制窗口”具有 WS_GROUP 风格 3. 每个组的第一个“控制窗口”带有 WS_TABSTOP 风格，从而使用户可以在组间移动 4. 用户随后可以使用光标在组内的控制间改变键盘焦点</td></tr><tr><td>WS_HSCROLL</td><td>创建一个有水平滚动条的窗口</td></tr><tr><td>WS_ICONIC</td><td>创建一个初始状态为最小化状态的窗口，与 WS_MINIMIZE 风格相同</td></tr><tr><td>WS_MAXIMIZE</td><td>创建一个初始状态为最大化状态的窗口</td></tr><tr><td>WS_MAXIMIZEBOX</td><td>创建一个具有最大化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_MINIMIZE</td><td>创建一个初始状态为最小化状态的窗口，与 WS_ICONIC 风格相同</td></tr><tr><td>WS_MINIMIZEBOX</td><td>创建一个具有最小化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_OVERLAPPED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题条和一个边框，与 WS_TILED 风格相同</td></tr><tr><td>WS_OVERLAPPEDWINDOW</td><td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_TILEDWINDOW 风格相同</td></tr><tr><td>WS_POPUP</td><td>创建一个弹出式窗口，该风格不能与 WS_CHILD 风格同时使用。</td></tr><tr><td>WS_POPUPWINDOW</td><td>相当于（WS_POPUP | WS_BORDER | WS_SYSMENU），但 WS_CAPTION 和 WS_POPUPWINDOW 必须同时设定才能使窗口某单可见</td></tr><tr><td>WS_SIZEBOX</td><td>创建一个可调边框的窗口，与 WS_THICKFRAME 风格相同</td></tr><tr><td>WS_SYSMENU</td><td>创建一个在标题条上带有窗口菜单的窗口，必须同时设定 WS_CAPTION 风格</td></tr><tr><td>WS_TABSTOP</td><td>1. 创建一个“控制窗口”，在用户按下 Tab 键时可以获得键盘焦点。 2. 按下 Tab 键后使键盘焦点转移到下一具有 WS_TABSTOP 风格的“控制窗口”</td></tr><tr><td>WS_THICKFRAME</td><td>创建一个具有可调边框的窗口，与 WS_SIZEBOX 风格相同</td></tr><tr><td>WS_TILED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题和一个边框，与 WS_OVERLAPPED 风格相同</td></tr><tr><td>WS_TILEDWINDOW</td><td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_OVERLAPPEDWINDOW 风格相同</td></tr><tr><td>WS_VISIBLE</td><td>创建一个初始状态为可见的窗口</td></tr><tr><td>WS_VSCROLL</td><td>创建一个有垂直滚动条的窗口</td></tr></tbody></table><h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功，返回值为新窗口的句柄；</p></li><li><p>如果函数失败，返回值为 NULL。</p></li></ol><h2 id="DefWindowProc"><a href="#DefWindowProc" class="headerlink" title="DefWindowProc"></a>DefWindowProc</h2><h3 id="函数功能：-2"><a href="#函数功能：-2" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>DefWindowProc 函数调用默认的窗口过程来处理我们不感兴趣的任何消息，该函数是为了确保每个消息都被处理。</p><p>DefWindowProc 函数传入和窗口过程同样的参数。</p><h3 id="API-函数原型：-2"><a href="#API-函数原型：-2" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">DefWindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  UINT Msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-2"><a href="#参数解析：-2" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定接收消息的窗口句柄</td></tr><tr><td>Msg</td><td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式 2. 应用程序消息只能使用低 16 位，高 16 位被系统保留 3. 传送门：<a href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td></tr><tr><td>wParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>lParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr></tbody></table><h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>返回值就是消息处理结果，它取决于发送的消息。</p><h2 id="DestroyWindow"><a href="#DestroyWindow" class="headerlink" title="DestroyWindow"></a>DestroyWindow</h2><h3 id="函数功能：-3"><a href="#函数功能：-3" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><ol><li><p>DestroyWindow 用于销毁一个指定的窗口，该函数通过发送 WM_DESTROY 消息和 WM_NCDESTROY 消息使窗口无效并移除其键盘焦点。</p></li><li><p>DestroyWindow 函数还销毁窗口的菜单，清空线程的消息队列，销毁与窗口过程相关的定时器，解除窗口对剪贴板的拥有权，打断剪贴板器的查看链。</p></li><li><p>如果指定的窗口拥有子窗口或拥有其它窗口，该函数将自动先销毁其子窗口或所拥有的窗口，然后再销毁自身。</p></li></ol><h3 id="API-函数原型：-3"><a href="#API-函数原型：-3" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DestroyWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-3"><a href="#参数解析：-3" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定将被销毁的窗口句柄</td></tr></tbody></table><h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功执行，返回值为非 0；</p></li><li><p>如果函数执行失败，返回值为 0。</p></li></ol><h3 id="备注：-1"><a href="#备注：-1" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>一个线程不能使用本函数销毁别的线程创建的窗口。</p></li><li><p>如果这个窗口是一个不具有 WS_EX_NOPARENTNOTIFY 样式的子窗口，则销毁窗口时将发 WM_PARENTNOTIFY 消息给其父窗口。</p></li></ol><h2 id="DispatchMessage"><a href="#DispatchMessage" class="headerlink" title="DispatchMessage"></a>DispatchMessage</h2><h3 id="函数功能：-4"><a href="#函数功能：-4" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>DispatchMessage 函数分派一个消息给窗口过程（回调函数），通常该消息从 GetMessage 函数获得。Windows 的控制权在该函数交给了应用程序。</p><h3 id="API-函数原型：-4"><a href="#API-函数原型：-4" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> MSG *lpmsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-4"><a href="#参数解析：-4" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpmsg</td><td>指向含有消息的 MSG结构 的指针</td></tr></tbody></table><h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>返回值是窗口过程返回的值；</p></li><li><p>尽管返回值的含义依赖于被分派的消息，但返回值通常被忽略。</p></li></ol><h3 id="备注：-2"><a href="#备注：-2" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>MSG 结构必须包含有效的消息值。</p></li><li><p>如果参数 lpmsg 指向一个 WM_TIMER 消息，并且 WM_TIMER 消息的参数 lParam 不为 NULL，则调用 lParam 指向的函数，而不是调用窗口程序。</p></li></ol><h2 id="DrawText"><a href="#DrawText" class="headerlink" title="DrawText"></a>DrawText</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>DrawText 函数在指定的矩形里写入格式化的正文，根据指定的方法对正文格式化（扩展的制表符，字符对齐、折行等）。</p><p>需要指定更多的格式选项，可以使用 DrawTextEx 函数。</p><h3 id="API-函数原型：-5"><a href="#API-函数原型：-5" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HDC hDC,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPCTSTR lpchText,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">int</span> nCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPRECT lpRect,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     UINT uFormat</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-5"><a href="#参数解析：-5" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hDC</td><td>指定“显示设备描述表”句柄</td></tr><tr><td>lpchText</td><td>1. 指向将被写入的字符串的指针，如果参数 nCount 是 -1，则字符串必须是以 \0 结束的 2. 如果 uFormat 包含 DT_MODIFYSTRING，则函数可为此字符串增加 4 个字符，存放字符串的缓冲区必须足够大，能容纳附加的字符</td></tr><tr><td>nCount</td><td>1. 指向字符串中的字符数 2. 如果 nCount 为 -1，则 lpchText 指向的字符串被认为是以 \0 结束的，DrawText 会自动计算字符数</td></tr><tr><td>lpRect</td><td>指向 <a href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>的指针，其中包含文本将被置于其中的矩形的信息（按逻辑坐标）</td></tr><tr><td>uFormat</td><td>1. 指定格式化文本的方法 2. 此参数可以通过指定下列标志或标志的组合</td></tr></tbody></table><h3 id="uFormat-参数各种标志解析"><a href="#uFormat-参数各种标志解析" class="headerlink" title="uFormat 参数各种标志解析"></a><strong>uFormat 参数各种标志解析</strong></h3><table><thead><tr><th><strong>标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>DT_BOTTOM</td><td>对齐文字到矩形的底部，当且仅当设置了 DT_SINGLELINE 标志才有效</td></tr><tr><td>DT_CALCRECT</td><td>1. 这个参数决定矩形的宽度和高度 2. 如果输出文本有多行，DrawText 函数使用 lpRect 定义的矩形的宽度，并扩展矩形的底部以容纳输出文本的最后一行 3. 如果输出文本只有一行，则 DrawText 函数改变矩形的右边界，以容纳下正文行的最后一个字符 4. 出现上述任何一种情况，DrawText 函数将返回格式化文本的高度，而不是绘制文本</td></tr><tr><td>DT_CENTER</td><td>文本水平居中显示</td></tr><tr><td>DT_EDITCONTROL</td><td>将拥有多行编辑控件的正文显示特性（尤其是平均字符宽度的计算方法，并且不会显示不可见的最后一行）</td></tr><tr><td>DT_END_ELLIPSIS</td><td>1. 对于显示的文本，如果结束的字符串的范围不在矩形内，它会被截断并以省略号标识 2. 如果一个字母不是在字符串的末尾但却超出了矩形范围，它会被换行但没有追加省略号标识 3. 除非指定了 DT_MODIFYSTRING 标志，否则字符串不会被修改</td></tr><tr><td>DT_EXPANDTABS</td><td>1. 扩展制表符，每个制表符的缺省字符数是 8 2. DT_WORD_ELLIPSIS, DT_PATH_ELLIPSIS 和 DT_END_ELLIPSIS 不能和此参数一起使用</td></tr><tr><td>DT_EXTERNALLEADING</td><td>在行的高度里包含字体的外部标头（通常外部标头不被包含在正文行的高度里）</td></tr><tr><td>DT_HIDEPREFIX</td><td>1. 忽略正文中的前缀字符（&amp;），并且前缀字符后面的字母不会出现下划线，其它前缀字符的调用方式不受影响 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_HIDEPREFIX 显示为“Fis&amp;hC”</td></tr><tr><td>DT_INTERNAL</td><td>用系统字体来计算正文尺寸</td></tr><tr><td>DT_LEFT</td><td>正文左对齐</td></tr><tr><td>DT_MODIFYSTRING</td><td>1. 允许系统修改给定的字符串来匹配显示的正文 2. 此标志必须和 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 同时使用</td></tr><tr><td>DT_NOCLIP</td><td>无裁剪绘制，使用 DT_NOCLIP 可以提高 DrawText 的效率</td></tr><tr><td>DT_NOFULLWIDTHCHARBREAK</td><td>1. 在宽字符的字符串中防止行断开，因此折行规则相当于单字符的字符串 2. 例如，我们可以用在韩国版的 Windows 中，为图标标签提供更好的可读性 3. 除非指定 DT_WORDBREAK，否则此值没有作用</td></tr><tr><td>DT_NOPREFIX</td><td>1. 关闭前缀字符的处理（通常 DrawText 解释 &amp; 为给其后的字符加下划线，解释 &amp;&amp; 为显示单个 &amp;） 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_NOPREFIX 显示为“F&amp;is&amp;&amp;hC”</td></tr><tr><td>DT_PATH_ELLIPSIS</td><td>1. 对于过长的正文，自动替换字符串中间的字符为省略号（…），以确保结果能在合适的矩形内显示 2. 如果该字符串包含反斜杠（\）字符，DT_PATH_ELLIPSIS 尽可能的保留最后一个反斜杠之后的字符 3. 除非指定了 DT_MODIFYSTRING 标志否则字符串不会被修改</td></tr><tr><td>DT_PREFIXONLY</td><td>1. 仅仅在（&amp;）前缀字符的位置下绘制一个下划线，但不绘制字符串中的任何其他字符 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_PREFIXONLY 显示为“_”</td></tr><tr><td>DT_RIGHT</td><td>正文右对齐</td></tr><tr><td>DT_RTLREADING</td><td>当设备环境的字体是希伯来文或阿拉伯文字体时，为双向正文安排从右到左的阅读顺序</td></tr><tr><td>DT_SINGLELINE</td><td>显示正文的同一行，回车和换行符都不能换行</td></tr><tr><td>DT_TABSTOP</td><td>1. 设置制表符，参数 uFormat 的 8~15 位（低位字中的高位字节）指定每个制表符的字符数，每个制表符的缺省字符数是 8 2. DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP 和 DT_NOPREFIX 不能和此参数一起使用</td></tr><tr><td>DT_TOP</td><td>正文顶端对齐</td></tr><tr><td>DT_VCENTER</td><td>使正文在矩形中垂直居中，当且仅当设置了 DT_SINGLELINE 标志才有效</td></tr><tr><td>DT_WORDBREAK</td><td>1. 当一行中的字符将会延伸到由 lpRect 指定的矩形的边框时，此行自动地在单词之间断开 2. 一个回车一换行也能使之换行 3. 如果没有指定，输出会在一行上</td></tr><tr><td>DT_WORD_ELLIPSIS</td><td>截短不符合矩形的正文，并增加省略号（与 DT_END_ELLIPSIS 类似）</td></tr></tbody></table><h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值是正文的高度（逻辑单位）；</p></li><li><p>如果指定了 DT_VCENTER 或 DT_BOTTOM，返回值是 lpRect -&gt; top 到绘制的正文的底部的偏移值；</p></li><li><p>如果 函数调用失败，返回值是 0。</p></li></ol><h3 id="备注：-3"><a href="#备注：-3" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>函数 DrawText 用设备环境中的字体选择、正文颜色和背景颜色来写正文。</p></li><li><p>DrawText 裁剪正文，使之不会出现在指定矩形的外面，除非指定了 DT_NOCLIP。</p></li><li><p>除非使用 DT_SINGLELINE 格式化，否则其余的格式都认为正文有多行。</p></li><li><p>如果选择的字体对指定的矩形而言太大，DrawText 并不会试图去换成一种小字体。</p></li><li><p>设备环境的正文对齐方式必须包括 TA_LEFT, TA_TOP 和 TA_NOUPDATECP 标志。</p></li></ol><h2 id="EndPaint"><a href="#EndPaint" class="headerlink" title="EndPaint"></a>EndPaint</h2><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>EndPaint 函数标记指定窗口的绘画过程结束。</p><p>这个函数在每次调用 BeginPaint 函数之后被调用（释放设备描述表），但仅仅在绘画完成以后。</p><h3 id="API-函数原型：-6"><a href="#API-函数原型：-6" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> PAINTSTRUCT *lpPaint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-6"><a href="#参数解析：-6" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>已经被重新绘制的窗口句柄</td></tr><tr><td>lpPaint</td><td>指向 <a href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>的指针，用于存放绘画相关的信息（该指针在调用 BeginPaint 时被赋值）</td></tr></tbody></table><h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>该函数返回值始终是非 0。</p><h2 id="GetClientRect"><a href="#GetClientRect" class="headerlink" title="GetClientRect"></a>GetClientRect</h2><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>GetClientRect 函数用于获取窗口客户区的坐标，客户区坐标指定客户区的左上角和右下角。</p><p>由于客户区坐标是相对窗口客户区的左上角而言的，因此左上角坐标为（0，0）</p><h3 id="API-函数原型：-7"><a href="#API-函数原型：-7" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetClientRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPRECT lpRect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-7"><a href="#参数解析：-7" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>需要获取客户区坐标的窗口句柄</td></tr><tr><td>lpRect</td><td>1. 指向 <a href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>的指针，该结构有四个成员，分别为 left、top、right 和 bottom 2. GetClientRect 将这四个成员设定为窗口显示区域的尺寸，left 和 top 字段通常设定为 0，right 和 bottom 字段设定为显示区域的宽度和高度（像素点数）</td></tr></tbody></table><h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功，返回值是非 0；</p></li><li><p>如果函数失败，返回值是 0。</p></li></ol><h2 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h2><h3 id="函数功能：-5"><a href="#函数功能：-5" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetMessage 函数的作用是从当前线程的消息队列里获取一个消息并填入 <a href="http://bbs.fishc.com/thread-47240-1-1.html">MSG 结构</a> 中。</p><p>该函数只能获取调用线程的消息，不能获得其他线程的消息。成功获取消息后，线程将从消息队列中删除该消息。</p><p>使用 GetMessage 函数，如果消息队列为空，函数会一直等待直到有消息到来才有返回值。如果希望函数立刻返回（无论是否获取消息），请使用 <a href="http://bbs.fishc.com/thread-69031-1-1.html">PeekMessage</a> 函数。</p><h3 id="API-函数原型：-8"><a href="#API-函数原型：-8" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_     LPMSG lpMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT wMsgFilterMin,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT wMsgFilterMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-8"><a href="#参数解析：-8" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpMsg</td><td>指向 <a href="http://bbs.fishc.com/thread-47240-1-1.html">MSG 结构</a>的指针，用于存放获取到的消息</td></tr><tr><td>hWnd</td><td>1. 需要获取消息的窗口的句柄，该窗口必须属于当前线程 2. 当其值是 NULL 时，将获取所有的当前线程的窗口消息和线程消息 3. 当其值是 -1 时，只获取当前线程消息</td></tr><tr><td>wMsgFilterMin</td><td>指定被可以被获取的消息值的最小整数（消息其实就是一个被定义的整数）</td></tr><tr><td>wMsgFilterMax</td><td>指定被可以被获取的消息值的最小整数</td></tr></tbody></table><h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数取得 WM_QUIT 之外的其他消息，返回值是非 0；</p></li><li><p>如果函数取得 WM_QUIT 消息，返回值是 0；</p></li><li><p>如果出现了错误，返回值是 -1。</p></li></ol><h3 id="备注：-4"><a href="#备注：-4" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>应用程序通常根据 GetMessage 函数的返回值决定是否结束消息循环并退出程序；</p></li><li><p>如果 hWnd 参数不为零，则 GetMessage 函数只获取属于 hWnd 窗口的消息，以及被 <a href="http://bbs.fishc.com/thread-69035-1-1.html">IsChild</a> 函数确定为 hWnd 的子窗口的消息；</p></li><li><p>wMsgFilterMin 和 wMsgFilterMax 参数限定消息获取的范围，如果二者都为 0，则消息获取的范围为所有消息；</p></li><li><p>注意，即便你通过 wMsgFilterMin 和 wMsgFilterMax 参数限定消息获取的范围，但 WM_QUIT 不受此范围影响（无法阻止此消息被 PeekMessage 函数获取）；</p></li><li><p>调用此函数的过程中，如果接收到非排队消息 —— 也就是由该线程调用 <a href="http://bbs.fishc.com/thread-69038-1-1.html">SendMessage</a>, <a href="http://bbs.fishc.com/thread-69039-1-1.html">SendMessageCallback</a>, <a href="http://bbs.fishc.com/thread-69040-1-1.html">SendMessageTimeout</a>, 或 <a href="http://bbs.fishc.com/thread-69041-1-1.html">SendNotifyMessage</a> 发送给所属窗口的消息 —— 系统先暂时挂起等待，然后再获取过滤器匹配的第一个队列消息。如果不指定过滤器，那么按照以下顺序获取消息：</p></li></ol><ul><li>Sent messages</li><li>Posted messages</li><li>Input (hardware) messages and system internal events</li><li>Sent messages (again)</li><li>WM_PAINT messages</li><li>WM_TIMER messages</li></ul><ol start="6"><li>PeekMessage 函数通常不会从消息队列中删除 WM_PAINT 消息，WM_PAINT 会持续保留在消息队列中直到它们被处理，除非一个 WM_PAINT 消息指定的区域为 NULL。</li></ol><p><em>小甲鱼注释：大家应该还记得有三个消息 WM_QUIT, WM_PAINT, WM_TIMER 会被特殊处理，它们总是放在队列的最后面，直到没有其它消息的时候才被处理，连续的 WM_PAINT 消息将被合并成一个以提高绘图效率。</em></p><ol start="7"><li>如果一个顶层窗口停止响应的消息超过几秒钟，系统认为窗口没有响应，并使用一个备用窗口替代，该窗口具有相同的 Z 序列、位置、尺寸和视觉属性。这使得用户可以移动、调整大小，甚至关闭该应用程序。然而，这些仅仅是动作，现有的程序事实上仍然没有响应（为了提高用户体验而制作的假象）。当一个程序被调试时，系统并不会为其生成备用窗口。</li></ol><h2 id="GetTextAlign"><a href="#GetTextAlign" class="headerlink" title="GetTextAlign"></a>GetTextAlign</h2><h3 id="函数功能：-6"><a href="#函数功能：-6" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetTextAlign 函数获得指定的设备环境下的文本对齐方式的设置。</p><h3 id="API-函数原型：-9"><a href="#API-函数原型：-9" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetTextAlign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-9"><a href="#参数解析：-9" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>指定设备环境句柄</td></tr></tbody></table><h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用失败，返回值是 GDI_ERROR；</p></li><li><p>如果函数调用成功，返回值是文字对齐标志的状态。</p></li></ol><p>该返回值是下列值的组合：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>TA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>TA_BOTTOM</td><td>基准点在限定矩形的底边上（限定矩形的含义请看下边备注）</td></tr><tr><td>TA_TOP</td><td>基准点在限定矩形的顶边上</td></tr><tr><td>TA_CENTER</td><td>基准点在限定矩形的中心水平对齐位置</td></tr><tr><td>TA_LEFT</td><td>基准点在限定矩形的左边上</td></tr><tr><td>TA_RIGHT</td><td>基准点在限定矩形的右边上</td></tr><tr><td>TA_RTLREADING</td><td>1. 适用于中东 Windows 版本：正文从右到左的阅读顺序排列，与缺省的从左到右正好相反 2. 只有当被选择的字体是 Hebrew 或 Arabic 时，此值才有用</td></tr><tr><td>TA_NOUPDATECP</td><td>每次输出调用后当前状态不改变</td></tr><tr><td>TA_UPDATECP</td><td>每次输出调用后当前状态改变</td></tr></tbody></table><p>若当前字体有一条缺省的垂直基线（如Kanji），下列值用于取代 TA_BASELINE 和 TA_CENTER：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>VTA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>VTA_CENTER</td><td>基准点与限定矩形的中心垂直对齐</td></tr></tbody></table><h3 id="备注：-5"><a href="#备注：-5" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>默认值是 TA_LEFT, TA_TOP 和 TA_NOUPDATECP</p></li><li><p>限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形</p></li><li><p>限定矩形的尺寸可通过调用 GetTextExtentPoint32 来获得</p></li><li><p>文字对齐标志决定 <a href="http://bbs.fishc.com/thread-49474-1-1.html">TextOut</a> 和 ExtTextOut 如何将正文字符串与基准点对齐</p></li><li><p>文字对齐标志不必是单个的标志位，可以等于0</p></li><li><p>标志必须按相关的组来检查，如下：</p></li></ol><ul><li>TA_LEFT, TA_RIGHT, and TA_CENTER</li><li>TA_BOTTOM, TA_TOP, and TA_BASELINE</li><li>TA_NOUPDATECP and TA_UPDATECP</li></ul><p>如果当前字体有缺省的垂直基线，相关的标志如下所示：</p><ul><li>TA_LEFT, TA_RIGHT, and VTA_BASELINE</li><li>TA_BOTTOM, TA_TOP, and VTA_CENTER</li><li>TA_NOUPDATECP and TA_UPDATECP</li></ul><ol start="7"><li>要验证一个特定的标志在返回值中被设置，应用程序必须执行以下步骤：<br>（例子：<a href="http://bbs.fishc.com/thread-49943-1-1.html">如何设置文本对齐模式</a>）</li></ol><ul><li>对该标志及其相关标志实施位OR操作；</li><li>对结果和返回值实施位AND操作；</li><li>检查结果值和标志是否相等。</li></ul><h2 id="GetTextMetrics"><a href="#GetTextMetrics" class="headerlink" title="GetTextMetrics"></a>GetTextMetrics</h2><h3 id="函数功能：-7"><a href="#函数功能：-7" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetTextMetrics 函数将当前字体的信息填充到指定缓冲区（<a href="http://bbs.fishc.com/thread-50017-1-1.html">TEXTMETRIC 结构</a>）</p><h3 id="API-函数原型：-10"><a href="#API-函数原型：-10" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetTextMetrics</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTEXTMETRIC lptm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-10"><a href="#参数解析：-10" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>设备环境句柄</td></tr><tr><td>lptm</td><td>指向 <a href="http://bbs.fishc.com/thread-50017-1-1.html">TEXTMETRIC 结构</a>的指针，该结构用于获得字体信息</td></tr></tbody></table><h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值是非 0；</p></li><li><p>如果函数调用失败，返回值是 0。</p></li></ol><h3 id="备注：-6"><a href="#备注：-6" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>要确定一种字体是否为 TrueType 字体，可以通过调用 GetTextMetrics 函数，然后检查 TEXTMETRIC.tmPitchAndFamily 的值是否为 TMPF_TRUETYPE</p></li><li><p>注意，调用 GetDC 函数返回的是一个未初始化的 DC，它具有“系统”（一个位图字体）作为默认字体。因此你需要先选择一种字体到 DC</p></li></ol><h2 id="lstrcat"><a href="#lstrcat" class="headerlink" title="lstrcat"></a>lstrcat</h2><h3 id="函数功能：-8"><a href="#函数功能：-8" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrcat 函数的功能是将一个字符串拼接在另一个字符串后边。</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49707-1-1.html">StringCchCat</a> 代替。</strong></p><h3 id="API-函数原型：-11"><a href="#API-函数原型：-11" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">lstrcat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPTSTR lpString1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPTSTR lpString2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-11"><a href="#参数解析：-11" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString1</td><td>一个以’\0’为结尾的字符串，该字符串空间必须大到足以容纳本身及另一个字符串</td></tr><tr><td>lpString2</td><td>一个以’\0’为结尾的字符串，该字符串将拼接到 lpString1 指向的字符串后边</td></tr></tbody></table><h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回指向拼接好的字符串指针；</p></li><li><p>如果函数调用失败，返回值为 NULL，并且 lpString1 可能会变成非 ‘\0’ 结束的字符串。</p></li></ol><h3 id="安全建议："><a href="#安全建议：" class="headerlink" title="安全建议："></a><strong>安全建议：</strong></h3><ol><li><p>不正确的使用 lstrcat 函数，可能会损害应用程序的安全性</p></li><li><p>lstrcat 函数使用结构化异常处理（SEH）来捕捉访问冲突和其他错误。当该函数捕获 SEH 错误，如果没有以’\0’结尾的字符串，则返回 NULL，且不把错误通知调用者。因此，把空间不足作为错误的条件是不安全的</p></li><li><p>lpString1 必须足够大，以增加 lpString2 和结束’\0’，否则可能发生缓冲区溢出</p></li><li><p>在最坏的情况下，缓冲区溢出可能允许攻击者可执行代码注入到你的进程，尤其是当 lpString1 是一个基于堆栈的缓冲区</p></li></ol><h2 id="lstrcpy"><a href="#lstrcpy" class="headerlink" title="lstrcpy"></a>lstrcpy</h2><h3 id="函数功能：-9"><a href="#函数功能：-9" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrcpy 函数的功能是复制一个字符串到缓冲区。</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49713-1-1.html">StringCchCopy</a> 代替。</strong></p><h3 id="API-函数原型：-12"><a href="#API-函数原型：-12" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">lstrcpy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR lpString1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPTSTR lpString2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-12"><a href="#参数解析：-12" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString1</td><td>1. 缓冲区，用于接收来自 lpString2 参数指向的字符串 2. 该缓冲区必须足够容纳字符串和’\0’</td></tr><tr><td>lpString2</td><td>待拷贝的字符串</td></tr></tbody></table><h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回指向缓冲区的指针；</p></li><li><p>如果函数调用失败，返回值是 NULL，并且 lpString1 可能会变成非 ‘\0’ 结束的字符串。</p></li></ol><h3 id="安全建议：-1"><a href="#安全建议：-1" class="headerlink" title="安全建议："></a><strong>安全建议：</strong></h3><ol><li><p>不正确的使用 lstcpy 函数，可能会损害应用程序的安全性</p></li><li><p>lstrcpy 函数使用结构化异常处理（SEH）来捕捉访问冲突和其他错误。当该函数捕获 SEH 错误，如果没有以’\0’结尾的字符串，则返回 NULL，且不把错误通知调用者。因此，把空间不足作为错误的条件是不安全的</p></li><li><p>lpString1 必须足够大，以增加 lpString2 和结束’\0’，否则可能发生缓冲区溢出</p></li><li><p>在最坏的情况下，缓冲区溢出可能允许攻击者可执行代码注入到你的进程，尤其是当 lpString1 是一个基于堆栈的缓冲区</p></li></ol><h2 id="lstrlen"><a href="#lstrlen" class="headerlink" title="lstrlen"></a>lstrlen</h2><h3 id="函数功能：-10"><a href="#函数功能：-10" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrlen 函数用于计算指定字符串的长度（不包含’\0）</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49704-1-1.html">StringCchLength</a> 或 StringCbLength 代替。</strong></p><h3 id="API-函数原型：-13"><a href="#API-函数原型：-13" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">lstrlen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCTSTR lpString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-13"><a href="#参数解析：-13" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString</td><td>指向以’\0’为终止符的字符串</td></tr></tbody></table><h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>该函数返回指定字符串的字符数；</p></li><li><p>如果是空字符串，则返回 0。</p></li></ol><h2 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h2><h3 id="函数功能：-11"><a href="#函数功能：-11" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>MessageBox 函数用于显示一个模态对话框，其中包含一个系统图标、 一组按钮和一个简短的特定于应用程序消息，如状态或错误的信息。</p><p>消息框中返回一个整数值，该值指示用户单击了哪个按钮。</p><h3 id="API-函数原型：-14"><a href="#API-函数原型：-14" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-14"><a href="#参数解析：-14" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>1. 该消息框的父窗口句柄 2. 如果此参数为NULL，则该消息框没有拥有父窗口</td></tr><tr><td>lpText</td><td>消息框的内容</td></tr><tr><td>lpCaption</td><td>消息框的标题</td></tr><tr><td>uType</td><td>1. 指定一个决定对话框的内容和行为的位标志集 2. 此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td></tr></tbody></table><h3 id="uType参数定义解析"><a href="#uType参数定义解析" class="headerlink" title="uType参数定义解析"></a><strong>uType参数定义解析</strong></h3><table><thead><tr><th><strong>按钮</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_OK</td><td>默认值，有一个“确认”按钮在里面</td></tr><tr><td>MB_YESNO</td><td>有“是”和“否”两个按钮在里面</td></tr><tr><td>MB_ABORTRETRYIGNORE</td><td>有“中止”，“重试”和“跳过”三个按钮在里面</td></tr><tr><td>MB_YESNOCANCEL</td><td>有“是”，“否”和“取消”三个按钮在里面</td></tr><tr><td>MB_RETRYCANCEL</td><td>有“重试”和“取消”两个按钮在里面</td></tr><tr><td>MB_OKCANCEL</td><td>有“确定”和“取消”两个按钮在里面</td></tr></tbody></table><table><thead><tr><th><strong>图标</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_ICONEXCLAMATION</td><td>一个惊叹号出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/33_400_300.jpg" alt="IC534153.png"></td></tr><tr><td>MB_ICONWARNING</td><td>一个惊叹号出现在消息框（同上）</td></tr><tr><td>MB_ICONINFORMATION</td><td>一个圆圈中小写字母i组成的图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/30_400_300.jpg" alt="IC534154.png"></td></tr><tr><td>MB_ICONASTERISK</td><td>一个圆圈中小写字母i组成的图标出现在消息框（同上）</td></tr><tr><td>MB_ICONQUESTION</td><td>一个问题标记图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/32_400_300.jpg" alt="IC534152.png"></td></tr><tr><td>MB_ICONSTOP</td><td>一个停止消息图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/31_400_300.jpg" alt="IC534151.png"></td></tr><tr><td>MB_ICONERROR</td><td>一个停止消息图标出现在消息框（同上）</td></tr><tr><td>MB_ICONHAND</td><td>一个停止消息图标出现在消息框（同上）</td></tr></tbody></table><table><thead><tr><th><strong>默认按钮</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_DEFBUTTON1</td><td>指定第一个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON2</td><td>指定第二个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON3</td><td>指定第三个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON4</td><td>指定第四个按钮为默认按钮</td></tr></tbody></table><table><thead><tr><th><strong>消息框形态</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_APPLMODAL</td><td>1. 在 hWnd 参数标识的窗口中继续工作以前，用户一定响应消息框 2. 但是，用户可以移动到其他线程的窗口且在这些窗口中工作 3. 根据应用程序中窗口的层次机构，用户则以移动到线程内的其他窗口 4. 所有母消息框的子窗口自动地失效，但是弹出窗口不是这样 5. 如果既没有指定 MB_SYSTEMMODAL 也没有指定 MB_TASKMODAL，则 MB_APPLMODAL 为默认的</td></tr><tr><td>MB_SYSTEMMODAL</td><td>1. 除了消息框有 WB_EX_TOPMOST 类型，否则 MB_APPLMODAL 和 MB_SYSTEMMODAL 一样 2. 用系统模态消息框来改变各种各样的用户，主要的损坏错误需要立即注意（例如，内存溢出） 3. 如果不是那些与 hWnd 联系的窗口，此标志对用户对窗口的相互联系没有影响</td></tr><tr><td>MB_TASKMODAL</td><td>1. 如果参数 hWnd 为 NULL 的话，那么除了所有属于当前线程高层次的窗口失效外，MB_TASKMODAL 和 MB_APPLMODAL 一样 2. 当调用应用程序或库没有一个可以得到的窗口句柄时，可以使用此标志，但仍需要阻止输入到调用线程的其他窗口，而不是搁置其他线程</td></tr></tbody></table><table><thead><tr><th><strong>其他标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_DEFAULT_DESKTOP_ONLY</td><td>1. 接收输入的当前桌面一定是一个默认桌面，否则函数调用失败 2. 默认桌面是一个在用户已经记录且以后应用程序在此上面运行的桌面</td></tr><tr><td>MB_HELP</td><td>1. 把一个 Help 按钮增加到消息框 2. 选择 Help 按钮或按 F1 产生一个 Help 事件</td></tr><tr><td>MB_RIGHT</td><td>文本为右对齐</td></tr><tr><td>MB_RTLREADING</td><td>用在 Hebrew 和 Arabic 系统中从右到左的顺序显示消息和大写文本</td></tr><tr><td>MB_SETFOREGROUND</td><td>1. 消息框变为前景窗口 2. 在内部系统为消息个调用 SetForegroundWindow 函数</td></tr><tr><td>MB_TOPMOST</td><td>消息框用 WS_EX_TOPMOST 窗口类型来创建 MB_SERVICE_NOTIFICATION</td></tr></tbody></table><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>1. 该消息框的父窗口句柄 2. 如果此参数为NULL，则该消息框没有拥有父窗口</td></tr><tr><td>lpText</td><td>消息框的内容</td></tr><tr><td>lpCaption</td><td>消息框的标题</td></tr><tr><td>uType</td><td>1. 指定一个决定对话框的内容和行为的位标志集 2. 此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td></tr></tbody></table><h3 id="返回值：-14"><a href="#返回值：-14" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><table><thead><tr><th><strong>返回值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>IDOK</td><td>用户按下了“确认”按钮</td></tr><tr><td>IDCANCEL</td><td>用户按下了“取消”按钮</td></tr><tr><td>IDABORT</td><td>用户按下了“中止”按钮</td></tr><tr><td>IDRETRY</td><td>用户按下了“重试”按钮</td></tr><tr><td>IDIGNORE</td><td>用户按下了“忽略”按钮</td></tr><tr><td>IDYES</td><td>用户按下了“是”按钮</td></tr><tr><td>IDNO</td><td>用户按下了“否”按钮</td></tr></tbody></table><h2 id="PostQuitMessage"><a href="#PostQuitMessage" class="headerlink" title="PostQuitMessage"></a>PostQuitMessage</h2><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>PostQuitMessage 函数向系统表明有个线程提出终止（退出）请求。</p><p>这个函数通常用来响应 WM_DESTROY 消息。</p><h3 id="API-函数原型：-15"><a href="#API-函数原型：-15" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">PostQuitMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-15"><a href="#参数解析：-15" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>nExitCode</td><td>指定应用程序的退出代码，此值被用作 WM_QUIT 消息的 wParam 参数</td></tr></tbody></table><h3 id="返回值：-15"><a href="#返回值：-15" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>该函数没有返回值。</p><h3 id="备注：-7"><a href="#备注：-7" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>PostQuitMessage 函数的功能是发送一个 WM_QUIT 消息给线程的消息队列并立即返回。</p></li><li><p>当线程从消息队列里取得 WM_QUIT 消息时，应当退出消息循环并将返回系统，返回给系统的退出值必须是消息 WM_QUIT 的 wParam 参数（所以 WinMain 函数的返回值是 msg.wParam）。</p></li></ol><h2 id="SetScrollRange"><a href="#SetScrollRange" class="headerlink" title="SetScrollRange"></a>SetScrollRange</h2><h3 id="函数功能：-12"><a href="#函数功能：-12" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>SetScrollRange 函数设置所指定滚动条范围的最小值和最大值。</p><p>注意：SetScrollRange 函数提供了向后的兼容性。但新的应用程序应该提倡使用 SetScrollInfo 函数代替。</p><h3 id="API-函数原型：-16"><a href="#API-函数原型：-16" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetScrollRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nBar,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nMinPos,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nMaxPos,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  BOOL bRedraw</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-16"><a href="#参数解析：-16" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>1. 滚动条控件的句柄或带有标准滚动条窗体的句柄 2. 由 nBar 参数的值确定</td></tr><tr><td>nBar</td><td>指定将要设置哪类滚动条的参数： 1. SB_CTL：设置滚动条控件的范围，要求参数 hwnd 必须是滚动条控件的句柄 2. SB_HORZ：设置窗体的标准水平滚动条的范围 3. SB_VERT：设置窗体的标准垂直滚动条的范围</td></tr><tr><td>nMinPos</td><td>指定滚动位置的最小值</td></tr><tr><td>nMaxPos</td><td>指定滚动位置的最大值</td></tr><tr><td>bRedraw</td><td>指定滚动条是否被重画以反映变化（如果这个参数为 TRUE，滚动条将被重画；如果为 FALSE 则不被重画）</td></tr></tbody></table><h3 id="返回值：-16"><a href="#返回值：-16" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值为非 0；</p></li><li><p>如果函数调用失败，返回值为 0。</p></li></ol><h3 id="备注：-8"><a href="#备注：-8" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>将 SetScrollRange 函数中的 nMinPos 和 nMaxPos 参数设置为一样的值，可以达到隐藏滚动条的目的。但在处理滚动条消息时，应用程序不应该调用 SetScrollRange 函数来隐藏滚动条。新的应用程序应该调用 ShowScrollBar 函数来隐藏滚动条。</p></li><li><p>如果调用 SetScrollPos 函数之后马上调用 SetScrollRange 函数，则 SetScrollPos 函数中的 bRedraw 参数一定要设置为零值（FALSE），以防止滚动条被画两次。</p></li><li><p>标准滚动条的缺省范围是 0 到 100。滚动条控件的缺省值为 NULL（参数 nMinPos 和 nMaxPos 的值均为零）。两个范围值之间的不同之处在于由参数 nMinPos 和 nMaxPos 指定，不过不能超过 MAXLONG 定义的大小。</p></li><li><p>因为说明滚动条位置的消息 WM_HSCROLL 和 WM_VSCROLL 是 16 位数据，所以那些只依赖于说明位置数据消息的应用程序在 SetScrollRange 函数的参数 nMaxPos 中有一个实际最大值 65,535。但是，因为 SetScrolllnfo，SetScrollPos， SetScrollRange，GetScrolllnfo，GetScrollPos 和 GetScrollRange 函数都支持 32 位的滚动条位置数据，所以有一个解决 16 位 WM_HSCROLL 和 WM_VSCROLL 消息阻碍的途径，请参见函数 GetScrolllnfo 的有关技术说明。</p></li><li><p>如果参数 nBar 设置为 SB_CTL 并且参数 hWnd 所标识的不是一个标准的滚动条控件。系统将发送一个 SBM_SETRANGE 消息到窗体用以设置滚动条消息。这将允许 SetScrollRange 函数操作一个定制的伪滚动条控件。如果窗体没有处理 SBM_SETRANGE 消息，SetScrollRange 函数将调用失败。</p></li></ol><h2 id="SetTextAlign"><a href="#SetTextAlign" class="headerlink" title="SetTextAlign"></a>SetTextAlign</h2><h3 id="函数功能：-13"><a href="#函数功能：-13" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>SetTextAlign 函数为指定设备环境设置文本的对齐标志。</p><h3 id="API-函数原型：-17"><a href="#API-函数原型：-17" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SetTextAlign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  UINT fMode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-17"><a href="#参数解析：-17" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>指定设备环境句柄</td></tr><tr><td>fMode</td><td>1. 文本对齐标志 2. 在横向对齐和纵向对齐标志中只能选择一个 3. 两个标志只能选择一个来改变当前的位置</td></tr></tbody></table><p>使用下面的列表中的掩码指定文本对齐方式：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>TA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>TA_BOTTOM</td><td>基准点在限定矩形的底边上（限定矩形的含义请看下边备注）</td></tr><tr><td>TA_TOP</td><td>基准点在限定矩形的顶边上</td></tr><tr><td>TA_CENTER</td><td>基准点在限定矩形的中心水平对齐位置</td></tr><tr><td>TA_LEFT</td><td>基准点在限定矩形的左边上</td></tr><tr><td>TA_RIGHT</td><td>基准点在限定矩形的右边上</td></tr><tr><td>TA_NOUPDATECP</td><td>1. 适用于中东 Windows 版本：正文从右到左的阅读顺序排列，与缺省的从左到右正好相反 2. 只有当被选择的字体是 Hebrew 或 Arabic 时，此值才有用</td></tr><tr><td>TA_RTLREADING</td><td>每次输出调用后当前状态不改变</td></tr><tr><td>TA_UPDATECP</td><td>每次输出调用后当前状态改变</td></tr></tbody></table><p>若当前字体有一条缺省的垂直基线（如Kanji），下列值用于取代 TA_BASELINE 和 TA_CENTER：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>VTA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>VTA_CENTER</td><td>基准点与限定矩形的中心垂直对齐</td></tr></tbody></table><p>默认值是 TA_LEFT, TA_TOP 和 TA_NOUPDATECP。</p><h3 id="返回值：-17"><a href="#返回值：-17" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用失败，返回值是 GDI_ERROR；</p></li><li><p>如果函数调用成功，返回值是文字对齐方式的前一个设置。</p></li></ol><h3 id="备注：-9"><a href="#备注：-9" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形</p></li><li><p><a href="http://bbs.fishc.com/thread-49474-1-1.html">TextOut</a> 和 ExtTextOut 函数用文字对齐标志来将一个正文字符串定位于显示器或者其他设备</p></li><li><p>该标志指定了基准点与限定正文的矩形的位置关系，基准点可以是当前位置，也可是传给正文输出函数的一个点</p></li><li><p>设置左对齐文本的做好方法可以是如下：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign (hdc, GetTextAlign(hdc) &amp; (~TA_CENTER))</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign (hdc,TA_LEFT | &lt;other flags&gt;)</span><br></pre></td></tr></table></figure><p>你当然可以使用 SetTextAlign (hdc, TA_LEFT) 来达到这个目的，但是这个方法会丢失所有的垂直基线或者从右到左的设置。</p><ol start="5"><li>调用 SetTextAlign 函数时，如果使用 TA_UPDATECP 标志，Windows 会忽略 TextOut 的 xStart 和 yStart 参数，而使用由 MoveToEx、LineTo 或更改目前位置的另一个函数设定的位置。</li></ol><h2 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h2><h3 id="函数功能：-14"><a href="#函数功能：-14" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>ShowWindow 函数用于设置窗口的显示状态。</p><p>应用程序第一次调用 ShowWindow 时，应该使用 WinMain 函数的 nCmdshow 参数作为它的 nCmdShow 参数。在随后调用 ShowWindow 函数时，必须使用下列显示方式中的一个给定值，而不是由 WinMain 函数的 nCmdSHow 参数指定的值。</p><h3 id="API-函数原型：-18"><a href="#API-函数原型：-18" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ShowWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nCmdShow</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-18"><a href="#参数解析：-18" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>窗口句柄</td></tr><tr><td>nCmdShow</td><td>控制窗口如何显示，如果发送应用程序的程序提供了 STARTUPINFO 结构，则应用程序第一次调用 ShowWindow 时该参数被忽略。否则，在第一次调用 ShowWindow 函数时，该值应为在函数 WinMain 中 nCmdShow 参数。</td></tr></tbody></table><p><strong>在随后的调用中，nCmdShow 参数可以为下列值之一：</strong></p><table><thead><tr><th><strong>显示方式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>SW_FORCEMINIMIZE</td><td>1. 最小化窗口，即使拥有窗口的线程被挂起也会最小化 2. 在从其他线程最小化窗口时才使用这个参数</td></tr><tr><td>SW_HIDE</td><td>隐藏窗口并激活其他窗口</td></tr><tr><td>SW_MAXIMIZE</td><td>最大化指定的窗口</td></tr><tr><td>SW_MINIMIZE</td><td>最小化指定的窗口并且激活在 Z 序中的下一个顶层窗口</td></tr><tr><td>SW_RESTORE</td><td>1. 激活并显示窗口 2. 如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置 3. 在恢复最小化窗口时，应用程序应该指定这个标志。</td></tr><tr><td>SW_SHOW</td><td>在窗口原来的位置以原来的尺寸激活并显示窗口</td></tr><tr><td>SW_SHOWDEFAULT</td><td>依据在 STARTUPINFO 结构中指定的 SW_FLAG 标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给 CreateProcess 函数的。</td></tr><tr><td>SW_SHOWMAXIMIZED</td><td>激活窗口并将其最大化</td></tr><tr><td>SW_SHOWMINIMIZED</td><td>激活窗口并将其最小化</td></tr><tr><td>SW_SHOWMINNOACTIVE</td><td>1. 窗口最小化 2. 在窗口激活的情况下，这个值跟 SW_SHOWMINIMIZED 很相似</td></tr><tr><td>SW_SHOWNA</td><td>1. 以窗口原来的位置以原来的尺寸显示窗口 2. 在窗口激活的情况下，这个值跟 SW_SHOW 很相似</td></tr><tr><td>SW_SHOWNOACTIVATE</td><td>1. 以窗口最近一次的位置和尺寸显示窗口 2. 在窗口激活的情况下，这个值跟 SW_SHOWNORMAL 很相似</td></tr><tr><td>SW_SHOWNORMAL</td><td>1. 激活并显示一个窗口 2. 如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小 3. 应用程序在第一次显示窗口的时候应该指定此标志</td></tr></tbody></table><h3 id="返回值：-18"><a href="#返回值：-18" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果窗口之前可见，则返回值为非 0；</p></li><li><p>如果窗口之前被隐藏，则返回值为 0。</p></li></ol><h2 id="StringCchCat"><a href="#StringCchCat" class="headerlink" title="StringCchCat"></a>StringCchCat</h2><h3 id="函数功能：-15"><a href="#函数功能：-15" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchCat 函数的功能是将一个字符串拼接到另一个字符串。StringCchCat 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strcat, wcscat, _tcsat</li><li>lstrcat</li><li>StrCat</li><li>StrCatBuff</li></ul><h3 id="API-函数原型：-19"><a href="#API-函数原型：-19" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPCTSTR pszSrc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-19"><a href="#参数解析：-19" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>1. 目标缓冲区，同时包含第一个字符串 2. 该缓冲区必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+’\0’）</td></tr><tr><td>cchDest</td><td>1. 目标缓冲区的大小（字符个数） 2. 该值必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+’\0’） 3. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pszSrc</td><td>第二个字符串</td></tr></tbody></table><h3 id="返回值：-19"><a href="#返回值：-19" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是拼接好的字符串指针。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-2.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-2.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>字符串正常拼接</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. cchDest 参数的值为 0 2. cchDest 参数的值大于 STRSAFE_MAX_CCH 3. 目标缓冲区空间已满</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 因缓冲区空间不足导致失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h3 id="备注：-10"><a href="#备注：-10" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>使用 StringCchCat 函数需要添加头文件：strsafe.h</p><h2 id="StringCchCopy"><a href="#StringCchCopy" class="headerlink" title="StringCchCopy"></a>StringCchCopy</h2><h3 id="函数功能：-16"><a href="#函数功能：-16" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchCopy 函数的功能是复制一个字符串到缓冲区。StringCchCopy 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strcpy, wcscpy, _tcscpy</li><li>lstrcpy</li><li>StrCpy</li></ul><h3 id="API-函数原型：-20"><a href="#API-函数原型：-20" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCopy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR pszSrc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-20"><a href="#参数解析：-20" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>缓冲区，用于接收拷贝过来的字符串</td></tr><tr><td>cchDest</td><td>1. 目标缓冲区的大小（字符个数） 2. 该值必须大于或等于 pszSrc + 1（待拷贝字符串的字符+’\0’） 3. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pszSrc</td><td>待拷贝的字符串</td></tr></tbody></table><h3 id="返回值：-20"><a href="#返回值：-20" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是指向缓冲区的指针。我们强烈建议您使用 SUCCEEDED 和 FAILED 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>字符串正常拷贝</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. cchDest 参数的值为 0 2. cchDest 参数的值大于 STRSAFE_MAX_CCH</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 因缓冲区空间不足导致失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h2 id="StringCchLength"><a href="#StringCchLength" class="headerlink" title="StringCchLength"></a>StringCchLength</h2><h3 id="函数功能：-17"><a href="#函数功能：-17" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchLength 函数用于确定字符串是否超过了规定的长度，以字符为计算单位。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strlen, wcslen, _tcslen</li></ul><h3 id="API-函数原型：-21"><a href="#API-函数原型：-21" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchLength</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR psz,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchMax,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  <span class="keyword">size_t</span> *pcch</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-21"><a href="#参数解析：-21" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>psz</td><td>指向待检查的字符串</td></tr><tr><td>cchMax</td><td>1. psz 参数里最大允许的字符数量，包括’\0’ 2. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pcch</td><td>1. psz 参数指向字符串的字符个数，不包括’\0’ 2. 这个值只有在 psz 指针不为 NULL，且函数成功时有效</td></tr></tbody></table><h3 id="返回值：-21"><a href="#返回值：-21" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是指定字符串的字符个数。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>psz 指向的字符串不为空，且字符串的长度（包括’\0’）小于等于 cchMax</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. psz 指向空字符串 2. cchMax 的值大于STRSAFE_MAX_CCH 3. psz 指向的字符串的字符个数超过 cchMax</td></tr></tbody></table><h3 id="备注：-11"><a href="#备注：-11" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>对比 StringCchLength 所替代的函数，StringCchLength 是可以使你的代码正确处理缓存区的一个附加功能。因为小的缓冲处理会牵连很多安全问题，例如缓存区溢出</p></li><li><p>使用 StringCchLength 函数需要添加头文件：strsafe.h</p></li></ol><h2 id="StringCchPrintf"><a href="#StringCchPrintf" class="headerlink" title="StringCchPrintf"></a>StringCchPrintf</h2><h3 id="函数功能：-18"><a href="#函数功能：-18" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchPrintf 函数用于把数据格式化写入到指定的缓冲区里，该函数要求提供目标缓冲区的大小，确保不会发生越界访问。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>sprintf, swprintf, _stprintf</li><li>wsprintf</li><li>wnsprintf</li><li>_snprintf, _snwprintf, _sntprintf</li></ul><h3 id="API-函数原型：-22"><a href="#API-函数原型：-22" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchPrintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR pszFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-22"><a href="#参数解析：-22" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>指定格式化数据将要写入的缓冲区</td></tr><tr><td>cchDest</td><td>1. 缓冲区大小 2. 应该设置足够大，以容纳字符串和结束标记（’\n’） 3. 最大允许的字符数是 STRSAFE_MAX_CCH</td></tr><tr><td>pszFormat</td><td>1. 格式化字符串 2. 与 pirntf 的格式化字符串一致</td></tr><tr><td>…</td><td>可变参数，参数的个数取决 pszFormat 参数</td></tr></tbody></table><h3 id="返回值：-22"><a href="#返回值：-22" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是像 sprintf 一样返回存储在其目标缓冲区的字节数。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>表示有足够的空间将拷贝到 pszDest，没有发生截断</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>cchDest 的值为 0 或大于 STRSAFE_MAX_CCH</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 由于缓冲区空间不足而导致的复制失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h3 id="备注：-12"><a href="#备注：-12" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>使用 StringCchPrintf 函数需要添加头文件：<strong>strsafe.h</strong></p><h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a><strong>代码演示：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strsafe.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">TCHAR pszDest[<span class="number">30</span>]; </span><br><span class="line"><span class="keyword">size_t</span> cchDest = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">LPCTSTR pszFormat = TEXT(<span class="string">&quot;从你家到鱼C工作室需要 %f 公里！&quot;</span>);</span><br><span class="line"></span><br><span class="line">HRESULT hr = StringCchPrintf(pszDest, cchDest, pszFormat, <span class="number">123.45</span>);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="TextOut"><a href="#TextOut" class="headerlink" title="TextOut"></a>TextOut</h2><h3 id="函数功能：-19"><a href="#函数功能：-19" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>TextOut 函数使用当前选择的字体、背景颜色和文本颜色，将一个字符串绘制于窗口的指定位置。</p><h3 id="API-函数原型：-23"><a href="#API-函数原型：-23" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nXStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nYStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCTSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> cchString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-23"><a href="#参数解析：-23" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>设备环境句柄</td></tr><tr><td>nXStart</td><td>指定用于字符串对齐的基准点的逻辑 x 坐标（有关基准点请看下边备注）</td></tr><tr><td>nYStart</td><td>指定用于字符串对齐的基准点的逻辑 y 坐标</td></tr><tr><td>lpString</td><td>1. 指向将被绘制字符串的指针 2. 该字符串不必以’\0’结束，因为 cchString 参数指定了该字符串的长度</td></tr><tr><td>cchString</td><td>lpString 字符串的长度（有多少个字符）</td></tr></tbody></table><h3 id="返回值：-23"><a href="#返回值：-23" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值为非 0；</p></li><li><p>如果函数调用失败，返回值为 0。</p></li></ol><h3 id="备注：-13"><a href="#备注：-13" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>字符串对齐的基准点取决于当前的文本对齐模式。应用程序可以通过调用 <a href="http://bbs.fishc.com/thread-49489-1-1.html">GetTextAlign</a> 获得当前的文本对齐模式，通过调用 <a href="http://bbs.fishc.com/thread-49492-1-1.html">SetTextAlign</a> 修改该模式。</p><h2 id="TranslateMessage"><a href="#TranslateMessage" class="headerlink" title="TranslateMessage"></a>TranslateMessage</h2><h3 id="函数功能：-20"><a href="#函数功能：-20" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>TranslateMessage 函数将虚拟键消息转换为字符消息，字符消息被寄送到当前线程的消息队列里。</p><p>当下一次线程调用函数 GetMessage 或 PeekMessage 时被读出。</p><h3 id="API-函数原型：-24"><a href="#API-函数原型：-24" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">TranslateMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> MSG *lpMsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-24"><a href="#参数解析：-24" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpMsg</td><td>指向含有消息的 MSG 结构的指针</td></tr></tbody></table><h3 id="返回值：-24"><a href="#返回值：-24" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果消息被转换（字符消息被寄送到当前线程的消息队列里）则返回非零值；</p></li><li><p>如果消息是 WM_KEYDOWN，WM_KEYUP WM_SYSKEYDOWN 或 WM_SYSKEYUP，返回非零值，不考虑转换；</p></li><li><p>如果消息没被转换（字符消息没被寄送到调用线程的消息队列里）则返回值是零。</p></li></ol><h2 id="UpdateWindow"><a href="#UpdateWindow" class="headerlink" title="UpdateWindow"></a>UpdateWindow</h2><h3 id="函数功能：-21"><a href="#函数功能：-21" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>UpdateWindow 函数绕过应用程序的消息队列，直接发送 WM_PAINT 消息给指定窗口的窗口过程。</p><p>如果窗口更新的区域不为空，UpdateWindow 函数通过发送一个 WM_PAINT 消息来更新指定窗口的客户区。如果更新区域为空，则不发送消息。</p><h3 id="API-函数原型：-25"><a href="#API-函数原型：-25" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UpdateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-25"><a href="#参数解析：-25" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定要更新的窗口的句柄.</td></tr></tbody></table><h3 id="返回值：-25"><a href="#返回值：-25" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值为非 0；</p></li><li><p>如果函数调用不成功，返回值为 0。</p></li></ol><h2 id="wsprintf"><a href="#wsprintf" class="headerlink" title="wsprintf"></a>wsprintf</h2><h3 id="函数功能：-22"><a href="#函数功能：-22" class="headerlink" title="函数功能："></a><strong>函数功能</strong>：</h3><ul><li>wsprintf 函数将格式化字符串写入到指定的缓冲区里</li><li>输出缓冲区里的的值取决于格式说明符（即”%”）</li><li>如果写入的是文字，此函数给写入的文字的末尾追加一个’\0’</li><li>函数的返回值是写入的长度，但不包括最后的’\0’</li></ul><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49693-1-1.html">StringCchPrintf</a> 或 StringCbPrint 代替。</strong></p><h3 id="API-函数原型：-26"><a href="#API-函数原型：-26" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">wsprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR lpOut,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR lpFmt,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-26"><a href="#参数解析：-26" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpOut</td><td>1. 指定格式化数据将要写入的缓冲区 2. 缓冲区限定最大为 1024 字节</td></tr><tr><td>lpFmt</td><td>1. 格式化字符串 2. 与 printf 的格式化字符串基本一致，但不支持浮点数</td></tr><tr><td>…</td><td>可变参数，参数的个数取决 lpFmt 参数</td></tr></tbody></table><h3 id="返回值：-26"><a href="#返回值：-26" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值与计划写入缓冲区的字符个数相等（不包含最后的’\0’）；</p></li><li><p>如果函数调用失败，返回值小于计划写入缓冲区的字符个数，可通过调用 GetLastError 获取详细的错误信息。</p></li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="MSG-结构"><a href="#MSG-结构" class="headerlink" title="MSG 结构"></a>MSG 结构</h2><h3 id="MSG-消息结构"><a href="#MSG-消息结构" class="headerlink" title="MSG 消息结构"></a><strong>MSG 消息结构</strong></h3><p>在 Windows 程序中，消息是由 MSG 结构体来表示的。</p><h3 id="结构原型："><a href="#结构原型：" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">  HWND   hwnd;</span><br><span class="line">  UINT   message;</span><br><span class="line">  WPARAM wParam;</span><br><span class="line">  LPARAM lParam;</span><br><span class="line">  DWORD  time;</span><br><span class="line">  POINT  pt;</span><br><span class="line">&#125; MSG, *PMSG, *LPMSG;</span><br></pre></td></tr></table></figure><h3 id="成员解析："><a href="#成员解析：" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hwnd</td><td>指定接收消息的窗口句柄 如果是线程消息，该值是 NULL</td></tr><tr><td>message</td><td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式 2. 应用程序消息只能使用低 16 位，高 16 位被系统保留 3. 传送门：<a href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td></tr><tr><td>wParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>lParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>time</td><td>该消息被投放到消息队列的时间</td></tr><tr><td>pt</td><td>当消息被投放到消息队列的时，鼠标位于屏幕中的位置</td></tr></tbody></table><h2 id="PAINTSTRUCT-结构"><a href="#PAINTSTRUCT-结构" class="headerlink" title="PAINTSTRUCT 结构"></a>PAINTSTRUCT 结构</h2><p>PAINTSTRUCT 结构包含一些窗口过程用来对客户区进行绘制的信息。</p><h3 id="结构原型：-1"><a href="#结构原型：-1" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">  HDC  hdc;</span><br><span class="line">  BOOL fErase;</span><br><span class="line">  RECT rcPaint;</span><br><span class="line">  BOOL fRestore;</span><br><span class="line">  BOOL fIncUpdate;</span><br><span class="line">  BYTE rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-1"><a href="#成员解析：-1" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>用于绘制的设备环境句柄</td></tr><tr><td>fErase</td><td>1. 表示背景是否必须擦除，如果为非零值则擦除背景，否则不擦除背景 2. 如果创建窗口类的时候没有设置背景画刷，则负责擦除背景</td></tr><tr><td>rcPaint</td><td>一个 <a href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>，指定左上角和右下角的坐标确定一个要绘制的矩形范围</td></tr><tr><td>fRestore</td><td>系统保留</td></tr><tr><td>fIncUpdate</td><td>系统保留</td></tr><tr><td>rgbReserved</td><td>系统保留</td></tr></tbody></table><h2 id="RECT-结构"><a href="#RECT-结构" class="headerlink" title="RECT 结构"></a>RECT 结构</h2><p>RECT 结构定义了一个矩形的左上角和右下角的坐标。</p><h3 id="结构原型：-2"><a href="#结构原型：-2" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RECT</span> &#123;</span></span><br><span class="line">  LONG left;</span><br><span class="line">  LONG top;</span><br><span class="line">  LONG right;</span><br><span class="line">  LONG bottom;</span><br><span class="line">&#125; RECT, *PRECT;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-2"><a href="#成员解析：-2" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>left</td><td>指定矩形左上角的 x 坐标</td></tr><tr><td>top</td><td>指定矩形左上角的 y 坐标</td></tr><tr><td>right</td><td>指定矩形右下角的 x 坐标</td></tr><tr><td>bottom</td><td>指定矩形右下角的 y 坐标</td></tr></tbody></table><h2 id="TEXTMETRIC-结构"><a href="#TEXTMETRIC-结构" class="headerlink" title="TEXTMETRIC 结构"></a>TEXTMETRIC 结构</h2><p>TEXTMETRIC 结构记录当前设备环境中有关字体的各种信息。</p><p>TEXTMETRIC 结构成员的值的单位取决于设备环境中当前选定的映射模式，默认的映射模式是 MM_TEXT，所以它们的值是以像素为单位的。</p><h3 id="结构原型：-3"><a href="#结构原型：-3" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRIC</span> &#123;</span></span><br><span class="line">  LONG  tmHeight;</span><br><span class="line">  LONG  tmAscent;</span><br><span class="line">  LONG  tmDescent;</span><br><span class="line">  LONG  tmInternalLeading;</span><br><span class="line">  LONG  tmExternalLeading;</span><br><span class="line">  LONG  tmAveCharWidth;</span><br><span class="line">  LONG  tmMaxCharWidth;</span><br><span class="line">  LONG  tmWeight;</span><br><span class="line">  LONG  tmOverhang;</span><br><span class="line">  LONG  tmDigitizedAspectX;</span><br><span class="line">  LONG  tmDigitizedAspectY;</span><br><span class="line">  TCHAR tmFirstChar;</span><br><span class="line">  TCHAR tmLastChar;</span><br><span class="line">  TCHAR tmDefaultChar;</span><br><span class="line">  TCHAR tmBreakChar;</span><br><span class="line">  BYTE  tmItalic;</span><br><span class="line">  BYTE  tmUnderlined;</span><br><span class="line">  BYTE  tmStruckOut;</span><br><span class="line">  BYTE  tmPitchAndFamily;</span><br><span class="line">  BYTE  tmCharSet;</span><br><span class="line">&#125; TEXTMETRIC, *PTEXTMETRIC;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-3"><a href="#成员解析：-3" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>tmHeight</td><td>字符高度（tmAscent + tmDescent）</td></tr><tr><td>tmAscent</td><td>字符上部高度（基线以上）</td></tr><tr><td>tmDescent</td><td>字符下部高度（基线以下）</td></tr><tr><td>tmInternalLeading</td><td>内部间距（包含在 tmHeight 中），该间距通常被用于显示重音符号</td></tr><tr><td>tmExternalLeading</td><td>外部间距，这个值是字体设计者建议在两行文字间留出的空间大小</td></tr><tr><td>tmAveCharWidth</td><td>1. 字体中小写字符的平均宽度（一般定义为字母 x 的宽度） 2. 字体中大写字符的平均宽度一般是该值的 1.5 倍计算 3. 此值不包括字体所需要的加粗和倾斜字符</td></tr><tr><td>tmMaxCharWidth</td><td>字体中最宽字符的宽度</td></tr><tr><td>tmWeight</td><td>字体的粗细轻重程度</td></tr><tr><td>tmOverhang</td><td>加入某些拼接字体上的附加高度</td></tr><tr><td>tmDigitizedAspectX</td><td>字体设计所针对的设备水平方向</td></tr><tr><td>tmDigitizedAspectY</td><td>字体设计所针对的设备垂直方向</td></tr><tr><td>tmFirstChar</td><td>为字体定义的第一个字符</td></tr><tr><td>tmLastChar</td><td>为字体定义的最后一个字符</td></tr><tr><td>tmDefaultChar</td><td>字体中所没有字符的替代字符</td></tr><tr><td>tmBreakChar</td><td>定义文本对齐截断操作所显示的字符</td></tr><tr><td>tmItalic</td><td>如果该值非零，则为斜体字体</td></tr><tr><td>tmUnderlined</td><td>如果该值非零，则为带下横线字体</td></tr><tr><td>tmStruckOut</td><td>如果该值非零，则为带删除线字体（字符中间画一条线）</td></tr><tr><td>tmPitchAndFamily</td><td>1. 如果低位为 0，表示等宽字体，小写和大写字母平均宽度一样 2. 如果低位为 1，表示变宽字体，大写字母是小写平均宽度的 3/2 倍</td></tr><tr><td>tmCharSet</td><td>字体的字符集</td></tr></tbody></table><h2 id="WNDCLASS-结构"><a href="#WNDCLASS-结构" class="headerlink" title="WNDCLASS 结构"></a>WNDCLASS 结构</h2><p>​        Windows 的窗口总是基于窗口类来创建的，窗口类同时确定了处理窗口消息的窗口过程（回调函数）。</p><p>​        在创建应用程序窗口之前，必须调用 RegisterClass 函数来注册窗口类。该函数只需要一个参数，即指向 WNDCLASS 窗口类的指针。因为 WNDCLASS 类包含了窗口所拥有的基本属性。</p><h3 id="结构原型：-4"><a href="#结构原型：-4" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSW</span> &#123;</span></span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;</span><br><span class="line">    <span class="keyword">int</span>         cbClsExtra;</span><br><span class="line">    <span class="keyword">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;</span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;</span><br><span class="line">    LPCWSTR     lpszMenuName;</span><br><span class="line">    LPCWSTR     lpszClassName;</span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-4"><a href="#成员解析：-4" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>style</td><td>指定窗口类型，各种“类风格”（详见下方↓）可以使用按位或操作符组合起来</td></tr><tr><td>lpfnWndProc</td><td>指定窗口过程（必须是回调函数）</td></tr><tr><td>cbClsExtra</td><td>预留的额外空间，一般为 0</td></tr><tr><td>cbWndExtra</td><td>预留的额外空间，一般为 0</td></tr><tr><td>hInstance</td><td>应用程序的实例句柄</td></tr><tr><td>hIcon</td><td>为所有基于该窗口类的窗口设定一个图标</td></tr><tr><td>hCursor</td><td>为所有基于该窗口类的窗口设定一个鼠标指针</td></tr><tr><td>hbrBackground</td><td>指定窗口背景色</td></tr><tr><td>lpszMenuName</td><td>指定窗口菜单</td></tr><tr><td>lpszClassName</td><td>指定窗口类名</td></tr></tbody></table><h3 id="style-类风格解析"><a href="#style-类风格解析" class="headerlink" title="style 类风格解析"></a><strong>style 类风格解析</strong></h3><table><thead><tr><th><strong>类风格</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>CS_VREDRAW</td><td>移动或者调整窗口的高度（垂直方向）时，重绘整个窗口</td></tr><tr><td>CS_HREDRAW</td><td>移动或者调整窗口的宽度（水平方向）时，重绘整个窗口</td></tr><tr><td>CS_DBLCLKS</td><td>当用户光标在窗口内双击时，允许发送双击消息给窗口过程</td></tr><tr><td>CS_OWNDC</td><td>给予每个窗口实例分配一个唯一的 DC（注意，尽管这样是很方便，但它必须慎重使用，因为每个 DC 大约要占 800 个字节的内存）</td></tr><tr><td>CS_CLASSDC</td><td>该窗口类的所有窗口实例都共享一个窗口类 DC</td></tr><tr><td>CS_PARENTDC</td><td>1. 将子窗口的裁剪区域设置到父窗口的 DC 中去，这样子窗口便可以在父窗口上绘制自身。（注意，这是子窗口从系统缓存中获取 DC，而不是使用父窗口的 DC。） 2. 指定该风格可以提高系统性能</td></tr><tr><td>CS_NOCLOSE</td><td>禁止系统菜单的关闭选项</td></tr><tr><td>CS_SAVEBITS</td><td>1. 以位图形式保存被该窗口遮挡的屏幕部分，当给窗口移动以后，系统便可以用该保存的位图恢复屏幕移动的相应部分，从而系统不用向被该窗口遮挡的窗口发送 WM_PAINT 消息 2. 该特性对于菜单类型的窗口比较合适，因为它通常是简短的显示一下之后便消失 3. 设置该特性将增加显示该窗口的时间，因为它通常要先分配保存位图的内存</td></tr><tr><td>CS_BYTEALIGNCLIENT</td><td>在字节边界上（在 x 方向上）定位窗口的用户区域的位置</td></tr><tr><td>CS_BYTEALIGNWINDOW</td><td>在字节边界上（在 x 方向上）定位窗口的位置</td></tr><tr><td>CS_GLOBALCLASS</td><td>1. 当调用 CreateWindow 或 CreateWindowEx 函数来创建窗口时允许它的 hInstance 参数和注册窗口类时传递给 RegisterClass 的 hInstance 参数不同 2. 如果不指定该风格，则这两个 hInstance 必须相同</td></tr></tbody></table><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="GET-X-LPARAM-和-GET-Y-LPARAM-宏"><a href="#GET-X-LPARAM-和-GET-Y-LPARAM-宏" class="headerlink" title="GET_X_LPARAM 和 GET_Y_LPARAM 宏"></a>GET_X_LPARAM 和 GET_Y_LPARAM 宏</h2><p>原文链接（GET_X_LPARAM）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632654(v=vs.85).aspx">传送门</a></p><p>原文链接（GET_Y_LPARAM）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632655(v=vs.85).aspx">传送门</a></p><h3 id="宏功能："><a href="#宏功能：" class="headerlink" title="宏功能："></a><strong>宏功能：</strong></h3><p>通过 lParam 参数获得相关消息触发的坐标 (x , y)</p><h3 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a><strong>宏定义：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GET_X_LPARAM</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">……</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GET_Y_LPARAM</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-27"><a href="#参数解析：-27" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lParam</td><td>将要被转换的 lParam 参数</td></tr></tbody></table><h3 id="返回值：-27"><a href="#返回值：-27" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>GET_X_LPARAM(lParam) 返回坐标的 x 值；</p></li><li><p>GET_Y_LPARAM(lParam) 返回坐标的 y 值。</p></li></ol><h3 id="重要备注："><a href="#重要备注：" class="headerlink" title="重要备注："></a><strong>重要备注：</strong></h3><ol><li><p>使用该宏需要包含头文件：windowsx.h。</p></li><li><p>不要再使用 LOWORD 和 HIWORD 去获取鼠标的坐标了，因为在多显示器的情况下会得到错误的坐标。</p></li></ol><h2 id="SUCCEEDED-和-FAILED-宏"><a href="#SUCCEEDED-和-FAILED-宏" class="headerlink" title="SUCCEEDED 和 FAILED 宏"></a>SUCCEEDED 和 FAILED 宏</h2><p>原文链接（SUCCEEDED）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687197(v=vs.85).aspx">传送门</a></p><p>原文链接（FAILED）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms693474(v=vs.85).aspx">传送门</a></p><h3 id="宏功能：-1"><a href="#宏功能：-1" class="headerlink" title="宏功能："></a><strong>宏功能：</strong></h3><p>SUCCEEDED 宏表示测试成功，FAILED 宏表示测试失败。</p><h3 id="宏原型："><a href="#宏原型：" class="headerlink" title="宏原型："></a><strong>宏原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SUCCEEDED</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HRESULT hr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">……</span><br><span class="line"><span class="function">BOOL <span class="title">FAILED</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HRESULT hr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-28"><a href="#参数解析：-28" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hr</td><td>1. 状态码 2. 该值可以是 HRESULT 或 SCODE 类型 3. 非负数表示成功 4. 负数表示失败</td></tr></tbody></table><h3 id="返回值：-28"><a href="#返回值：-28" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果 hr 的值大于等于 0，则结果为 TRUE；</p></li><li><p>如果 hr 的值小于 0，则结果为 FALSE。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WinAPI文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> WinAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客美化</title>
      <link href="2021/03/14/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
      <url>2021/03/14/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="更改公告内容-gif图片"><a href="#更改公告内容-gif图片" class="headerlink" title="更改公告内容+gif图片"></a>更改公告内容+gif图片</h1><p>在主题配置文件中搜索 card_announcement </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span> <span class="string">//公告内容</span></span><br></pre></td></tr></table></figure><p>更改后</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">欢迎来到yui1111的博客！&lt;img</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/rigodlee/BLOGCDN/img/20150404H5648_ZuzhL.gif&quot;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://imgtu.com/i/603iAU"><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/03/14/603iAU.png" alt="603iAU.png"></a></p><h1 id="更换头像与背景图像"><a href="#更换头像与背景图像" class="headerlink" title="更换头像与背景图像"></a>更换头像与背景图像</h1><p>打开主题配置文件，搜索<code>Avatar</code>往下一排全是关于博客头像背景图片之类的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github 个人博客搭建</title>
      <link href="2021/03/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>2021/03/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="会使用到的工具"><a href="#会使用到的工具" class="headerlink" title="会使用到的工具"></a>会使用到的工具</h2><ul><li><p>node.js</p></li><li><p>sublime</p></li><li><p>git</p></li></ul><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>首先我们首先在node.js的<a href="https://nodejs.org/zh-cn/download/">官网</a>下载</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHuC9.png" alt="1"></p><p>使用其他平台的用户可根据自己的需求下载哦（图片为Windows平台）</p><p>下载完成后，一路next就能安装成功。</p><h4 id="检查安装情况"><a href="#检查安装情况" class="headerlink" title="检查安装情况"></a>检查安装情况</h4><ul><li><strong>node.js</strong></li></ul><p>打开Windows 命令处理程序输入node -v</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHm4J.png" alt="2"></p><p>出现版本号即为安装成功</p><ul><li><strong>npm</strong></li></ul><p>继续在Windows 命令处理程序输入npm -v</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHABT.png" alt="3"></p><p>出现版本号即为安装成功</p><h3 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h3><p>直接到<a href="http://www.sublimetext.com/3">sublime官网</a>下载。建议安装在与博客文件同一文件夹中。</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="下载和安装-1"><a href="#下载和安装-1" class="headerlink" title="下载和安装"></a>下载和安装</h4><ul><li><p><strong>下载</strong></p><p>下载git可直接去git**<a href="">官网</a>**下载。进入官网后点击download。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHMg1.png" alt="4"></p></li><li><p><strong>安装</strong></p></li></ul><ol><li><p>下载完成后打开进入此界面（因为我已经安装过git所以图中下面会多显示Only show new options ）</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHQjx.png" alt="5"></p></li><li><p>安装路径——选择自己想安装的位置就行。</p></li><li><p>安装git组件，图中框起来的为默认选中的组件，根据自己的需求勾选好后，选择下一步。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqH1u6.png" alt="6"></p></li><li><p>菜单文件夹，直接选择默认就行。</p></li><li><p>选择git的默认编辑器</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqH3DK.png" alt="7"></p></li><li><p>选择仓库的初始名称。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqH8HO.png" alt="8"></p></li><li><p>修改系统的环境变量</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHYUe.png" alt="9"></p></li><li><p>SSL的证书选择</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHt4H.png" alt="10"></p></li><li><p>配置行尾结束符，默认为unix格式，可根据自己的情况选择</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHUCd.png" alt="11"></p></li><li><p>配置终端仿真，建议第一个</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHa8A.png" alt="12"></p></li><li><p>其他配置，默认即可。</p></li><li><p>安装完成后点击鼠标右键会出现<strong>Git GUI Here</strong>和<strong>Git Bash Here</strong>两个选项</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHwvt.png" alt="13"></p></li></ol><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>在自己想安装hexo的位置新建一个叫blog的文件夹。创建完成后使用Windows命令窗口进入blog的文件夹中。</p><p>使用npm命令安装hexo，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHdgI.png" alt="14"></p><p>安装完成后再输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog  &#x2F;&#x2F;blog可替换成你想要的名字</span><br></pre></td></tr></table></figure><p>进行初始化</p><p>​    <img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHBKP.png" alt="15"></p><p>出现 Start blogging with Hexo！即为成功。</p><p>进入第二个一创建好的blog文件夹，按顺序输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello Hexo&#x2F;&#x2F;新建一篇名为“hello Hexo”的博客</span><br><span class="line">hexo g&#x2F;&#x2F;生成静态文件</span><br><span class="line">hexo s&#x2F;&#x2F;本地部署预览</span><br></pre></td></tr></table></figure><p>完成后输入localhost:4000可进行本地访问。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHJED.png" alt="16"></p><h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><h3 id="GitHub仓库创建"><a href="#GitHub仓库创建" class="headerlink" title="GitHub仓库创建"></a>GitHub仓库创建</h3><p>首先要有一个GitHub的账号。</p><p>登录后点击左上角的new，创建新的仓库。进入仓库后输入仓库名称，必须要与owner下的名称一致，输入完成后即可（因为我之前已经创建过了仓库，所以提示）</p><p>​    <img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHK3R.png" alt="17"></p><h3 id="GitHubSSH配置"><a href="#GitHubSSH配置" class="headerlink" title="GitHubSSH配置"></a>GitHubSSH配置</h3><p>打开git bash输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config –global user.email “xxx@qq.com“ &#x2F;&#x2F;填写注册github的邮箱</span><br><span class="line"></span><br><span class="line">git config –global user.name “xxxx” &#x2F;&#x2F;github 用户名</span><br><span class="line"></span><br><span class="line">ssh-keygen &#x2F;&#x2F;输入完这个就一致enter就行了</span><br></pre></td></tr></table></figure><p>完成后进入用户目录下的.ssh文件夹，打开id_rsa.pub，复制里面的内容。</p><p>进入GitHub，鼠标移动到右上角头像处，点击settings，之后再点击左边 SSH and GPG keys。创建一个新的SSH即可。</p><h3 id="Hexo与GitHub连接"><a href="#Hexo与GitHub连接" class="headerlink" title="Hexo与GitHub连接"></a>Hexo与GitHub连接</h3><p>在站点文件夹中打开_config.yml，将Deployment改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;yui1111&#x2F;yui1111.github.io.git &#x2F;&#x2F;改为自己GitHub中的https链接</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqLBK1.png" alt="18"></p><p>将”url”后改为“<a href="https://github项目名&quot;/">https://github项目名&quot;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;example.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;yui1111.github.io &#x2F;&#x2F;改这个</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure><p>安装插件，上传博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">git config --global user.email &quot;github邮箱&quot;</span><br><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>输入网址如<a href="https://yui1111.github.io后等待一会即可进入./">https://yui1111.github.io后等待一会即可进入。</a></p><p>至此搭建过程结束。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
