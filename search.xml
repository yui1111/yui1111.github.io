<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/11/19/Untitled/"/>
      <url>2021/11/19/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程笔记4</title>
      <link href="2021/11/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/"/>
      <url>2021/11/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-临界区"><a href="#Windows-临界区" class="headerlink" title="Windows 临界区"></a><strong>Windows 临界区</strong></h2><p>windows 临界区与 <code>std::mutex</code> 类似，效果几乎可以等同于 <code>std::mutex</code></p><p>不过 Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。</p><p><code>std::mutex</code> 则不允许同一个线程重复加锁。</p><p>windows中的临界区同 <code>mutex</code> 一样，可以保护一个代码段。但 windows 的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。</p><h2 id="自动析构技术"><a href="#自动析构技术" class="headerlink" title="自动析构技术"></a><strong>自动析构技术</strong></h2><p>C++：<code>lock_guard</code> 防止忘了释放信号量，自动释放<br>windows：可以写个类自动释放临界区：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWinLock</span> &#123;</span>        </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CWinLock(CRITICAL_SECTION *pCritmp) : m_pCritical(pCritmp)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(m_pCritical);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CWinLock()</span><br><span class="line">    &#123;</span><br><span class="line">        LeaveCriticalSection(m_pCritical);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CRITICAL_SECTION *m_pCritical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述这种类 RAII 类（Resource Acquisition is initialization），即”资源获取及初始化“。容器，智能指针属于这种类。</p><h2 id="递归独占互斥量-std-recursive-mutex"><a href="#递归独占互斥量-std-recursive-mutex" class="headerlink" title="递归独占互斥量 std::recursive_mutex"></a><strong>递归独占互斥量 std::recursive_mutex</strong></h2><p><code>std::mutex</code> 独占式互斥量</p><p><code>std::recursive_mutex</code>：允许在同一个线程中同一个互斥量多次被 <code>lock()</code> ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比 <code>std::mutex</code> 低。</p><p>如果你真的用了 <code>recursive_mutex</code> 要考虑代码是否有优化空间，如果能调用一次 <code>lock()</code> 就不要调用多次。</p><h2 id="带超时的互斥量-std-timed-mutex-和-std-recursive-timed-mutex"><a href="#带超时的互斥量-std-timed-mutex-和-std-recursive-timed-mutex" class="headerlink" title="带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex"></a><strong>带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex</strong></h2><p>std::timed_mutex 与 std::mutex 类似，只是多了几个成员函数</p><ol><li><p><code>try_lock_for()</code>: 参数是一段时间，等待一段时间，如果我拿到了锁，或者等待超过时间没拿到锁，就继续流程，返回值为 <code>bool</code> 类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex my_mutex;</span><br><span class="line"><span class="keyword">if</span>(my_mutex.try_lock_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>)) <span class="comment">// 等待 100ms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在规定时间内返回 <code>true</code> 否则返回 <code>false</code></p></li><li><p><code>try_lock_until()</code>: 参数是一个未来的时间点，在这个现在这个时间到指定的未来时间内拿到锁，或者超过指定的时间没拿到锁就会继续流程，返回值为 <code>bool</code> 类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex my_mutex;</span><br><span class="line"><span class="keyword">if</span>(my_mutex.try_lock_until(chrono::steady_clock::now() + <span class="number">10</span>s))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的区别就是一个参数是时间段，一个参数是时间点</p></li></ol><p><code>std::recursive_timed_mutex</code>：是待超时的<strong>递归</strong>独占互斥量 与 <code>std::recursive_mutex</code> 类似</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程笔记3</title>
      <link href="2021/11/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/"/>
      <url>2021/11/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h2 id="std-future其他的成员函数wait-for"><a href="#std-future其他的成员函数wait-for" class="headerlink" title="std::future其他的成员函数wait_for()"></a><strong>std::future其他的成员函数wait_for()</strong></h2><p><code>wait_for()</code> 返回的是一个枚举类型 <code>std::future_status</code></p><p><code>std::future_status</code> 是枚举类型，表示异步任务的执行状态。类型的取值有</p><ol><li><code>std::future_status::timeout</code> : 表示线程还没执行完</li><li><code>std::future_status::ready</code> ：表示线程在规定时间内完成</li><li><code>std::future_status::deferred </code> : 表示 <code>std::async()</code> 使用了 <code>std::launch::deferred</code></li></ol><p><code>wait_for()</code> 用于卡住当前流程，等待 <code>std::async()</code> 的异步任务运行一段时间，然后返回其状态 <code>std::future_status</code>。如果 <code>std::async()</code> 的参数是 <code>std::launch::deferred</code>（延迟执行），则不会卡住主流程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(mythread);</span><br><span class="line"><span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));   <span class="comment">// 等待1秒去执行子线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(status == <span class="built_in">std</span>::future_status::timeout) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 超时，表示线程还没执行完</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time out!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="built_in">std</span>::future_status::ready)   <span class="comment">// 表示线程成功返回</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread successfully completed! return value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="built_in">std</span>::future_status::deferred)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 async 的第一个参数被设置为 std::lauch::deferred，则条件成立</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread is delayed&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我么也可以通过 <code>wait_for()</code> 来判断系统通过 <code>std::async(mythread)</code> 创建的异步任务是否创建了线程</p><p>如果进入 <code>else if(status == std::future_status::deferred)</code> 则表示系统资源紧张而直接在主线程中调用了线程入口函数 <code>mythread()</code></p><h2 id="std-shard-future类模板"><a href="#std-shard-future类模板" class="headerlink" title="std::shard_future类模板"></a><strong>std::shard_future类模板</strong></h2><p><code>std::future</code> 与 <code>std::shared_future</code> 不同</p><ol><li><p><code>std::future</code> 的 <code>get()</code> 成员函数是转移数据，也就是说采用了移动语义</p><p>我们可以使用 <code>result</code> 中的 <code>valid()</code> 函数来判断是否还有值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async([]&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line">result.get();</span><br><span class="line"><span class="keyword">bool</span> isget = result.valid();</span><br></pre></td></tr></table></figure><p><code>isget == false</code> 则说明 <code>result</code> 没有值</p></li><li><p><code>std::shared_future</code> 的 <code>get()</code> 成员函数是复制数据</p></li></ol><h2 id="std-atomic原子操作"><a href="#std-atomic原子操作" class="headerlink" title="std::atomic原子操作"></a><strong>std::atomic原子操作</strong></h2><h3 id="原子操作概念引出范例"><a href="#原子操作概念引出范例" class="headerlink" title="原子操作概念引出范例"></a>原子操作概念引出范例</h3><p>两个线程同时进行加法运算，导致最后结果不准确，因为线程的不断切换中会打断代码导致没运行完整<br>通过互斥量来进行加锁解锁才会让加法计算运行准确<br>原子操作可以理解为：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式<br>也就是说：是在多线程中 不会被打断的程序执行片段，原子操作，效率上比互斥量更胜一筹<br>互斥量的加锁一般是针对一个代码段（多行代码），二原子操作针对的一般都是一个变量，而不是一个代码段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;<span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g_i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;g_i = &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理来说 <code>g_i</code> 应该为 200000 ，但因为线程的切换导致不会加到 200000，且每次结果都不会相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/19/MIzc1ifugsWJl8H.png" alt="image-20211119220525072"></p><h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h3><p>std::atomic 是一个类模板，用于封装某个类型的值，有两种初始化方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">0</span>&#125;;<span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure><p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，<strong>不可能出现半完成状态</strong></p><p>一般atomic原子操作，针对<code>++，--，+=，-=，&amp;=，|=，^=</code>是支持的，其他操作不一定支持。</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程笔记2</title>
      <link href="2021/11/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/"/>
      <url>2021/11/17/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h2 id="std-async-函数模板-与-std-future-类模板"><a href="#std-async-函数模板-与-std-future-类模板" class="headerlink" title="std::async 函数模板 与 std::future 类模板"></a><strong>std::async 函数模板 与 std::future 类模板</strong></h2><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async()"></a>std::async()</h3><p><code>std::async()</code> 是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个 <code>std::future</code> 对象，<code>std::future</code> 是一个类模板</p><ul><li><p>什么叫 “启动一个异步任务”</p><p>启动一个异步任务就是自动创建一个线程并开始执行对应的线程入口函数，它返回一个 <code>std::future</code> 对象</p><p>这个对象里面就含有线程入口函数所返回的结果（线程返回的结果）我们可以通过调用 <code>future</code> 对象的成员函数 <code>get()</code> 来获取结果</p></li><li><p>函数中可以额外的传递一个参数</p><p>该参数类型是 <code>std::lunnch</code> 类型（枚举）来达到一些目的</p><ol><li><p><code>std::launch::deferred</code> 表示线程入口函数调用被延迟到 <code>std::future</code> 的 <code>wait()</code> 或 <code>get()</code> 函数时调用才执行，延迟调用，<strong>并且没有创建新线程</strong>，是在<strong>主线程中调用线程入口函数</strong></p><p>如果 <code>wait()</code> 或 <code>get()</code> 没有被调用 则线程<strong>不会被执行</strong></p></li><li><p><code>std::launch::async</code> 在调用 <code>async()</code> 函数的时候就开始创建线程,不会等待 <code>get()</code> </p></li></ol></li></ul><h3 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h3><p><code>std::future</code> 提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：<code>future</code> 中保存着一个值，这个值是在将来的某个时刻能够拿到。</p><p><code>std::future</code> 对象的 <code>get()</code> 成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像 <code>join()</code>。但是，它是可以获取结果的。</p><p><code>std::future</code> 对象的 <code>wait()</code> 成员函数，用于等待线程返回，本身并不返回结果，这个效果和 <code>std::thread</code> 的 <code>join()</code> 更像。</p><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a><strong>具体实例</strong></h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dr</span><span class="params">(<span class="number">5000</span>)</span></span>; <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(dr);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">    <span class="keyword">int</span> tmpper = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main() threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(&amp;A::mythread, &amp;a, tmpper);   <span class="comment">// 第二个参数是对象引用才能保证线程里用的是同一个对象</span></span><br><span class="line"><span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::deferred, &amp;A::mythread, &amp;a, tmpper);</span></span><br><span class="line">    <span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::async, &amp;A::mythread, &amp;a, tmpper);    </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;return value = &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main() End!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用 <code>std::launch::async</code> </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/17/ZetKAFvsJl3O8BC.png" alt="image-20211117190358167"></p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/17/uzofJ91tl5maQsP.png" alt="image-20211117190444180"></p><p>​        <code>async()</code><strong>强制</strong>创建了一个新的线程</p><ol start="2"><li><p>使用 <code>std::launch::deferred</code> </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/11/17/ufvaI45oZEer1wp.png" alt="image-20211117190712373"></p><p>则是在主线程中<strong>调用了</strong>这个函数，并没有创建新的线程</p></li><li><p>使用 <code>std::launch::deferred | std::launch::async</code></p><p>这里这个 <code>|</code> ： 这意味着 <code>std::async</code> 的行为可能是 <strong>创建新线程并立即执行</strong> 或者 <strong>创建新线程并且延迟调用</strong></p><p>系统<strong>自动决定</strong>异步还是同步方式运行</p></li><li><p>不带额外参数</p><p>与 3. 中<strong>效果完全一致</strong></p></li></ol><h3 id="std-async和std-thread-区别"><a href="#std-async和std-thread-区别" class="headerlink" title="std::async和std::thread()区别"></a><strong>std::async和std::thread()区别</strong></h3><p><code>std::thread()</code> 如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）<br><code>std::async()</code> 创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</p><p>由于系统资源限制：</p><ol><li>如果用 <code>std::thread</code> 创建线程太多，则可能创建失败，系统报告异常崩溃</li><li>如果用 <code>std::async</code> 一般就不会报异常不会崩溃，因为，如果系统资源紧张导致无法创建新线程的时候，<code>std::async</code> 这种不加额外参数的调用就不会创建新线程。而是后续调用了<code>.get()</code> 来请求结果，那么这个异步任务就运行在执行这条 <code>get()</code> 语句所在的线程上</li></ol><h2 id="std-packaged-task-类模板"><a href="#std-packaged-task-类模板" class="headerlink" title="std::packaged_task 类模板"></a><strong>std::packaged_task 类模板</strong></h2><p><code>std::packaged_task</code>: 打包任务，把任务包装起来，可用于包装各种<strong>可调用对象</strong>的模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dr</span><span class="params">(<span class="number">5000</span>)</span></span>; <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(dr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; mypt(mythread);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt), <span class="number">1</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::future</code> 对象里包含有线程入口函数的返回结果，<code>result</code> 保存 <code>mythread</code> 的返回值.</p><p>我们也可以吧函数换成 lambda 表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">([](<span class="keyword">int</span> mypar) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::chrono::milliseconds dr(<span class="number">5000</span>); <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(dr);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::packaged_task</code>也是可调用对象</p><p>lambda 表达式的直接调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">([](<span class="keyword">int</span> mypar) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() start threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::chrono::milliseconds dr(<span class="number">5000</span>); <span class="comment">// 定义一个5s的时间 模拟工作了这么久</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::this_thread::sleep_for(dr);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread() end threadID = &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">mypt(<span class="number">150</span>);<span class="comment">// 直接调用，并没有创建线程</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="使用容器保存任务"><a href="#使用容器保存任务" class="headerlink" title="使用容器保存任务"></a>使用容器保存任务</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; my_tasks;</span><br><span class="line">my_tasks.emplace_back(<span class="built_in">std</span>::move(mypt)); <span class="comment">// 使用移动语义，加入进去后 mypt 就空了</span></span><br><span class="line"><span class="comment">// 从容器中取出 packaged_task</span></span><br><span class="line"><span class="keyword">auto</span> iter = my_tasks.begin();</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt2 = <span class="built_in">std</span>::move(*iter);  <span class="comment">// move 后 容器中还有一项，并没有被删除</span></span><br><span class="line">my_tasks.erase(iter);   <span class="comment">// 删除第一个元素，迭代器已经失效，所以后续代码不能再使用 iter</span></span><br><span class="line">mypt2(<span class="number">150</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt2.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="std-promise-类模板"><a href="#std-promise-类模板" class="headerlink" title="std::promise 类模板"></a><strong>std::promise 类模板</strong></h2><p>通过 <code>promise</code> 保存一个值，在将来某个时刻我们通过把一个 <code>future</code> 绑定到 <code>promise</code> 上来得到这个绑定的值</p><p>可以通过 <code>promise</code> 来实现两个线程中的数据传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; myprom;   <span class="comment">// 声明一个 std::promise 对象，保存值为int</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread, <span class="built_in">std</span>::ref(myprom), <span class="number">180</span>)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; ful = myprom.get_future();<span class="comment">// promise 和 future 绑定，用于获取线程返回值</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(mythread2, <span class="built_in">std</span>::ref(ful))</span></span>;<span class="comment">// 两个线程中数据传递</span></span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程笔记</title>
      <link href="2021/11/16/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>2021/11/16/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="条件变量-std-condition-variable-以及成员函数"><a href="#条件变量-std-condition-variable-以及成员函数" class="headerlink" title="条件变量 std::condition_variable 以及成员函数"></a>条件变量 std::condition_variable 以及成员函数</h2><h3 id="条件变量condition-variable"><a href="#条件变量condition-variable" class="headerlink" title="条件变量condition_variable"></a><strong>条件变量condition_variable</strong></h3><p>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable my_cond;</span><br></pre></td></tr></table></figure><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a><strong>wait()</strong></h3><p><code>wait()</code>第一个参数为<code>std::unique_lock&lt;std::mutex&gt;</code>，第二个参数为可选参数【<strong>可调用对象</strong>如 lambda 表达式 或者 函数】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 收集玩家命令线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;inMsgRecvQueue() insert &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sb</span><span class="params">(my_mutex1)</span></span>;</span><br><span class="line">            </span><br><span class="line">            msgRecvQueue.emplace_back(i);</span><br><span class="line">            my_cond.notify_all();   <span class="comment">// 尝试把 outMsgRecvQueue() 中的 wait() 唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出命令线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> command = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sb</span><span class="params">(my_mutex1)</span></span>;</span><br><span class="line">            my_cond.wait(sb,[<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span>(!msgRecvQueue.empty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 一旦走到这 队列中一定会有数据</span></span><br><span class="line">            command = msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            sb.unlock(); <span class="comment">// 提前 unlock ，以免影响效率</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread ID = &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; outMsgRecvQueue Start And Get Value! = &quot;</span> &lt;&lt; command &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">// end while</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用于收集玩家发送过来的命令</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">    <span class="built_in">std</span>::mutex my_mutex1;   <span class="comment">// 创建一个互斥量</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable my_cond;    <span class="comment">// 生成一个条件变量对象    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>如果有第二个参数</p><ul><li><p>如果第二个参数返回值为 <code>false</code> 那么 <code>wait()</code> 将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用 <code>notify_one()</code> 或者 <code>notify_all()</code> 成员函数为止</p></li><li><p>如果第二个参数返回值为 <code>true</code> 那么 <code>wait()</code> 将重新解锁上互斥量，并继续执行之后的代码</p></li></ul></li><li><p>如果没有第二个参数</p><ul><li>就与第二个参数为 <code>false</code> 效果相同，将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用 <code>notify_one()</code> 或者 <code>notify_all()</code> 成员函数为止</li></ul></li></ol><p>当唤醒其他线程中的 <code>wait()</code> 后</p><ol><li><code>wait()</code> 不断尝试重新获取互斥量的锁，如果获取不到 就会一直反复获取锁，如果获取到就继续执行 2.</li><li><ul><li>如果 <code>wait()</code> 有第二个参数（当前为 lambda 表达式）且返回值为 <code>false</code> 那 <code>wait()</code> 又对<strong>互斥量解锁</strong>并堵塞到这，等待再次被唤醒</li><li>如果 <code>wait()</code> 有第二个参数（当前为 lambda 表达式）且返回值为 <code>true</code> 则 <code>wait()</code> 返回，<strong>将互斥量再次上锁</strong> 流程继续（此时互斥量已经被锁住）</li><li>如果 没有第二个参数 <code>wait()</code> <strong>将互斥量再次上锁</strong> 直接返回，流程继续</li></ul></li></ol><h3 id="notify-one-与-notify-all"><a href="#notify-one-与-notify-all" class="headerlink" title="notify_one() 与 notify_all()"></a><strong>notify_one()</strong> 与 <strong>notify_all()</strong></h3><ul><li><code>notify_one()</code>唤醒一个线程中的 <code>wait()</code></li><li><code>notify_all()</code> 唤醒所有线程中的 <code>wait()</code></li></ul><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a><strong>深入思考</strong></h2><p>上面的代码可能导致出现一种情况：<br>因为<code>outMsgRecvQueue()</code>与<code>inMsgRecvQueue()</code>并不是一对一执行的，所以当程序循环执行很多次以后，可能在<code>msgRecvQueue</code> 中已经有了很多消息，但是，<code>outMsgRecvQueue</code>还是被唤醒一次只处理一条数据。这时可以考虑把<code>outMsgRecvQueue</code>多执行几次，或者对<code>inMsgRecvQueue</code>进行限流。</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinAPI文档</title>
      <link href="2021/10/26/WinAPI%E6%96%87%E6%A1%A3/"/>
      <url>2021/10/26/WinAPI%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>注：转载自<a href="https://fishc.com.cn/forum-207-1.html">小甲鱼-鱼c论坛</a> ，归纳一下方便自己学习//SetScrollRange</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="BeginPaint"><a href="#BeginPaint" class="headerlink" title="BeginPaint"></a>BeginPaint</h2><h3 id="函数功能："><a href="#函数功能：" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>BeginPaint 函数为指定窗口进行绘画作准备，并用将和绘画有关的信息填充到一个 <a href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>中。</p><h3 id="API-函数原型："><a href="#API-函数原型：" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">BeginPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HWND hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPPAINTSTRUCT lpPaint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hwnd</td><td>需要重新绘制的窗口句柄</td></tr><tr><td>lpPaint</td><td>指向 <a href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>的指针，用于存放绘画相关的信息</td></tr></tbody></table><h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功，返回值是指定窗口的“显示设备描述表”句柄；</p></li><li><p>如果函数失败，返回值是 NULL，表明没有得到显示设备的内容。</p></li></ol><h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>BeginPaint 函数自动设置显示设备内容的剪切区域，而排除任何更新区域外的区域。该更新区域可以通过 InvalidateRect 或 InvalidateRgn 函数设置，也可以是系统在改变大小、移动、创建、滚动后设置的，或者其他的影响客户区的操作来设置的。</p></li><li><p>如果更新区域被标记为可擦除的，BeginPaint 发送一个 WM_ERASEBKGND 消息给窗口。</p></li><li><p>一个应用程序除了响应 WM_PAINT 消息外，不应该调用 BeginPaint。</p></li><li><p>每次调用 BeginPaint 都应该有相应的 EndPaint 函数。</p></li><li><p>如果被绘画的客户区中有一个 caret（caret：插入符。是窗口客户区中的一个闪烁的线，块，或位图。插入符通常表示文本或图形将被插入的地方。即一闪一闪的光标），BeginPaint 自动隐藏该符号，而保证它不被擦除。</p></li><li><p>如果窗口类有一个背景刷，BeginPaint 使用这个刷子来擦除更新区域的背景。</p></li></ol><h2 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h2><h3 id="函数功能：-1"><a href="#函数功能：-1" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>CreateWindow 函数创建一个重叠式窗口、弹出式窗口或子窗口。它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。函数也指该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。</p><p>若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数。</p><h3 id="API-函数原型：-1"><a href="#API-函数原型：-1" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code>说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND WINAPI <span class="title">CreateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpClassName,    <span class="comment">// 窗口类名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpWindowName,   <span class="comment">// 窗口标题</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD dwStyle,          <span class="comment">// 窗口风格，或称窗口格式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> x,                  <span class="comment">// 初始 x 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> y,                  <span class="comment">// 初始 y 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> nWidth,             <span class="comment">// 初始 x 方向尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">int</span> nHeight,            <span class="comment">// 初始 y 方向尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWndParent,        <span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HMENU hMenu,            <span class="comment">// 窗口菜单句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HINSTANCE hInstance,    <span class="comment">// 程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPVOID lpParam          <span class="comment">// 创建参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-1"><a href="#参数解析：-1" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpClassName</td><td>1. 窗口类名称，可以是一个指向 NULL 结束的字符串或一个整型数值 2. 如果是字符串，它指定了窗口的类名。这个类名可以是任何用函数 RegisterClass 注册的类名，或是任何预定义的控制类名 3. 如是一个整型量，它是由此前调用 theGlobalAddAtom 函数产生的全局量。这个小于 0xC000 的 16 位数必须是 lpClassName 参数字的低 16 位，该参数的高位必须是 0</td></tr><tr><td>lpWindowName</td><td>1. 窗口标题，一个指向 NULL 结束的字符串指针 2. 如果窗口风格指定了标题条，由 lpWindowName 指向的窗口标题将显示在标题条上 3. 当使用 Createwindow 函数来创建控制例如按钮，选择框和静态控制时，可使用 lpWindowName 来指定控制文本</td></tr><tr><td>dwStyle</td><td>指定创建窗口的风格（详见下方↓）</td></tr><tr><td>x</td><td>1. 指定窗口的初始水平位置（x 坐标） 2. 对一个层叠或弹出式窗口，x 参数是屏幕坐标系的窗口的左上角的初始 x 坐标 3. 对于子窗口，x 是子窗口左上角相对父窗口客户区左上角的初始 x 坐标 4. 如果该参数被设为 CW_USEDEFAULT 则系统为窗口选择缺省的左上角坐标并忽略 y 参数，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口或子窗口设定，则 x 和 y 参数被设为零。</td></tr><tr><td>y</td><td>1. 指定窗口的初始垂直位置（y 坐标） 2. 对一个层叠或弹出式窗口，y 参数是屏幕坐标系的窗口的左上角的初始 y 坐标 3. 对于子窗口，y 是子窗口左上角相对父窗口客户区左上角的初始 y 坐标 4. 对于列表框，y 是列表框客户区左上角相对父窗口客户区左上角的初始 y 坐标 5. 如果层叠窗口是使用 WS_VISIBLE 风格位创建的并且 x 参数被设为 CW_USEDEFAULT，则系统将忽略 y 参数</td></tr><tr><td>nWidth</td><td>1. 以设备单元指明窗口的宽度 2. 对于层叠窗口，nWidth 的值或是屏幕坐标的窗口宽度或是 CW_USEDEFAULT 3. 若 nWidth 是 CW_USEDEFAULT，则系统为窗口选择一个默认的高度和宽度（默认宽度为从初始 x 坐标开始到屏幕的右边界，缺省高度为从初始 y 坐标开始到目标区域的顶部。)，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口和子窗口设定 CW_USEDEFAULT 标志则 nWidth 和 nHeight 被设为零</td></tr><tr><td>nHeight</td><td>1. 以设备单元指明窗口的高度 2. 对于层叠窗口，nHeight 是屏幕坐标的窗口宽度 3. 若 nWidth 被设为 CW_USEDEFAULT，则系统忽略 nHeight 参数，自动为 nWidth 和 nHeight 设置默认参数</td></tr><tr><td>hWndParent</td><td>1. 指向被创建窗口的父窗口或所有者窗口的句柄 2. 若要创建一个子窗口或一个从属窗口，需提供一个有效的窗口句柄 3. 创建一个单纯的消息窗口，可以提供 HWND_MESSAGE 或提供一个己存在的消息窗口的句柄</td></tr><tr><td>hMenu</td><td>1. 指向窗口菜单句柄，或依据窗口风格指明一个子窗口标识 2. 对于层叠或弹出式窗口，hMenu 指定窗口使用的菜单：如果使用了菜单类，则 hMenu 可以为 NULL 3. 对于子窗口，hMenu 指定了该子窗口标识（一个整型量），一个对话框使用这个整型值将事件通知父类。应用程序确定子窗口标识，这个值对于相同父窗口的所有子窗口必须是唯一的</td></tr><tr><td>hInstance</td><td>与窗口相关联的模块实例的句柄</td></tr><tr><td>lpParam</td><td>1. 指向一个值的指针，该值传递给窗口 WM_CREATE 消息。该值通过在 IParam 参数中的 CREATESTRUCT 结构传递 2. 如果应用程序调用 CreateWindow 创建一个 MDI 客户窗口，则 lpParam 必须指向一个 CLIENTCREATESTRUCT 结构</td></tr></tbody></table><h3 id="dwStyle-窗口风格解析"><a href="#dwStyle-窗口风格解析" class="headerlink" title="dwStyle 窗口风格解析"></a><strong>dwStyle 窗口风格解析</strong></h3><table><thead><tr><th><strong>窗口风格</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>WS_BORDER</td><td>创建一个带边框的窗口</td></tr><tr><td>WS_CAPTION</td><td>创建一个有标题框的窗口（包含了 WS_BODER 风格）</td></tr><tr><td>WS_CHILD</td><td>创建一个子窗口，这个风格的窗口不能拥有菜单也不能与 WS_POPUP 风格合用</td></tr><tr><td>WS_CHILDWINDOW</td><td>与 WS_CHILD 相同</td></tr><tr><td>WS_CLIPCHILDREN</td><td>当在父窗口内绘图时，排除子窗口区域，在创建父窗口时使用这个风格</td></tr><tr><td>WS_CLIPSIBLINGS</td><td>1. 排除子窗口之间的相对区域，也就是，当一个特定的窗口接收到 WM_PAINT 消息时，WS_CLIPSIBLINGS 风格将所有层叠窗口排除在绘图之外，只重绘指定的子窗口 2. 如果未指定该风格，并且子窗口是层叠的，则在重绘子窗口的客户区时，就会重绘邻近的子窗口</td></tr><tr><td>WS_DISABLED</td><td>1. 创建一个初始状态为禁止的子窗口，一个禁止状态的窗口不能接受来自用户的输入信息 2. 在窗口创建之后，可以调用 EnableWindow 函数来启用该窗口</td></tr><tr><td>WS_DLGFRAME</td><td>创建一个带对话框边框风格的窗口，这种风格的窗口不能带标题条</td></tr><tr><td>WS_GROUP</td><td>1. 指定一组“控制窗口”的第一个“控制窗口” 2. 这个“控制窗口”组由第一个“控制窗口”和随后定义的“控制窗口”组成，自第二个“控制窗口”开始每个“控制窗口”具有 WS_GROUP 风格 3. 每个组的第一个“控制窗口”带有 WS_TABSTOP 风格，从而使用户可以在组间移动 4. 用户随后可以使用光标在组内的控制间改变键盘焦点</td></tr><tr><td>WS_HSCROLL</td><td>创建一个有水平滚动条的窗口</td></tr><tr><td>WS_ICONIC</td><td>创建一个初始状态为最小化状态的窗口，与 WS_MINIMIZE 风格相同</td></tr><tr><td>WS_MAXIMIZE</td><td>创建一个初始状态为最大化状态的窗口</td></tr><tr><td>WS_MAXIMIZEBOX</td><td>创建一个具有最大化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_MINIMIZE</td><td>创建一个初始状态为最小化状态的窗口，与 WS_ICONIC 风格相同</td></tr><tr><td>WS_MINIMIZEBOX</td><td>创建一个具有最小化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_OVERLAPPED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题条和一个边框，与 WS_TILED 风格相同</td></tr><tr><td>WS_OVERLAPPEDWINDOW</td><td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_TILEDWINDOW 风格相同</td></tr><tr><td>WS_POPUP</td><td>创建一个弹出式窗口，该风格不能与 WS_CHILD 风格同时使用。</td></tr><tr><td>WS_POPUPWINDOW</td><td>相当于（WS_POPUP | WS_BORDER | WS_SYSMENU），但 WS_CAPTION 和 WS_POPUPWINDOW 必须同时设定才能使窗口某单可见</td></tr><tr><td>WS_SIZEBOX</td><td>创建一个可调边框的窗口，与 WS_THICKFRAME 风格相同</td></tr><tr><td>WS_SYSMENU</td><td>创建一个在标题条上带有窗口菜单的窗口，必须同时设定 WS_CAPTION 风格</td></tr><tr><td>WS_TABSTOP</td><td>1. 创建一个“控制窗口”，在用户按下 Tab 键时可以获得键盘焦点。 2. 按下 Tab 键后使键盘焦点转移到下一具有 WS_TABSTOP 风格的“控制窗口”</td></tr><tr><td>WS_THICKFRAME</td><td>创建一个具有可调边框的窗口，与 WS_SIZEBOX 风格相同</td></tr><tr><td>WS_TILED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题和一个边框，与 WS_OVERLAPPED 风格相同</td></tr><tr><td>WS_TILEDWINDOW</td><td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_OVERLAPPEDWINDOW 风格相同</td></tr><tr><td>WS_VISIBLE</td><td>创建一个初始状态为可见的窗口</td></tr><tr><td>WS_VSCROLL</td><td>创建一个有垂直滚动条的窗口</td></tr></tbody></table><h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功，返回值为新窗口的句柄；</p></li><li><p>如果函数失败，返回值为 NULL。</p></li></ol><h2 id="DefWindowProc"><a href="#DefWindowProc" class="headerlink" title="DefWindowProc"></a>DefWindowProc</h2><h3 id="函数功能：-2"><a href="#函数功能：-2" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>DefWindowProc 函数调用默认的窗口过程来处理我们不感兴趣的任何消息，该函数是为了确保每个消息都被处理。</p><p>DefWindowProc 函数传入和窗口过程同样的参数。</p><h3 id="API-函数原型：-2"><a href="#API-函数原型：-2" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">DefWindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  UINT Msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-2"><a href="#参数解析：-2" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定接收消息的窗口句柄</td></tr><tr><td>Msg</td><td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式 2. 应用程序消息只能使用低 16 位，高 16 位被系统保留 3. 传送门：<a href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td></tr><tr><td>wParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>lParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr></tbody></table><h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>返回值就是消息处理结果，它取决于发送的消息。</p><h2 id="DestroyWindow"><a href="#DestroyWindow" class="headerlink" title="DestroyWindow"></a>DestroyWindow</h2><h3 id="函数功能：-3"><a href="#函数功能：-3" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><ol><li><p>DestroyWindow 用于销毁一个指定的窗口，该函数通过发送 WM_DESTROY 消息和 WM_NCDESTROY 消息使窗口无效并移除其键盘焦点。</p></li><li><p>DestroyWindow 函数还销毁窗口的菜单，清空线程的消息队列，销毁与窗口过程相关的定时器，解除窗口对剪贴板的拥有权，打断剪贴板器的查看链。</p></li><li><p>如果指定的窗口拥有子窗口或拥有其它窗口，该函数将自动先销毁其子窗口或所拥有的窗口，然后再销毁自身。</p></li></ol><h3 id="API-函数原型：-3"><a href="#API-函数原型：-3" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DestroyWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-3"><a href="#参数解析：-3" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定将被销毁的窗口句柄</td></tr></tbody></table><h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功执行，返回值为非 0；</p></li><li><p>如果函数执行失败，返回值为 0。</p></li></ol><h3 id="备注：-1"><a href="#备注：-1" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>一个线程不能使用本函数销毁别的线程创建的窗口。</p></li><li><p>如果这个窗口是一个不具有 WS_EX_NOPARENTNOTIFY 样式的子窗口，则销毁窗口时将发 WM_PARENTNOTIFY 消息给其父窗口。</p></li></ol><h2 id="DispatchMessage"><a href="#DispatchMessage" class="headerlink" title="DispatchMessage"></a>DispatchMessage</h2><h3 id="函数功能：-4"><a href="#函数功能：-4" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>DispatchMessage 函数分派一个消息给窗口过程（回调函数），通常该消息从 GetMessage 函数获得。Windows 的控制权在该函数交给了应用程序。</p><h3 id="API-函数原型：-4"><a href="#API-函数原型：-4" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> MSG *lpmsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-4"><a href="#参数解析：-4" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpmsg</td><td>指向含有消息的 MSG结构 的指针</td></tr></tbody></table><h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>返回值是窗口过程返回的值；</p></li><li><p>尽管返回值的含义依赖于被分派的消息，但返回值通常被忽略。</p></li></ol><h3 id="备注：-2"><a href="#备注：-2" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>MSG 结构必须包含有效的消息值。</p></li><li><p>如果参数 lpmsg 指向一个 WM_TIMER 消息，并且 WM_TIMER 消息的参数 lParam 不为 NULL，则调用 lParam 指向的函数，而不是调用窗口程序。</p></li></ol><h2 id="DrawText"><a href="#DrawText" class="headerlink" title="DrawText"></a>DrawText</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>DrawText 函数在指定的矩形里写入格式化的正文，根据指定的方法对正文格式化（扩展的制表符，字符对齐、折行等）。</p><p>需要指定更多的格式选项，可以使用 DrawTextEx 函数。</p><h3 id="API-函数原型：-5"><a href="#API-函数原型：-5" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HDC hDC,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPCTSTR lpchText,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">int</span> nCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPRECT lpRect,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     UINT uFormat</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-5"><a href="#参数解析：-5" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hDC</td><td>指定“显示设备描述表”句柄</td></tr><tr><td>lpchText</td><td>1. 指向将被写入的字符串的指针，如果参数 nCount 是 -1，则字符串必须是以 \0 结束的 2. 如果 uFormat 包含 DT_MODIFYSTRING，则函数可为此字符串增加 4 个字符，存放字符串的缓冲区必须足够大，能容纳附加的字符</td></tr><tr><td>nCount</td><td>1. 指向字符串中的字符数 2. 如果 nCount 为 -1，则 lpchText 指向的字符串被认为是以 \0 结束的，DrawText 会自动计算字符数</td></tr><tr><td>lpRect</td><td>指向 <a href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>的指针，其中包含文本将被置于其中的矩形的信息（按逻辑坐标）</td></tr><tr><td>uFormat</td><td>1. 指定格式化文本的方法 2. 此参数可以通过指定下列标志或标志的组合</td></tr></tbody></table><h3 id="uFormat-参数各种标志解析"><a href="#uFormat-参数各种标志解析" class="headerlink" title="uFormat 参数各种标志解析"></a><strong>uFormat 参数各种标志解析</strong></h3><table><thead><tr><th><strong>标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>DT_BOTTOM</td><td>对齐文字到矩形的底部，当且仅当设置了 DT_SINGLELINE 标志才有效</td></tr><tr><td>DT_CALCRECT</td><td>1. 这个参数决定矩形的宽度和高度 2. 如果输出文本有多行，DrawText 函数使用 lpRect 定义的矩形的宽度，并扩展矩形的底部以容纳输出文本的最后一行 3. 如果输出文本只有一行，则 DrawText 函数改变矩形的右边界，以容纳下正文行的最后一个字符 4. 出现上述任何一种情况，DrawText 函数将返回格式化文本的高度，而不是绘制文本</td></tr><tr><td>DT_CENTER</td><td>文本水平居中显示</td></tr><tr><td>DT_EDITCONTROL</td><td>将拥有多行编辑控件的正文显示特性（尤其是平均字符宽度的计算方法，并且不会显示不可见的最后一行）</td></tr><tr><td>DT_END_ELLIPSIS</td><td>1. 对于显示的文本，如果结束的字符串的范围不在矩形内，它会被截断并以省略号标识 2. 如果一个字母不是在字符串的末尾但却超出了矩形范围，它会被换行但没有追加省略号标识 3. 除非指定了 DT_MODIFYSTRING 标志，否则字符串不会被修改</td></tr><tr><td>DT_EXPANDTABS</td><td>1. 扩展制表符，每个制表符的缺省字符数是 8 2. DT_WORD_ELLIPSIS, DT_PATH_ELLIPSIS 和 DT_END_ELLIPSIS 不能和此参数一起使用</td></tr><tr><td>DT_EXTERNALLEADING</td><td>在行的高度里包含字体的外部标头（通常外部标头不被包含在正文行的高度里）</td></tr><tr><td>DT_HIDEPREFIX</td><td>1. 忽略正文中的前缀字符（&amp;），并且前缀字符后面的字母不会出现下划线，其它前缀字符的调用方式不受影响 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_HIDEPREFIX 显示为“Fis&amp;hC”</td></tr><tr><td>DT_INTERNAL</td><td>用系统字体来计算正文尺寸</td></tr><tr><td>DT_LEFT</td><td>正文左对齐</td></tr><tr><td>DT_MODIFYSTRING</td><td>1. 允许系统修改给定的字符串来匹配显示的正文 2. 此标志必须和 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 同时使用</td></tr><tr><td>DT_NOCLIP</td><td>无裁剪绘制，使用 DT_NOCLIP 可以提高 DrawText 的效率</td></tr><tr><td>DT_NOFULLWIDTHCHARBREAK</td><td>1. 在宽字符的字符串中防止行断开，因此折行规则相当于单字符的字符串 2. 例如，我们可以用在韩国版的 Windows 中，为图标标签提供更好的可读性 3. 除非指定 DT_WORDBREAK，否则此值没有作用</td></tr><tr><td>DT_NOPREFIX</td><td>1. 关闭前缀字符的处理（通常 DrawText 解释 &amp; 为给其后的字符加下划线，解释 &amp;&amp; 为显示单个 &amp;） 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_NOPREFIX 显示为“F&amp;is&amp;&amp;hC”</td></tr><tr><td>DT_PATH_ELLIPSIS</td><td>1. 对于过长的正文，自动替换字符串中间的字符为省略号（…），以确保结果能在合适的矩形内显示 2. 如果该字符串包含反斜杠（\）字符，DT_PATH_ELLIPSIS 尽可能的保留最后一个反斜杠之后的字符 3. 除非指定了 DT_MODIFYSTRING 标志否则字符串不会被修改</td></tr><tr><td>DT_PREFIXONLY</td><td>1. 仅仅在（&amp;）前缀字符的位置下绘制一个下划线，但不绘制字符串中的任何其他字符 2. 例如：输入字符串为“F&amp;is&amp;&amp;hC”，正常显示为“Fis&amp;hC”，使用 DT_PREFIXONLY 显示为“_”</td></tr><tr><td>DT_RIGHT</td><td>正文右对齐</td></tr><tr><td>DT_RTLREADING</td><td>当设备环境的字体是希伯来文或阿拉伯文字体时，为双向正文安排从右到左的阅读顺序</td></tr><tr><td>DT_SINGLELINE</td><td>显示正文的同一行，回车和换行符都不能换行</td></tr><tr><td>DT_TABSTOP</td><td>1. 设置制表符，参数 uFormat 的 8~15 位（低位字中的高位字节）指定每个制表符的字符数，每个制表符的缺省字符数是 8 2. DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP 和 DT_NOPREFIX 不能和此参数一起使用</td></tr><tr><td>DT_TOP</td><td>正文顶端对齐</td></tr><tr><td>DT_VCENTER</td><td>使正文在矩形中垂直居中，当且仅当设置了 DT_SINGLELINE 标志才有效</td></tr><tr><td>DT_WORDBREAK</td><td>1. 当一行中的字符将会延伸到由 lpRect 指定的矩形的边框时，此行自动地在单词之间断开 2. 一个回车一换行也能使之换行 3. 如果没有指定，输出会在一行上</td></tr><tr><td>DT_WORD_ELLIPSIS</td><td>截短不符合矩形的正文，并增加省略号（与 DT_END_ELLIPSIS 类似）</td></tr></tbody></table><h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值是正文的高度（逻辑单位）；</p></li><li><p>如果指定了 DT_VCENTER 或 DT_BOTTOM，返回值是 lpRect -&gt; top 到绘制的正文的底部的偏移值；</p></li><li><p>如果 函数调用失败，返回值是 0。</p></li></ol><h3 id="备注：-3"><a href="#备注：-3" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>函数 DrawText 用设备环境中的字体选择、正文颜色和背景颜色来写正文。</p></li><li><p>DrawText 裁剪正文，使之不会出现在指定矩形的外面，除非指定了 DT_NOCLIP。</p></li><li><p>除非使用 DT_SINGLELINE 格式化，否则其余的格式都认为正文有多行。</p></li><li><p>如果选择的字体对指定的矩形而言太大，DrawText 并不会试图去换成一种小字体。</p></li><li><p>设备环境的正文对齐方式必须包括 TA_LEFT, TA_TOP 和 TA_NOUPDATECP 标志。</p></li></ol><h2 id="EndPaint"><a href="#EndPaint" class="headerlink" title="EndPaint"></a>EndPaint</h2><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>EndPaint 函数标记指定窗口的绘画过程结束。</p><p>这个函数在每次调用 BeginPaint 函数之后被调用（释放设备描述表），但仅仅在绘画完成以后。</p><h3 id="API-函数原型：-6"><a href="#API-函数原型：-6" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> PAINTSTRUCT *lpPaint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-6"><a href="#参数解析：-6" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>已经被重新绘制的窗口句柄</td></tr><tr><td>lpPaint</td><td>指向 <a href="http://bbs.fishc.com/thread-47741-1-1.html">PAINTSTRUCT 结构</a>的指针，用于存放绘画相关的信息（该指针在调用 BeginPaint 时被赋值）</td></tr></tbody></table><h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>该函数返回值始终是非 0。</p><h2 id="GetClientRect"><a href="#GetClientRect" class="headerlink" title="GetClientRect"></a>GetClientRect</h2><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>GetClientRect 函数用于获取窗口客户区的坐标，客户区坐标指定客户区的左上角和右下角。</p><p>由于客户区坐标是相对窗口客户区的左上角而言的，因此左上角坐标为（0，0）</p><h3 id="API-函数原型：-7"><a href="#API-函数原型：-7" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetClientRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPRECT lpRect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-7"><a href="#参数解析：-7" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>需要获取客户区坐标的窗口句柄</td></tr><tr><td>lpRect</td><td>1. 指向 <a href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>的指针，该结构有四个成员，分别为 left、top、right 和 bottom 2. GetClientRect 将这四个成员设定为窗口显示区域的尺寸，left 和 top 字段通常设定为 0，right 和 bottom 字段设定为显示区域的宽度和高度（像素点数）</td></tr></tbody></table><h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数成功，返回值是非 0；</p></li><li><p>如果函数失败，返回值是 0。</p></li></ol><h2 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h2><h3 id="函数功能：-5"><a href="#函数功能：-5" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetMessage 函数的作用是从当前线程的消息队列里获取一个消息并填入 <a href="http://bbs.fishc.com/thread-47240-1-1.html">MSG 结构</a> 中。</p><p>该函数只能获取调用线程的消息，不能获得其他线程的消息。成功获取消息后，线程将从消息队列中删除该消息。</p><p>使用 GetMessage 函数，如果消息队列为空，函数会一直等待直到有消息到来才有返回值。如果希望函数立刻返回（无论是否获取消息），请使用 <a href="http://bbs.fishc.com/thread-69031-1-1.html">PeekMessage</a> 函数。</p><h3 id="API-函数原型：-8"><a href="#API-函数原型：-8" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_     LPMSG lpMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT wMsgFilterMin,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT wMsgFilterMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-8"><a href="#参数解析：-8" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpMsg</td><td>指向 <a href="http://bbs.fishc.com/thread-47240-1-1.html">MSG 结构</a>的指针，用于存放获取到的消息</td></tr><tr><td>hWnd</td><td>1. 需要获取消息的窗口的句柄，该窗口必须属于当前线程 2. 当其值是 NULL 时，将获取所有的当前线程的窗口消息和线程消息 3. 当其值是 -1 时，只获取当前线程消息</td></tr><tr><td>wMsgFilterMin</td><td>指定被可以被获取的消息值的最小整数（消息其实就是一个被定义的整数）</td></tr><tr><td>wMsgFilterMax</td><td>指定被可以被获取的消息值的最小整数</td></tr></tbody></table><h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数取得 WM_QUIT 之外的其他消息，返回值是非 0；</p></li><li><p>如果函数取得 WM_QUIT 消息，返回值是 0；</p></li><li><p>如果出现了错误，返回值是 -1。</p></li></ol><h3 id="备注：-4"><a href="#备注：-4" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>应用程序通常根据 GetMessage 函数的返回值决定是否结束消息循环并退出程序；</p></li><li><p>如果 hWnd 参数不为零，则 GetMessage 函数只获取属于 hWnd 窗口的消息，以及被 <a href="http://bbs.fishc.com/thread-69035-1-1.html">IsChild</a> 函数确定为 hWnd 的子窗口的消息；</p></li><li><p>wMsgFilterMin 和 wMsgFilterMax 参数限定消息获取的范围，如果二者都为 0，则消息获取的范围为所有消息；</p></li><li><p>注意，即便你通过 wMsgFilterMin 和 wMsgFilterMax 参数限定消息获取的范围，但 WM_QUIT 不受此范围影响（无法阻止此消息被 PeekMessage 函数获取）；</p></li><li><p>调用此函数的过程中，如果接收到非排队消息 —— 也就是由该线程调用 <a href="http://bbs.fishc.com/thread-69038-1-1.html">SendMessage</a>, <a href="http://bbs.fishc.com/thread-69039-1-1.html">SendMessageCallback</a>, <a href="http://bbs.fishc.com/thread-69040-1-1.html">SendMessageTimeout</a>, 或 <a href="http://bbs.fishc.com/thread-69041-1-1.html">SendNotifyMessage</a> 发送给所属窗口的消息 —— 系统先暂时挂起等待，然后再获取过滤器匹配的第一个队列消息。如果不指定过滤器，那么按照以下顺序获取消息：</p></li></ol><ul><li>Sent messages</li><li>Posted messages</li><li>Input (hardware) messages and system internal events</li><li>Sent messages (again)</li><li>WM_PAINT messages</li><li>WM_TIMER messages</li></ul><ol start="6"><li>PeekMessage 函数通常不会从消息队列中删除 WM_PAINT 消息，WM_PAINT 会持续保留在消息队列中直到它们被处理，除非一个 WM_PAINT 消息指定的区域为 NULL。</li></ol><p><em>小甲鱼注释：大家应该还记得有三个消息 WM_QUIT, WM_PAINT, WM_TIMER 会被特殊处理，它们总是放在队列的最后面，直到没有其它消息的时候才被处理，连续的 WM_PAINT 消息将被合并成一个以提高绘图效率。</em></p><ol start="7"><li>如果一个顶层窗口停止响应的消息超过几秒钟，系统认为窗口没有响应，并使用一个备用窗口替代，该窗口具有相同的 Z 序列、位置、尺寸和视觉属性。这使得用户可以移动、调整大小，甚至关闭该应用程序。然而，这些仅仅是动作，现有的程序事实上仍然没有响应（为了提高用户体验而制作的假象）。当一个程序被调试时，系统并不会为其生成备用窗口。</li></ol><h2 id="GetTextAlign"><a href="#GetTextAlign" class="headerlink" title="GetTextAlign"></a>GetTextAlign</h2><h3 id="函数功能：-6"><a href="#函数功能：-6" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetTextAlign 函数获得指定的设备环境下的文本对齐方式的设置。</p><h3 id="API-函数原型：-9"><a href="#API-函数原型：-9" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetTextAlign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-9"><a href="#参数解析：-9" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>指定设备环境句柄</td></tr></tbody></table><h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用失败，返回值是 GDI_ERROR；</p></li><li><p>如果函数调用成功，返回值是文字对齐标志的状态。</p></li></ol><p>该返回值是下列值的组合：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>TA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>TA_BOTTOM</td><td>基准点在限定矩形的底边上（限定矩形的含义请看下边备注）</td></tr><tr><td>TA_TOP</td><td>基准点在限定矩形的顶边上</td></tr><tr><td>TA_CENTER</td><td>基准点在限定矩形的中心水平对齐位置</td></tr><tr><td>TA_LEFT</td><td>基准点在限定矩形的左边上</td></tr><tr><td>TA_RIGHT</td><td>基准点在限定矩形的右边上</td></tr><tr><td>TA_RTLREADING</td><td>1. 适用于中东 Windows 版本：正文从右到左的阅读顺序排列，与缺省的从左到右正好相反 2. 只有当被选择的字体是 Hebrew 或 Arabic 时，此值才有用</td></tr><tr><td>TA_NOUPDATECP</td><td>每次输出调用后当前状态不改变</td></tr><tr><td>TA_UPDATECP</td><td>每次输出调用后当前状态改变</td></tr></tbody></table><p>若当前字体有一条缺省的垂直基线（如Kanji），下列值用于取代 TA_BASELINE 和 TA_CENTER：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>VTA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>VTA_CENTER</td><td>基准点与限定矩形的中心垂直对齐</td></tr></tbody></table><h3 id="备注：-5"><a href="#备注：-5" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>默认值是 TA_LEFT, TA_TOP 和 TA_NOUPDATECP</p></li><li><p>限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形</p></li><li><p>限定矩形的尺寸可通过调用 GetTextExtentPoint32 来获得</p></li><li><p>文字对齐标志决定 <a href="http://bbs.fishc.com/thread-49474-1-1.html">TextOut</a> 和 ExtTextOut 如何将正文字符串与基准点对齐</p></li><li><p>文字对齐标志不必是单个的标志位，可以等于0</p></li><li><p>标志必须按相关的组来检查，如下：</p></li></ol><ul><li>TA_LEFT, TA_RIGHT, and TA_CENTER</li><li>TA_BOTTOM, TA_TOP, and TA_BASELINE</li><li>TA_NOUPDATECP and TA_UPDATECP</li></ul><p>如果当前字体有缺省的垂直基线，相关的标志如下所示：</p><ul><li>TA_LEFT, TA_RIGHT, and VTA_BASELINE</li><li>TA_BOTTOM, TA_TOP, and VTA_CENTER</li><li>TA_NOUPDATECP and TA_UPDATECP</li></ul><ol start="7"><li>要验证一个特定的标志在返回值中被设置，应用程序必须执行以下步骤：<br>（例子：<a href="http://bbs.fishc.com/thread-49943-1-1.html">如何设置文本对齐模式</a>）</li></ol><ul><li>对该标志及其相关标志实施位OR操作；</li><li>对结果和返回值实施位AND操作；</li><li>检查结果值和标志是否相等。</li></ul><h2 id="GetTextMetrics"><a href="#GetTextMetrics" class="headerlink" title="GetTextMetrics"></a>GetTextMetrics</h2><h3 id="函数功能：-7"><a href="#函数功能：-7" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>GetTextMetrics 函数将当前字体的信息填充到指定缓冲区（<a href="http://bbs.fishc.com/thread-50017-1-1.html">TEXTMETRIC 结构</a>）</p><h3 id="API-函数原型：-10"><a href="#API-函数原型：-10" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetTextMetrics</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTEXTMETRIC lptm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-10"><a href="#参数解析：-10" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>设备环境句柄</td></tr><tr><td>lptm</td><td>指向 <a href="http://bbs.fishc.com/thread-50017-1-1.html">TEXTMETRIC 结构</a>的指针，该结构用于获得字体信息</td></tr></tbody></table><h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值是非 0；</p></li><li><p>如果函数调用失败，返回值是 0。</p></li></ol><h3 id="备注：-6"><a href="#备注：-6" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>要确定一种字体是否为 TrueType 字体，可以通过调用 GetTextMetrics 函数，然后检查 TEXTMETRIC.tmPitchAndFamily 的值是否为 TMPF_TRUETYPE</p></li><li><p>注意，调用 GetDC 函数返回的是一个未初始化的 DC，它具有“系统”（一个位图字体）作为默认字体。因此你需要先选择一种字体到 DC</p></li></ol><h2 id="lstrcat"><a href="#lstrcat" class="headerlink" title="lstrcat"></a>lstrcat</h2><h3 id="函数功能：-8"><a href="#函数功能：-8" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrcat 函数的功能是将一个字符串拼接在另一个字符串后边。</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49707-1-1.html">StringCchCat</a> 代替。</strong></p><h3 id="API-函数原型：-11"><a href="#API-函数原型：-11" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">lstrcat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPTSTR lpString1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPTSTR lpString2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-11"><a href="#参数解析：-11" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString1</td><td>一个以’\0’为结尾的字符串，该字符串空间必须大到足以容纳本身及另一个字符串</td></tr><tr><td>lpString2</td><td>一个以’\0’为结尾的字符串，该字符串将拼接到 lpString1 指向的字符串后边</td></tr></tbody></table><h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回指向拼接好的字符串指针；</p></li><li><p>如果函数调用失败，返回值为 NULL，并且 lpString1 可能会变成非 ‘\0’ 结束的字符串。</p></li></ol><h3 id="安全建议："><a href="#安全建议：" class="headerlink" title="安全建议："></a><strong>安全建议：</strong></h3><ol><li><p>不正确的使用 lstrcat 函数，可能会损害应用程序的安全性</p></li><li><p>lstrcat 函数使用结构化异常处理（SEH）来捕捉访问冲突和其他错误。当该函数捕获 SEH 错误，如果没有以’\0’结尾的字符串，则返回 NULL，且不把错误通知调用者。因此，把空间不足作为错误的条件是不安全的</p></li><li><p>lpString1 必须足够大，以增加 lpString2 和结束’\0’，否则可能发生缓冲区溢出</p></li><li><p>在最坏的情况下，缓冲区溢出可能允许攻击者可执行代码注入到你的进程，尤其是当 lpString1 是一个基于堆栈的缓冲区</p></li></ol><h2 id="lstrcpy"><a href="#lstrcpy" class="headerlink" title="lstrcpy"></a>lstrcpy</h2><h3 id="函数功能：-9"><a href="#函数功能：-9" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrcpy 函数的功能是复制一个字符串到缓冲区。</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49713-1-1.html">StringCchCopy</a> 代替。</strong></p><h3 id="API-函数原型：-12"><a href="#API-函数原型：-12" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPTSTR WINAPI <span class="title">lstrcpy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR lpString1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPTSTR lpString2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-12"><a href="#参数解析：-12" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString1</td><td>1. 缓冲区，用于接收来自 lpString2 参数指向的字符串 2. 该缓冲区必须足够容纳字符串和’\0’</td></tr><tr><td>lpString2</td><td>待拷贝的字符串</td></tr></tbody></table><h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回指向缓冲区的指针；</p></li><li><p>如果函数调用失败，返回值是 NULL，并且 lpString1 可能会变成非 ‘\0’ 结束的字符串。</p></li></ol><h3 id="安全建议：-1"><a href="#安全建议：-1" class="headerlink" title="安全建议："></a><strong>安全建议：</strong></h3><ol><li><p>不正确的使用 lstcpy 函数，可能会损害应用程序的安全性</p></li><li><p>lstrcpy 函数使用结构化异常处理（SEH）来捕捉访问冲突和其他错误。当该函数捕获 SEH 错误，如果没有以’\0’结尾的字符串，则返回 NULL，且不把错误通知调用者。因此，把空间不足作为错误的条件是不安全的</p></li><li><p>lpString1 必须足够大，以增加 lpString2 和结束’\0’，否则可能发生缓冲区溢出</p></li><li><p>在最坏的情况下，缓冲区溢出可能允许攻击者可执行代码注入到你的进程，尤其是当 lpString1 是一个基于堆栈的缓冲区</p></li></ol><h2 id="lstrlen"><a href="#lstrlen" class="headerlink" title="lstrlen"></a>lstrlen</h2><h3 id="函数功能：-10"><a href="#函数功能：-10" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>lstrlen 函数用于计算指定字符串的长度（不包含’\0）</p><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49704-1-1.html">StringCchLength</a> 或 StringCbLength 代替。</strong></p><h3 id="API-函数原型：-13"><a href="#API-函数原型：-13" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">lstrlen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCTSTR lpString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-13"><a href="#参数解析：-13" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpString</td><td>指向以’\0’为终止符的字符串</td></tr></tbody></table><h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>该函数返回指定字符串的字符数；</p></li><li><p>如果是空字符串，则返回 0。</p></li></ol><h2 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h2><h3 id="函数功能：-11"><a href="#函数功能：-11" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>MessageBox 函数用于显示一个模态对话框，其中包含一个系统图标、 一组按钮和一个简短的特定于应用程序消息，如状态或错误的信息。</p><p>消息框中返回一个整数值，该值指示用户单击了哪个按钮。</p><h3 id="API-函数原型：-14"><a href="#API-函数原型：-14" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      UINT uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-14"><a href="#参数解析：-14" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>1. 该消息框的父窗口句柄 2. 如果此参数为NULL，则该消息框没有拥有父窗口</td></tr><tr><td>lpText</td><td>消息框的内容</td></tr><tr><td>lpCaption</td><td>消息框的标题</td></tr><tr><td>uType</td><td>1. 指定一个决定对话框的内容和行为的位标志集 2. 此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td></tr></tbody></table><h3 id="uType参数定义解析"><a href="#uType参数定义解析" class="headerlink" title="uType参数定义解析"></a><strong>uType参数定义解析</strong></h3><table><thead><tr><th><strong>按钮</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_OK</td><td>默认值，有一个“确认”按钮在里面</td></tr><tr><td>MB_YESNO</td><td>有“是”和“否”两个按钮在里面</td></tr><tr><td>MB_ABORTRETRYIGNORE</td><td>有“中止”，“重试”和“跳过”三个按钮在里面</td></tr><tr><td>MB_YESNOCANCEL</td><td>有“是”，“否”和“取消”三个按钮在里面</td></tr><tr><td>MB_RETRYCANCEL</td><td>有“重试”和“取消”两个按钮在里面</td></tr><tr><td>MB_OKCANCEL</td><td>有“确定”和“取消”两个按钮在里面</td></tr></tbody></table><table><thead><tr><th><strong>图标</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_ICONEXCLAMATION</td><td>一个惊叹号出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/33_400_300.jpg" alt="IC534153.png"></td></tr><tr><td>MB_ICONWARNING</td><td>一个惊叹号出现在消息框（同上）</td></tr><tr><td>MB_ICONINFORMATION</td><td>一个圆圈中小写字母i组成的图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/30_400_300.jpg" alt="IC534154.png"></td></tr><tr><td>MB_ICONASTERISK</td><td>一个圆圈中小写字母i组成的图标出现在消息框（同上）</td></tr><tr><td>MB_ICONQUESTION</td><td>一个问题标记图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/32_400_300.jpg" alt="IC534152.png"></td></tr><tr><td>MB_ICONSTOP</td><td>一个停止消息图标出现在消息框：<img src= "/img/loading.gif" data-lazy-src="https://fishc.com.cn/data/attachment/image/000/02/50/31_400_300.jpg" alt="IC534151.png"></td></tr><tr><td>MB_ICONERROR</td><td>一个停止消息图标出现在消息框（同上）</td></tr><tr><td>MB_ICONHAND</td><td>一个停止消息图标出现在消息框（同上）</td></tr></tbody></table><table><thead><tr><th><strong>默认按钮</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_DEFBUTTON1</td><td>指定第一个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON2</td><td>指定第二个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON3</td><td>指定第三个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON4</td><td>指定第四个按钮为默认按钮</td></tr></tbody></table><table><thead><tr><th><strong>消息框形态</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_APPLMODAL</td><td>1. 在 hWnd 参数标识的窗口中继续工作以前，用户一定响应消息框 2. 但是，用户可以移动到其他线程的窗口且在这些窗口中工作 3. 根据应用程序中窗口的层次机构，用户则以移动到线程内的其他窗口 4. 所有母消息框的子窗口自动地失效，但是弹出窗口不是这样 5. 如果既没有指定 MB_SYSTEMMODAL 也没有指定 MB_TASKMODAL，则 MB_APPLMODAL 为默认的</td></tr><tr><td>MB_SYSTEMMODAL</td><td>1. 除了消息框有 WB_EX_TOPMOST 类型，否则 MB_APPLMODAL 和 MB_SYSTEMMODAL 一样 2. 用系统模态消息框来改变各种各样的用户，主要的损坏错误需要立即注意（例如，内存溢出） 3. 如果不是那些与 hWnd 联系的窗口，此标志对用户对窗口的相互联系没有影响</td></tr><tr><td>MB_TASKMODAL</td><td>1. 如果参数 hWnd 为 NULL 的话，那么除了所有属于当前线程高层次的窗口失效外，MB_TASKMODAL 和 MB_APPLMODAL 一样 2. 当调用应用程序或库没有一个可以得到的窗口句柄时，可以使用此标志，但仍需要阻止输入到调用线程的其他窗口，而不是搁置其他线程</td></tr></tbody></table><table><thead><tr><th><strong>其他标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MB_DEFAULT_DESKTOP_ONLY</td><td>1. 接收输入的当前桌面一定是一个默认桌面，否则函数调用失败 2. 默认桌面是一个在用户已经记录且以后应用程序在此上面运行的桌面</td></tr><tr><td>MB_HELP</td><td>1. 把一个 Help 按钮增加到消息框 2. 选择 Help 按钮或按 F1 产生一个 Help 事件</td></tr><tr><td>MB_RIGHT</td><td>文本为右对齐</td></tr><tr><td>MB_RTLREADING</td><td>用在 Hebrew 和 Arabic 系统中从右到左的顺序显示消息和大写文本</td></tr><tr><td>MB_SETFOREGROUND</td><td>1. 消息框变为前景窗口 2. 在内部系统为消息个调用 SetForegroundWindow 函数</td></tr><tr><td>MB_TOPMOST</td><td>消息框用 WS_EX_TOPMOST 窗口类型来创建 MB_SERVICE_NOTIFICATION</td></tr></tbody></table><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>1. 该消息框的父窗口句柄 2. 如果此参数为NULL，则该消息框没有拥有父窗口</td></tr><tr><td>lpText</td><td>消息框的内容</td></tr><tr><td>lpCaption</td><td>消息框的标题</td></tr><tr><td>uType</td><td>1. 指定一个决定对话框的内容和行为的位标志集 2. 此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td></tr></tbody></table><h3 id="返回值：-14"><a href="#返回值：-14" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><table><thead><tr><th><strong>返回值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>IDOK</td><td>用户按下了“确认”按钮</td></tr><tr><td>IDCANCEL</td><td>用户按下了“取消”按钮</td></tr><tr><td>IDABORT</td><td>用户按下了“中止”按钮</td></tr><tr><td>IDRETRY</td><td>用户按下了“重试”按钮</td></tr><tr><td>IDIGNORE</td><td>用户按下了“忽略”按钮</td></tr><tr><td>IDYES</td><td>用户按下了“是”按钮</td></tr><tr><td>IDNO</td><td>用户按下了“否”按钮</td></tr></tbody></table><h2 id="PostQuitMessage"><a href="#PostQuitMessage" class="headerlink" title="PostQuitMessage"></a>PostQuitMessage</h2><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a><strong>函数原型：</strong></h3><p>PostQuitMessage 函数向系统表明有个线程提出终止（退出）请求。</p><p>这个函数通常用来响应 WM_DESTROY 消息。</p><h3 id="API-函数原型：-15"><a href="#API-函数原型：-15" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">PostQuitMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-15"><a href="#参数解析：-15" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>nExitCode</td><td>指定应用程序的退出代码，此值被用作 WM_QUIT 消息的 wParam 参数</td></tr></tbody></table><h3 id="返回值：-15"><a href="#返回值：-15" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>该函数没有返回值。</p><h3 id="备注：-7"><a href="#备注：-7" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>PostQuitMessage 函数的功能是发送一个 WM_QUIT 消息给线程的消息队列并立即返回。</p></li><li><p>当线程从消息队列里取得 WM_QUIT 消息时，应当退出消息循环并将返回系统，返回给系统的退出值必须是消息 WM_QUIT 的 wParam 参数（所以 WinMain 函数的返回值是 msg.wParam）。</p></li></ol><h2 id="SetScrollRange"><a href="#SetScrollRange" class="headerlink" title="SetScrollRange"></a>SetScrollRange</h2><h3 id="函数功能：-12"><a href="#函数功能：-12" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>SetScrollRange 函数设置所指定滚动条范围的最小值和最大值。</p><p>注意：SetScrollRange 函数提供了向后的兼容性。但新的应用程序应该提倡使用 SetScrollInfo 函数代替。</p><h3 id="API-函数原型：-16"><a href="#API-函数原型：-16" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetScrollRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nBar,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nMinPos,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nMaxPos,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  BOOL bRedraw</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-16"><a href="#参数解析：-16" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>1. 滚动条控件的句柄或带有标准滚动条窗体的句柄 2. 由 nBar 参数的值确定</td></tr><tr><td>nBar</td><td>指定将要设置哪类滚动条的参数： 1. SB_CTL：设置滚动条控件的范围，要求参数 hwnd 必须是滚动条控件的句柄 2. SB_HORZ：设置窗体的标准水平滚动条的范围 3. SB_VERT：设置窗体的标准垂直滚动条的范围</td></tr><tr><td>nMinPos</td><td>指定滚动位置的最小值</td></tr><tr><td>nMaxPos</td><td>指定滚动位置的最大值</td></tr><tr><td>bRedraw</td><td>指定滚动条是否被重画以反映变化（如果这个参数为 TRUE，滚动条将被重画；如果为 FALSE 则不被重画）</td></tr></tbody></table><h3 id="返回值：-16"><a href="#返回值：-16" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值为非 0；</p></li><li><p>如果函数调用失败，返回值为 0。</p></li></ol><h3 id="备注：-8"><a href="#备注：-8" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>将 SetScrollRange 函数中的 nMinPos 和 nMaxPos 参数设置为一样的值，可以达到隐藏滚动条的目的。但在处理滚动条消息时，应用程序不应该调用 SetScrollRange 函数来隐藏滚动条。新的应用程序应该调用 ShowScrollBar 函数来隐藏滚动条。</p></li><li><p>如果调用 SetScrollPos 函数之后马上调用 SetScrollRange 函数，则 SetScrollPos 函数中的 bRedraw 参数一定要设置为零值（FALSE），以防止滚动条被画两次。</p></li><li><p>标准滚动条的缺省范围是 0 到 100。滚动条控件的缺省值为 NULL（参数 nMinPos 和 nMaxPos 的值均为零）。两个范围值之间的不同之处在于由参数 nMinPos 和 nMaxPos 指定，不过不能超过 MAXLONG 定义的大小。</p></li><li><p>因为说明滚动条位置的消息 WM_HSCROLL 和 WM_VSCROLL 是 16 位数据，所以那些只依赖于说明位置数据消息的应用程序在 SetScrollRange 函数的参数 nMaxPos 中有一个实际最大值 65,535。但是，因为 SetScrolllnfo，SetScrollPos， SetScrollRange，GetScrolllnfo，GetScrollPos 和 GetScrollRange 函数都支持 32 位的滚动条位置数据，所以有一个解决 16 位 WM_HSCROLL 和 WM_VSCROLL 消息阻碍的途径，请参见函数 GetScrolllnfo 的有关技术说明。</p></li><li><p>如果参数 nBar 设置为 SB_CTL 并且参数 hWnd 所标识的不是一个标准的滚动条控件。系统将发送一个 SBM_SETRANGE 消息到窗体用以设置滚动条消息。这将允许 SetScrollRange 函数操作一个定制的伪滚动条控件。如果窗体没有处理 SBM_SETRANGE 消息，SetScrollRange 函数将调用失败。</p></li></ol><h2 id="SetTextAlign"><a href="#SetTextAlign" class="headerlink" title="SetTextAlign"></a>SetTextAlign</h2><h3 id="函数功能：-13"><a href="#函数功能：-13" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>SetTextAlign 函数为指定设备环境设置文本的对齐标志。</p><h3 id="API-函数原型：-17"><a href="#API-函数原型：-17" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SetTextAlign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  UINT fMode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-17"><a href="#参数解析：-17" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>指定设备环境句柄</td></tr><tr><td>fMode</td><td>1. 文本对齐标志 2. 在横向对齐和纵向对齐标志中只能选择一个 3. 两个标志只能选择一个来改变当前的位置</td></tr></tbody></table><p>使用下面的列表中的掩码指定文本对齐方式：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>TA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>TA_BOTTOM</td><td>基准点在限定矩形的底边上（限定矩形的含义请看下边备注）</td></tr><tr><td>TA_TOP</td><td>基准点在限定矩形的顶边上</td></tr><tr><td>TA_CENTER</td><td>基准点在限定矩形的中心水平对齐位置</td></tr><tr><td>TA_LEFT</td><td>基准点在限定矩形的左边上</td></tr><tr><td>TA_RIGHT</td><td>基准点在限定矩形的右边上</td></tr><tr><td>TA_NOUPDATECP</td><td>1. 适用于中东 Windows 版本：正文从右到左的阅读顺序排列，与缺省的从左到右正好相反 2. 只有当被选择的字体是 Hebrew 或 Arabic 时，此值才有用</td></tr><tr><td>TA_RTLREADING</td><td>每次输出调用后当前状态不改变</td></tr><tr><td>TA_UPDATECP</td><td>每次输出调用后当前状态改变</td></tr></tbody></table><p>若当前字体有一条缺省的垂直基线（如Kanji），下列值用于取代 TA_BASELINE 和 TA_CENTER：</p><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>VTA_BASELINE</td><td>基准点在正文的基线上</td></tr><tr><td>VTA_CENTER</td><td>基准点与限定矩形的中心垂直对齐</td></tr></tbody></table><p>默认值是 TA_LEFT, TA_TOP 和 TA_NOUPDATECP。</p><h3 id="返回值：-17"><a href="#返回值：-17" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用失败，返回值是 GDI_ERROR；</p></li><li><p>如果函数调用成功，返回值是文字对齐方式的前一个设置。</p></li></ol><h3 id="备注：-9"><a href="#备注：-9" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>限定矩形是指能将正文字符串的所有字符单元限定于其中的矩形</p></li><li><p><a href="http://bbs.fishc.com/thread-49474-1-1.html">TextOut</a> 和 ExtTextOut 函数用文字对齐标志来将一个正文字符串定位于显示器或者其他设备</p></li><li><p>该标志指定了基准点与限定正文的矩形的位置关系，基准点可以是当前位置，也可是传给正文输出函数的一个点</p></li><li><p>设置左对齐文本的做好方法可以是如下：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign (hdc, GetTextAlign(hdc) &amp; (~TA_CENTER))</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign (hdc,TA_LEFT | &lt;other flags&gt;)</span><br></pre></td></tr></table></figure><p>你当然可以使用 SetTextAlign (hdc, TA_LEFT) 来达到这个目的，但是这个方法会丢失所有的垂直基线或者从右到左的设置。</p><ol start="5"><li>调用 SetTextAlign 函数时，如果使用 TA_UPDATECP 标志，Windows 会忽略 TextOut 的 xStart 和 yStart 参数，而使用由 MoveToEx、LineTo 或更改目前位置的另一个函数设定的位置。</li></ol><h2 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h2><h3 id="函数功能：-14"><a href="#函数功能：-14" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>ShowWindow 函数用于设置窗口的显示状态。</p><p>应用程序第一次调用 ShowWindow 时，应该使用 WinMain 函数的 nCmdshow 参数作为它的 nCmdShow 参数。在随后调用 ShowWindow 函数时，必须使用下列显示方式中的一个给定值，而不是由 WinMain 函数的 nCmdSHow 参数指定的值。</p><h3 id="API-函数原型：-18"><a href="#API-函数原型：-18" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ShowWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nCmdShow</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-18"><a href="#参数解析：-18" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>窗口句柄</td></tr><tr><td>nCmdShow</td><td>控制窗口如何显示，如果发送应用程序的程序提供了 STARTUPINFO 结构，则应用程序第一次调用 ShowWindow 时该参数被忽略。否则，在第一次调用 ShowWindow 函数时，该值应为在函数 WinMain 中 nCmdShow 参数。</td></tr></tbody></table><p><strong>在随后的调用中，nCmdShow 参数可以为下列值之一：</strong></p><table><thead><tr><th><strong>显示方式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>SW_FORCEMINIMIZE</td><td>1. 最小化窗口，即使拥有窗口的线程被挂起也会最小化 2. 在从其他线程最小化窗口时才使用这个参数</td></tr><tr><td>SW_HIDE</td><td>隐藏窗口并激活其他窗口</td></tr><tr><td>SW_MAXIMIZE</td><td>最大化指定的窗口</td></tr><tr><td>SW_MINIMIZE</td><td>最小化指定的窗口并且激活在 Z 序中的下一个顶层窗口</td></tr><tr><td>SW_RESTORE</td><td>1. 激活并显示窗口 2. 如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置 3. 在恢复最小化窗口时，应用程序应该指定这个标志。</td></tr><tr><td>SW_SHOW</td><td>在窗口原来的位置以原来的尺寸激活并显示窗口</td></tr><tr><td>SW_SHOWDEFAULT</td><td>依据在 STARTUPINFO 结构中指定的 SW_FLAG 标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给 CreateProcess 函数的。</td></tr><tr><td>SW_SHOWMAXIMIZED</td><td>激活窗口并将其最大化</td></tr><tr><td>SW_SHOWMINIMIZED</td><td>激活窗口并将其最小化</td></tr><tr><td>SW_SHOWMINNOACTIVE</td><td>1. 窗口最小化 2. 在窗口激活的情况下，这个值跟 SW_SHOWMINIMIZED 很相似</td></tr><tr><td>SW_SHOWNA</td><td>1. 以窗口原来的位置以原来的尺寸显示窗口 2. 在窗口激活的情况下，这个值跟 SW_SHOW 很相似</td></tr><tr><td>SW_SHOWNOACTIVATE</td><td>1. 以窗口最近一次的位置和尺寸显示窗口 2. 在窗口激活的情况下，这个值跟 SW_SHOWNORMAL 很相似</td></tr><tr><td>SW_SHOWNORMAL</td><td>1. 激活并显示一个窗口 2. 如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小 3. 应用程序在第一次显示窗口的时候应该指定此标志</td></tr></tbody></table><h3 id="返回值：-18"><a href="#返回值：-18" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果窗口之前可见，则返回值为非 0；</p></li><li><p>如果窗口之前被隐藏，则返回值为 0。</p></li></ol><h2 id="StringCchCat"><a href="#StringCchCat" class="headerlink" title="StringCchCat"></a>StringCchCat</h2><h3 id="函数功能：-15"><a href="#函数功能：-15" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchCat 函数的功能是将一个字符串拼接到另一个字符串。StringCchCat 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strcat, wcscat, _tcsat</li><li>lstrcat</li><li>StrCat</li><li>StrCatBuff</li></ul><h3 id="API-函数原型：-19"><a href="#API-函数原型：-19" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPCTSTR pszSrc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-19"><a href="#参数解析：-19" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>1. 目标缓冲区，同时包含第一个字符串 2. 该缓冲区必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+’\0’）</td></tr><tr><td>cchDest</td><td>1. 目标缓冲区的大小（字符个数） 2. 该值必须大于或等于 pszDest + pszSrc + 1（两个字符串的字符总和+’\0’） 3. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pszSrc</td><td>第二个字符串</td></tr></tbody></table><h3 id="返回值：-19"><a href="#返回值：-19" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是拼接好的字符串指针。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-2.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-2.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>字符串正常拼接</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. cchDest 参数的值为 0 2. cchDest 参数的值大于 STRSAFE_MAX_CCH 3. 目标缓冲区空间已满</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 因缓冲区空间不足导致失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h3 id="备注：-10"><a href="#备注：-10" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>使用 StringCchCat 函数需要添加头文件：strsafe.h</p><h2 id="StringCchCopy"><a href="#StringCchCopy" class="headerlink" title="StringCchCopy"></a>StringCchCopy</h2><h3 id="函数功能：-16"><a href="#函数功能：-16" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchCopy 函数的功能是复制一个字符串到缓冲区。StringCchCopy 函数要求提供目标缓冲区的长度，以确保写入数据不会超出缓冲区的末尾。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strcpy, wcscpy, _tcscpy</li><li>lstrcpy</li><li>StrCpy</li></ul><h3 id="API-函数原型：-20"><a href="#API-函数原型：-20" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchCopy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR pszSrc</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-20"><a href="#参数解析：-20" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>缓冲区，用于接收拷贝过来的字符串</td></tr><tr><td>cchDest</td><td>1. 目标缓冲区的大小（字符个数） 2. 该值必须大于或等于 pszSrc + 1（待拷贝字符串的字符+’\0’） 3. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pszSrc</td><td>待拷贝的字符串</td></tr></tbody></table><h3 id="返回值：-20"><a href="#返回值：-20" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是指向缓冲区的指针。我们强烈建议您使用 SUCCEEDED 和 FAILED 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>字符串正常拷贝</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. cchDest 参数的值为 0 2. cchDest 参数的值大于 STRSAFE_MAX_CCH</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 因缓冲区空间不足导致失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h2 id="StringCchLength"><a href="#StringCchLength" class="headerlink" title="StringCchLength"></a>StringCchLength</h2><h3 id="函数功能：-17"><a href="#函数功能：-17" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchLength 函数用于确定字符串是否超过了规定的长度，以字符为计算单位。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>strlen, wcslen, _tcslen</li></ul><h3 id="API-函数原型：-21"><a href="#API-函数原型：-21" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchLength</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR psz,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchMax,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  <span class="keyword">size_t</span> *pcch</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-21"><a href="#参数解析：-21" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>psz</td><td>指向待检查的字符串</td></tr><tr><td>cchMax</td><td>1. psz 参数里最大允许的字符数量，包括’\0’ 2. 这个数不能超过 STRSAFE_MAX_CCH</td></tr><tr><td>pcch</td><td>1. psz 参数指向字符串的字符个数，不包括’\0’ 2. 这个值只有在 psz 指针不为 NULL，且函数成功时有效</td></tr></tbody></table><h3 id="返回值：-21"><a href="#返回值：-21" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是指定字符串的字符个数。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>psz 指向的字符串不为空，且字符串的长度（包括’\0’）小于等于 cchMax</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>1. psz 指向空字符串 2. cchMax 的值大于STRSAFE_MAX_CCH 3. psz 指向的字符串的字符个数超过 cchMax</td></tr></tbody></table><h3 id="备注：-11"><a href="#备注：-11" class="headerlink" title="备注："></a><strong>备注：</strong></h3><ol><li><p>对比 StringCchLength 所替代的函数，StringCchLength 是可以使你的代码正确处理缓存区的一个附加功能。因为小的缓冲处理会牵连很多安全问题，例如缓存区溢出</p></li><li><p>使用 StringCchLength 函数需要添加头文件：strsafe.h</p></li></ol><h2 id="StringCchPrintf"><a href="#StringCchPrintf" class="headerlink" title="StringCchPrintf"></a>StringCchPrintf</h2><h3 id="函数功能：-18"><a href="#函数功能：-18" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>StringCchPrintf 函数用于把数据格式化写入到指定的缓冲区里，该函数要求提供目标缓冲区的大小，确保不会发生越界访问。</p><p>微软推荐使用该函数替代以下函数：</p><ul><li>sprintf, swprintf, _stprintf</li><li>wsprintf</li><li>wnsprintf</li><li>_snprintf, _snwprintf, _sntprintf</li></ul><h3 id="API-函数原型：-22"><a href="#API-函数原型：-22" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">StringCchPrintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR pszDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   <span class="keyword">size_t</span> cchDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR pszFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-22"><a href="#参数解析：-22" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>pszDest</td><td>指定格式化数据将要写入的缓冲区</td></tr><tr><td>cchDest</td><td>1. 缓冲区大小 2. 应该设置足够大，以容纳字符串和结束标记（’\n’） 3. 最大允许的字符数是 STRSAFE_MAX_CCH</td></tr><tr><td>pszFormat</td><td>1. 格式化字符串 2. 与 pirntf 的格式化字符串一致</td></tr><tr><td>…</td><td>可变参数，参数的个数取决 pszFormat 参数</td></tr></tbody></table><h3 id="返回值：-22"><a href="#返回值：-22" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><p>这个函数返回一个 HRESULT，而不是像 sprintf 一样返回存储在其目标缓冲区的字节数。我们强烈建议您使用 <a href="http://bbs.fishc.com/thread-49703-1-1.html">SUCCEEDED</a> 和 <a href="http://bbs.fishc.com/thread-49703-1-1.html">FAILED</a> 宏来测试这个函数的返回值。</p><p>返回值可以是以下任意一个值：</p><table><thead><tr><th><strong>返回代码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>S_OK</td><td>表示有足够的空间将拷贝到 pszDest，没有发生截断</td></tr><tr><td>STRSAFE_E_INVALID_PARAMETER</td><td>cchDest 的值为 0 或大于 STRSAFE_MAX_CCH</td></tr><tr><td>STRSAFE_E_INSUFFICIENT_BUFFER</td><td>1. 由于缓冲区空间不足而导致的复制失败 2. 结果被截断，当仍然包含’\0’结尾 3. 如果截断操作可以被接受，则不一定被看作是失败</td></tr></tbody></table><h3 id="备注：-12"><a href="#备注：-12" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>使用 StringCchPrintf 函数需要添加头文件：<strong>strsafe.h</strong></p><h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a><strong>代码演示：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strsafe.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">TCHAR pszDest[<span class="number">30</span>]; </span><br><span class="line"><span class="keyword">size_t</span> cchDest = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">LPCTSTR pszFormat = TEXT(<span class="string">&quot;从你家到鱼C工作室需要 %f 公里！&quot;</span>);</span><br><span class="line"></span><br><span class="line">HRESULT hr = StringCchPrintf(pszDest, cchDest, pszFormat, <span class="number">123.45</span>);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="TextOut"><a href="#TextOut" class="headerlink" title="TextOut"></a>TextOut</h2><h3 id="函数功能：-19"><a href="#函数功能：-19" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>TextOut 函数使用当前选择的字体、背景颜色和文本颜色，将一个字符串绘制于窗口的指定位置。</p><h3 id="API-函数原型：-23"><a href="#API-函数原型：-23" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><p><em>注释：<code>_In_</code> 说明该参数是输入的，<code>_opt_</code> 说明该参数是可选参数。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nXStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> nYStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCTSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">int</span> cchString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-23"><a href="#参数解析：-23" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>设备环境句柄</td></tr><tr><td>nXStart</td><td>指定用于字符串对齐的基准点的逻辑 x 坐标（有关基准点请看下边备注）</td></tr><tr><td>nYStart</td><td>指定用于字符串对齐的基准点的逻辑 y 坐标</td></tr><tr><td>lpString</td><td>1. 指向将被绘制字符串的指针 2. 该字符串不必以’\0’结束，因为 cchString 参数指定了该字符串的长度</td></tr><tr><td>cchString</td><td>lpString 字符串的长度（有多少个字符）</td></tr></tbody></table><h3 id="返回值：-23"><a href="#返回值：-23" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值为非 0；</p></li><li><p>如果函数调用失败，返回值为 0。</p></li></ol><h3 id="备注：-13"><a href="#备注：-13" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>字符串对齐的基准点取决于当前的文本对齐模式。应用程序可以通过调用 <a href="http://bbs.fishc.com/thread-49489-1-1.html">GetTextAlign</a> 获得当前的文本对齐模式，通过调用 <a href="http://bbs.fishc.com/thread-49492-1-1.html">SetTextAlign</a> 修改该模式。</p><h2 id="TranslateMessage"><a href="#TranslateMessage" class="headerlink" title="TranslateMessage"></a>TranslateMessage</h2><h3 id="函数功能：-20"><a href="#函数功能：-20" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>TranslateMessage 函数将虚拟键消息转换为字符消息，字符消息被寄送到当前线程的消息队列里。</p><p>当下一次线程调用函数 GetMessage 或 PeekMessage 时被读出。</p><h3 id="API-函数原型：-24"><a href="#API-函数原型：-24" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">TranslateMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> MSG *lpMsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-24"><a href="#参数解析：-24" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpMsg</td><td>指向含有消息的 MSG 结构的指针</td></tr></tbody></table><h3 id="返回值：-24"><a href="#返回值：-24" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果消息被转换（字符消息被寄送到当前线程的消息队列里）则返回非零值；</p></li><li><p>如果消息是 WM_KEYDOWN，WM_KEYUP WM_SYSKEYDOWN 或 WM_SYSKEYUP，返回非零值，不考虑转换；</p></li><li><p>如果消息没被转换（字符消息没被寄送到调用线程的消息队列里）则返回值是零。</p></li></ol><h2 id="UpdateWindow"><a href="#UpdateWindow" class="headerlink" title="UpdateWindow"></a>UpdateWindow</h2><h3 id="函数功能：-21"><a href="#函数功能：-21" class="headerlink" title="函数功能："></a><strong>函数功能：</strong></h3><p>UpdateWindow 函数绕过应用程序的消息队列，直接发送 WM_PAINT 消息给指定窗口的窗口过程。</p><p>如果窗口更新的区域不为空，UpdateWindow 函数通过发送一个 WM_PAINT 消息来更新指定窗口的客户区。如果更新区域为空，则不发送消息。</p><h3 id="API-函数原型：-25"><a href="#API-函数原型：-25" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UpdateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HWND hWnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-25"><a href="#参数解析：-25" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定要更新的窗口的句柄.</td></tr></tbody></table><h3 id="返回值：-25"><a href="#返回值：-25" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值为非 0；</p></li><li><p>如果函数调用不成功，返回值为 0。</p></li></ol><h2 id="wsprintf"><a href="#wsprintf" class="headerlink" title="wsprintf"></a>wsprintf</h2><h3 id="函数功能：-22"><a href="#函数功能：-22" class="headerlink" title="函数功能："></a><strong>函数功能</strong>：</h3><ul><li>wsprintf 函数将格式化字符串写入到指定的缓冲区里</li><li>输出缓冲区里的的值取决于格式说明符（即”%”）</li><li>如果写入的是文字，此函数给写入的文字的末尾追加一个’\0’</li><li>函数的返回值是写入的长度，但不包括最后的’\0’</li></ul><p><strong>注意：实际编程中不要再使用该函数，请使用 <a href="http://bbs.fishc.com/thread-49693-1-1.html">StringCchPrintf</a> 或 StringCbPrint 代替。</strong></p><h3 id="API-函数原型：-26"><a href="#API-函数原型：-26" class="headerlink" title="API 函数原型："></a><strong>API 函数原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">wsprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  LPTSTR lpOut,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   LPCTSTR lpFmt,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-26"><a href="#参数解析：-26" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpOut</td><td>1. 指定格式化数据将要写入的缓冲区 2. 缓冲区限定最大为 1024 字节</td></tr><tr><td>lpFmt</td><td>1. 格式化字符串 2. 与 printf 的格式化字符串基本一致，但不支持浮点数</td></tr><tr><td>…</td><td>可变参数，参数的个数取决 lpFmt 参数</td></tr></tbody></table><h3 id="返回值：-26"><a href="#返回值：-26" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果函数调用成功，返回值与计划写入缓冲区的字符个数相等（不包含最后的’\0’）；</p></li><li><p>如果函数调用失败，返回值小于计划写入缓冲区的字符个数，可通过调用 GetLastError 获取详细的错误信息。</p></li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="MSG-结构"><a href="#MSG-结构" class="headerlink" title="MSG 结构"></a>MSG 结构</h2><h3 id="MSG-消息结构"><a href="#MSG-消息结构" class="headerlink" title="MSG 消息结构"></a><strong>MSG 消息结构</strong></h3><p>在 Windows 程序中，消息是由 MSG 结构体来表示的。</p><h3 id="结构原型："><a href="#结构原型：" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">  HWND   hwnd;</span><br><span class="line">  UINT   message;</span><br><span class="line">  WPARAM wParam;</span><br><span class="line">  LPARAM lParam;</span><br><span class="line">  DWORD  time;</span><br><span class="line">  POINT  pt;</span><br><span class="line">&#125; MSG, *PMSG, *LPMSG;</span><br></pre></td></tr></table></figure><h3 id="成员解析："><a href="#成员解析：" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hwnd</td><td>指定接收消息的窗口句柄 如果是线程消息，该值是 NULL</td></tr><tr><td>message</td><td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式 2. 应用程序消息只能使用低 16 位，高 16 位被系统保留 3. 传送门：<a href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td></tr><tr><td>wParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>lParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>time</td><td>该消息被投放到消息队列的时间</td></tr><tr><td>pt</td><td>当消息被投放到消息队列的时，鼠标位于屏幕中的位置</td></tr></tbody></table><h2 id="PAINTSTRUCT-结构"><a href="#PAINTSTRUCT-结构" class="headerlink" title="PAINTSTRUCT 结构"></a>PAINTSTRUCT 结构</h2><p>PAINTSTRUCT 结构包含一些窗口过程用来对客户区进行绘制的信息。</p><h3 id="结构原型：-1"><a href="#结构原型：-1" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">  HDC  hdc;</span><br><span class="line">  BOOL fErase;</span><br><span class="line">  RECT rcPaint;</span><br><span class="line">  BOOL fRestore;</span><br><span class="line">  BOOL fIncUpdate;</span><br><span class="line">  BYTE rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-1"><a href="#成员解析：-1" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>用于绘制的设备环境句柄</td></tr><tr><td>fErase</td><td>1. 表示背景是否必须擦除，如果为非零值则擦除背景，否则不擦除背景 2. 如果创建窗口类的时候没有设置背景画刷，则负责擦除背景</td></tr><tr><td>rcPaint</td><td>一个 <a href="http://bbs.fishc.com/thread-47745-1-1.html">RECT 结构</a>，指定左上角和右下角的坐标确定一个要绘制的矩形范围</td></tr><tr><td>fRestore</td><td>系统保留</td></tr><tr><td>fIncUpdate</td><td>系统保留</td></tr><tr><td>rgbReserved</td><td>系统保留</td></tr></tbody></table><h2 id="RECT-结构"><a href="#RECT-结构" class="headerlink" title="RECT 结构"></a>RECT 结构</h2><p>RECT 结构定义了一个矩形的左上角和右下角的坐标。</p><h3 id="结构原型：-2"><a href="#结构原型：-2" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RECT</span> &#123;</span></span><br><span class="line">  LONG left;</span><br><span class="line">  LONG top;</span><br><span class="line">  LONG right;</span><br><span class="line">  LONG bottom;</span><br><span class="line">&#125; RECT, *PRECT;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-2"><a href="#成员解析：-2" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>left</td><td>指定矩形左上角的 x 坐标</td></tr><tr><td>top</td><td>指定矩形左上角的 y 坐标</td></tr><tr><td>right</td><td>指定矩形右下角的 x 坐标</td></tr><tr><td>bottom</td><td>指定矩形右下角的 y 坐标</td></tr></tbody></table><h2 id="TEXTMETRIC-结构"><a href="#TEXTMETRIC-结构" class="headerlink" title="TEXTMETRIC 结构"></a>TEXTMETRIC 结构</h2><p>TEXTMETRIC 结构记录当前设备环境中有关字体的各种信息。</p><p>TEXTMETRIC 结构成员的值的单位取决于设备环境中当前选定的映射模式，默认的映射模式是 MM_TEXT，所以它们的值是以像素为单位的。</p><h3 id="结构原型：-3"><a href="#结构原型：-3" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRIC</span> &#123;</span></span><br><span class="line">  LONG  tmHeight;</span><br><span class="line">  LONG  tmAscent;</span><br><span class="line">  LONG  tmDescent;</span><br><span class="line">  LONG  tmInternalLeading;</span><br><span class="line">  LONG  tmExternalLeading;</span><br><span class="line">  LONG  tmAveCharWidth;</span><br><span class="line">  LONG  tmMaxCharWidth;</span><br><span class="line">  LONG  tmWeight;</span><br><span class="line">  LONG  tmOverhang;</span><br><span class="line">  LONG  tmDigitizedAspectX;</span><br><span class="line">  LONG  tmDigitizedAspectY;</span><br><span class="line">  TCHAR tmFirstChar;</span><br><span class="line">  TCHAR tmLastChar;</span><br><span class="line">  TCHAR tmDefaultChar;</span><br><span class="line">  TCHAR tmBreakChar;</span><br><span class="line">  BYTE  tmItalic;</span><br><span class="line">  BYTE  tmUnderlined;</span><br><span class="line">  BYTE  tmStruckOut;</span><br><span class="line">  BYTE  tmPitchAndFamily;</span><br><span class="line">  BYTE  tmCharSet;</span><br><span class="line">&#125; TEXTMETRIC, *PTEXTMETRIC;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-3"><a href="#成员解析：-3" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>tmHeight</td><td>字符高度（tmAscent + tmDescent）</td></tr><tr><td>tmAscent</td><td>字符上部高度（基线以上）</td></tr><tr><td>tmDescent</td><td>字符下部高度（基线以下）</td></tr><tr><td>tmInternalLeading</td><td>内部间距（包含在 tmHeight 中），该间距通常被用于显示重音符号</td></tr><tr><td>tmExternalLeading</td><td>外部间距，这个值是字体设计者建议在两行文字间留出的空间大小</td></tr><tr><td>tmAveCharWidth</td><td>1. 字体中小写字符的平均宽度（一般定义为字母 x 的宽度） 2. 字体中大写字符的平均宽度一般是该值的 1.5 倍计算 3. 此值不包括字体所需要的加粗和倾斜字符</td></tr><tr><td>tmMaxCharWidth</td><td>字体中最宽字符的宽度</td></tr><tr><td>tmWeight</td><td>字体的粗细轻重程度</td></tr><tr><td>tmOverhang</td><td>加入某些拼接字体上的附加高度</td></tr><tr><td>tmDigitizedAspectX</td><td>字体设计所针对的设备水平方向</td></tr><tr><td>tmDigitizedAspectY</td><td>字体设计所针对的设备垂直方向</td></tr><tr><td>tmFirstChar</td><td>为字体定义的第一个字符</td></tr><tr><td>tmLastChar</td><td>为字体定义的最后一个字符</td></tr><tr><td>tmDefaultChar</td><td>字体中所没有字符的替代字符</td></tr><tr><td>tmBreakChar</td><td>定义文本对齐截断操作所显示的字符</td></tr><tr><td>tmItalic</td><td>如果该值非零，则为斜体字体</td></tr><tr><td>tmUnderlined</td><td>如果该值非零，则为带下横线字体</td></tr><tr><td>tmStruckOut</td><td>如果该值非零，则为带删除线字体（字符中间画一条线）</td></tr><tr><td>tmPitchAndFamily</td><td>1. 如果低位为 0，表示等宽字体，小写和大写字母平均宽度一样 2. 如果低位为 1，表示变宽字体，大写字母是小写平均宽度的 3/2 倍</td></tr><tr><td>tmCharSet</td><td>字体的字符集</td></tr></tbody></table><h2 id="WNDCLASS-结构"><a href="#WNDCLASS-结构" class="headerlink" title="WNDCLASS 结构"></a>WNDCLASS 结构</h2><p>​        Windows 的窗口总是基于窗口类来创建的，窗口类同时确定了处理窗口消息的窗口过程（回调函数）。</p><p>​        在创建应用程序窗口之前，必须调用 RegisterClass 函数来注册窗口类。该函数只需要一个参数，即指向 WNDCLASS 窗口类的指针。因为 WNDCLASS 类包含了窗口所拥有的基本属性。</p><h3 id="结构原型：-4"><a href="#结构原型：-4" class="headerlink" title="结构原型："></a><strong>结构原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSW</span> &#123;</span></span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;</span><br><span class="line">    <span class="keyword">int</span>         cbClsExtra;</span><br><span class="line">    <span class="keyword">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;</span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;</span><br><span class="line">    LPCWSTR     lpszMenuName;</span><br><span class="line">    LPCWSTR     lpszClassName;</span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;</span><br></pre></td></tr></table></figure><h3 id="成员解析：-4"><a href="#成员解析：-4" class="headerlink" title="成员解析："></a><strong>成员解析：</strong></h3><table><thead><tr><th><strong>成员</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>style</td><td>指定窗口类型，各种“类风格”（详见下方↓）可以使用按位或操作符组合起来</td></tr><tr><td>lpfnWndProc</td><td>指定窗口过程（必须是回调函数）</td></tr><tr><td>cbClsExtra</td><td>预留的额外空间，一般为 0</td></tr><tr><td>cbWndExtra</td><td>预留的额外空间，一般为 0</td></tr><tr><td>hInstance</td><td>应用程序的实例句柄</td></tr><tr><td>hIcon</td><td>为所有基于该窗口类的窗口设定一个图标</td></tr><tr><td>hCursor</td><td>为所有基于该窗口类的窗口设定一个鼠标指针</td></tr><tr><td>hbrBackground</td><td>指定窗口背景色</td></tr><tr><td>lpszMenuName</td><td>指定窗口菜单</td></tr><tr><td>lpszClassName</td><td>指定窗口类名</td></tr></tbody></table><h3 id="style-类风格解析"><a href="#style-类风格解析" class="headerlink" title="style 类风格解析"></a><strong>style 类风格解析</strong></h3><table><thead><tr><th><strong>类风格</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>CS_VREDRAW</td><td>移动或者调整窗口的高度（垂直方向）时，重绘整个窗口</td></tr><tr><td>CS_HREDRAW</td><td>移动或者调整窗口的宽度（水平方向）时，重绘整个窗口</td></tr><tr><td>CS_DBLCLKS</td><td>当用户光标在窗口内双击时，允许发送双击消息给窗口过程</td></tr><tr><td>CS_OWNDC</td><td>给予每个窗口实例分配一个唯一的 DC（注意，尽管这样是很方便，但它必须慎重使用，因为每个 DC 大约要占 800 个字节的内存）</td></tr><tr><td>CS_CLASSDC</td><td>该窗口类的所有窗口实例都共享一个窗口类 DC</td></tr><tr><td>CS_PARENTDC</td><td>1. 将子窗口的裁剪区域设置到父窗口的 DC 中去，这样子窗口便可以在父窗口上绘制自身。（注意，这是子窗口从系统缓存中获取 DC，而不是使用父窗口的 DC。） 2. 指定该风格可以提高系统性能</td></tr><tr><td>CS_NOCLOSE</td><td>禁止系统菜单的关闭选项</td></tr><tr><td>CS_SAVEBITS</td><td>1. 以位图形式保存被该窗口遮挡的屏幕部分，当给窗口移动以后，系统便可以用该保存的位图恢复屏幕移动的相应部分，从而系统不用向被该窗口遮挡的窗口发送 WM_PAINT 消息 2. 该特性对于菜单类型的窗口比较合适，因为它通常是简短的显示一下之后便消失 3. 设置该特性将增加显示该窗口的时间，因为它通常要先分配保存位图的内存</td></tr><tr><td>CS_BYTEALIGNCLIENT</td><td>在字节边界上（在 x 方向上）定位窗口的用户区域的位置</td></tr><tr><td>CS_BYTEALIGNWINDOW</td><td>在字节边界上（在 x 方向上）定位窗口的位置</td></tr><tr><td>CS_GLOBALCLASS</td><td>1. 当调用 CreateWindow 或 CreateWindowEx 函数来创建窗口时允许它的 hInstance 参数和注册窗口类时传递给 RegisterClass 的 hInstance 参数不同 2. 如果不指定该风格，则这两个 hInstance 必须相同</td></tr></tbody></table><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="GET-X-LPARAM-和-GET-Y-LPARAM-宏"><a href="#GET-X-LPARAM-和-GET-Y-LPARAM-宏" class="headerlink" title="GET_X_LPARAM 和 GET_Y_LPARAM 宏"></a>GET_X_LPARAM 和 GET_Y_LPARAM 宏</h2><p>原文链接（GET_X_LPARAM）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632654(v=vs.85).aspx">传送门</a></p><p>原文链接（GET_Y_LPARAM）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632655(v=vs.85).aspx">传送门</a></p><h3 id="宏功能："><a href="#宏功能：" class="headerlink" title="宏功能："></a><strong>宏功能：</strong></h3><p>通过 lParam 参数获得相关消息触发的坐标 (x , y)</p><h3 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a><strong>宏定义：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GET_X_LPARAM</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">……</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GET_Y_LPARAM</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-27"><a href="#参数解析：-27" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lParam</td><td>将要被转换的 lParam 参数</td></tr></tbody></table><h3 id="返回值：-27"><a href="#返回值：-27" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>GET_X_LPARAM(lParam) 返回坐标的 x 值；</p></li><li><p>GET_Y_LPARAM(lParam) 返回坐标的 y 值。</p></li></ol><h3 id="重要备注："><a href="#重要备注：" class="headerlink" title="重要备注："></a><strong>重要备注：</strong></h3><ol><li><p>使用该宏需要包含头文件：windowsx.h。</p></li><li><p>不要再使用 LOWORD 和 HIWORD 去获取鼠标的坐标了，因为在多显示器的情况下会得到错误的坐标。</p></li></ol><h2 id="SUCCEEDED-和-FAILED-宏"><a href="#SUCCEEDED-和-FAILED-宏" class="headerlink" title="SUCCEEDED 和 FAILED 宏"></a>SUCCEEDED 和 FAILED 宏</h2><p>原文链接（SUCCEEDED）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687197(v=vs.85).aspx">传送门</a></p><p>原文链接（FAILED）-&gt; <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms693474(v=vs.85).aspx">传送门</a></p><h3 id="宏功能：-1"><a href="#宏功能：-1" class="headerlink" title="宏功能："></a><strong>宏功能：</strong></h3><p>SUCCEEDED 宏表示测试成功，FAILED 宏表示测试失败。</p><h3 id="宏原型："><a href="#宏原型：" class="headerlink" title="宏原型："></a><strong>宏原型：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SUCCEEDED</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HRESULT hr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">……</span><br><span class="line"><span class="function">BOOL <span class="title">FAILED</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HRESULT hr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数解析：-28"><a href="#参数解析：-28" class="headerlink" title="参数解析："></a><strong>参数解析：</strong></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hr</td><td>1. 状态码 2. 该值可以是 HRESULT 或 SCODE 类型 3. 非负数表示成功 4. 负数表示失败</td></tr></tbody></table><h3 id="返回值：-28"><a href="#返回值：-28" class="headerlink" title="返回值："></a><strong>返回值：</strong></h3><ol><li><p>如果 hr 的值大于等于 0，则结果为 TRUE；</p></li><li><p>如果 hr 的值小于 0，则结果为 FALSE。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WinAPI文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> WinAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客美化</title>
      <link href="2021/03/14/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
      <url>2021/03/14/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="更改公告内容-gif图片"><a href="#更改公告内容-gif图片" class="headerlink" title="更改公告内容+gif图片"></a>更改公告内容+gif图片</h1><p>在主题配置文件中搜索 card_announcement </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span> <span class="string">//公告内容</span></span><br></pre></td></tr></table></figure><p>更改后</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">欢迎来到yui1111的博客！&lt;img</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/rigodlee/BLOGCDN/img/20150404H5648_ZuzhL.gif&quot;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://imgtu.com/i/603iAU"><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/03/14/603iAU.png" alt="603iAU.png"></a></p><h1 id="更换头像与背景图像"><a href="#更换头像与背景图像" class="headerlink" title="更换头像与背景图像"></a>更换头像与背景图像</h1><p>打开主题配置文件，搜索<code>Avatar</code>往下一排全是关于博客头像背景图片之类的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github 个人博客搭建</title>
      <link href="2021/03/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>2021/03/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="会使用到的工具"><a href="#会使用到的工具" class="headerlink" title="会使用到的工具"></a>会使用到的工具</h2><ul><li><p>node.js</p></li><li><p>sublime</p></li><li><p>git</p></li></ul><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>首先我们首先在node.js的<a href="https://nodejs.org/zh-cn/download/">官网</a>下载</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHuC9.png" alt="1"></p><p>使用其他平台的用户可根据自己的需求下载哦（图片为Windows平台）</p><p>下载完成后，一路next就能安装成功。</p><h4 id="检查安装情况"><a href="#检查安装情况" class="headerlink" title="检查安装情况"></a>检查安装情况</h4><ul><li><strong>node.js</strong></li></ul><p>打开Windows 命令处理程序输入node -v</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHm4J.png" alt="2"></p><p>出现版本号即为安装成功</p><ul><li><strong>npm</strong></li></ul><p>继续在Windows 命令处理程序输入npm -v</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHABT.png" alt="3"></p><p>出现版本号即为安装成功</p><h3 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h3><p>直接到<a href="http://www.sublimetext.com/3">sublime官网</a>下载。建议安装在与博客文件同一文件夹中。</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="下载和安装-1"><a href="#下载和安装-1" class="headerlink" title="下载和安装"></a>下载和安装</h4><ul><li><p><strong>下载</strong></p><p>下载git可直接去git**<a href="">官网</a>**下载。进入官网后点击download。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHMg1.png" alt="4"></p></li><li><p><strong>安装</strong></p></li></ul><ol><li><p>下载完成后打开进入此界面（因为我已经安装过git所以图中下面会多显示Only show new options ）</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHQjx.png" alt="5"></p></li><li><p>安装路径——选择自己想安装的位置就行。</p></li><li><p>安装git组件，图中框起来的为默认选中的组件，根据自己的需求勾选好后，选择下一步。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqH1u6.png" alt="6"></p></li><li><p>菜单文件夹，直接选择默认就行。</p></li><li><p>选择git的默认编辑器</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqH3DK.png" alt="7"></p></li><li><p>选择仓库的初始名称。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqH8HO.png" alt="8"></p></li><li><p>修改系统的环境变量</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHYUe.png" alt="9"></p></li><li><p>SSL的证书选择</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHt4H.png" alt="10"></p></li><li><p>配置行尾结束符，默认为unix格式，可根据自己的情况选择</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHUCd.png" alt="11"></p></li><li><p>配置终端仿真，建议第一个</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHa8A.png" alt="12"></p></li><li><p>其他配置，默认即可。</p></li><li><p>安装完成后点击鼠标右键会出现<strong>Git GUI Here</strong>和<strong>Git Bash Here</strong>两个选项</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHwvt.png" alt="13"></p></li></ol><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>在自己想安装hexo的位置新建一个叫blog的文件夹。创建完成后使用Windows命令窗口进入blog的文件夹中。</p><p>使用npm命令安装hexo，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHdgI.png" alt="14"></p><p>安装完成后再输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog  &#x2F;&#x2F;blog可替换成你想要的名字</span><br></pre></td></tr></table></figure><p>进行初始化</p><p>​    <img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHBKP.png" alt="15"></p><p>出现 Start blogging with Hexo！即为成功。</p><p>进入第二个一创建好的blog文件夹，按顺序输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello Hexo&#x2F;&#x2F;新建一篇名为“hello Hexo”的博客</span><br><span class="line">hexo g&#x2F;&#x2F;生成静态文件</span><br><span class="line">hexo s&#x2F;&#x2F;本地部署预览</span><br></pre></td></tr></table></figure><p>完成后输入localhost:4000可进行本地访问。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHJED.png" alt="16"></p><h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><h3 id="GitHub仓库创建"><a href="#GitHub仓库创建" class="headerlink" title="GitHub仓库创建"></a>GitHub仓库创建</h3><p>首先要有一个GitHub的账号。</p><p>登录后点击左上角的new，创建新的仓库。进入仓库后输入仓库名称，必须要与owner下的名称一致，输入完成后即可（因为我之前已经创建过了仓库，所以提示）</p><p>​    <img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqHK3R.png" alt="17"></p><h3 id="GitHubSSH配置"><a href="#GitHubSSH配置" class="headerlink" title="GitHubSSH配置"></a>GitHubSSH配置</h3><p>打开git bash输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config –global user.email “xxx@qq.com“ &#x2F;&#x2F;填写注册github的邮箱</span><br><span class="line"></span><br><span class="line">git config –global user.name “xxxx” &#x2F;&#x2F;github 用户名</span><br><span class="line"></span><br><span class="line">ssh-keygen &#x2F;&#x2F;输入完这个就一致enter就行了</span><br></pre></td></tr></table></figure><p>完成后进入用户目录下的.ssh文件夹，打开id_rsa.pub，复制里面的内容。</p><p>进入GitHub，鼠标移动到右上角头像处，点击settings，之后再点击左边 SSH and GPG keys。创建一个新的SSH即可。</p><h3 id="Hexo与GitHub连接"><a href="#Hexo与GitHub连接" class="headerlink" title="Hexo与GitHub连接"></a>Hexo与GitHub连接</h3><p>在站点文件夹中打开_config.yml，将Deployment改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;yui1111&#x2F;yui1111.github.io.git &#x2F;&#x2F;改为自己GitHub中的https链接</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2021/01/25/sqLBK1.png" alt="18"></p><p>将”url”后改为“<a href="https://github项目名&quot;/">https://github项目名&quot;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;example.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;yui1111.github.io &#x2F;&#x2F;改这个</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure><p>安装插件，上传博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">git config --global user.email &quot;github邮箱&quot;</span><br><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>输入网址如<a href="https://yui1111.github.io后等待一会即可进入./">https://yui1111.github.io后等待一会即可进入。</a></p><p>至此搭建过程结束。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
